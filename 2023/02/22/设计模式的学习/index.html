<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="理论设计模式从何而来模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案 软件设计模式Gang of Four提出了软件设计模式Gof提出的设计模式有23个，包括  创建型模式：如何创建对象 结构型模式：如何实现类或者对象的组合 行为型模式：类或者对象怎么交互以及怎样分配职责">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式的学习">
<meta property="og:url" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="理论设计模式从何而来模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案 软件设计模式Gang of Four提出了软件设计模式Gof提出的设计模式有23个，包括  创建型模式：如何创建对象 结构型模式：如何实现类或者对象的组合 行为型模式：类或者对象怎么交互以及怎样分配职责">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/16.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/17.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/14.png">
<meta property="og:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/15.png">
<meta property="article:published_time" content="2023-02-22T06:54:48.000Z">
<meta property="article:modified_time" content="2023-02-22T06:57:12.957Z">
<meta property="article:author" content="安妮的心动录">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="后端学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png">

<link rel="canonical" href="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>设计模式的学习 | 安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式的学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 14:54:48 / 修改时间：14:57:12" itemprop="dateCreated datePublished" datetime="2023-02-22T14:54:48+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h3 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h3><p>模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，<strong>设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案</strong></p>
<h3 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h3><p><strong>Gang of Four提出了软件设计模式</strong><br>Gof提出的设计模式有23个，包括</p>
<ul>
<li>创建型模式：如何创建对象</li>
<li>结构型模式：如何实现类或者对象的组合</li>
<li>行为型模式：类或者对象怎么交互以及怎样分配职责</li>
</ul>
<p>“简单工厂模式”不属于23种<br>设计模式：GOF的23种+简单工厂模式<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/16.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/17.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" alt="image.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计原则是设计模式的核心思想，一共有七种</p>
<ul>
<li>单一职责原则： 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个</li>
<li><strong>开闭原则</strong>：类的改动<strong>是通过增加代码</strong>进行的，而不是修改源代码</li>
<li>里氏代换原则：任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能</li>
<li><strong>依赖倒转原则</strong>：依赖于抽象（接口），不要依赖具体的实现（类），也就是<strong>针对接口</strong>编程</li>
<li>接口隔离原则：不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去</li>
<li>合成复用原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合</li>
<li><strong>迪米特法则</strong>：<strong>一个对象应当对其他对象尽可能少的了解</strong>，从而降低各个对象之间的耦合，提高系统的可维护性，例如在一个程序中，各个模块相互调用时，通常会提供一个同一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变的时候，不会影响其他模块的使用（黑盒原理）</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>类的职责是单一的，对外只提供一种功能，而引起类变化的原因也应该只有一个<br>在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂<br><strong>一个类对外只提供一种功能</strong><br><strong>实例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 以下代码不遵循单一职责原则，一个类实现了多个功能</span><br><span class="line">// 即一个clothes结构体实现了“工作装扮”和“逛街装扮”两个方法</span><br><span class="line">type Clothes struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (c *Clothes) Style() &#123;</span><br><span class="line">//	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (c *Clothes) Style2() &#123;</span><br><span class="line">//	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	c := Clothes&#123;&#125;</span><br><span class="line">//	c.Style()</span><br><span class="line">//	c.Style2()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 单一职责原则</span><br><span class="line">// 每一个类（结构体）负责一个功能或者一个逻辑</span><br><span class="line"></span><br><span class="line">type ClothesShop struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClothesWork struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesWork) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesShop) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := ClothesWork&#123;&#125;</span><br><span class="line">	c.Style()</span><br><span class="line">	c1 := ClothesShop&#123;&#125;</span><br><span class="line">	c1.Style()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则的核心思想就是当我们添加一个新功能的时候，不是通过修改代码，而是通过增添代码来实现的。<br>如果我们使用接口<code>interface</code>就可以进行一层抽象，然后提供一个抽象的方法供业务进行实现。<br><strong>增加功能的时候去增加代码而不是修改代码</strong><br><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码是平铺式设计 每当添加一个业务就需要增加方法 会导致Banker类越来越臃肿</span><br><span class="line">// 不符合开闭原则  每当有新的功能出现就要对类添加对应功能的代码</span><br><span class="line">// 当Banker业务越多再修改Banker的业务或者添加新业务的时候 出现问题的问题也会越来越大</span><br><span class="line">// 耦合度太高 Banker的职责也不够单一 代码的维护成本与业务的复杂程度成正比</span><br><span class="line"></span><br><span class="line">//type Banker struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Save() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 存款业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Transfer() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 转账业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Pay() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 支付业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 新增的Deal服务</span><br><span class="line">//func (b *Banker) Deal() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 交易业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">// banker := &amp;Banker&#123;&#125;</span><br><span class="line">// banker.Save()</span><br><span class="line">// banker.Transfer()</span><br><span class="line">// banker.Pay()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 开闭原则</span><br><span class="line">// 在Go中的描述就是通过接口实现多态，每个类去实现接口</span><br><span class="line">// 这样的话就能实现一个结果：类的改动是通过增加代码进行的，而不是修改源代码</span><br><span class="line"></span><br><span class="line">type AbstractBanker interface &#123;</span><br><span class="line">   Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SaveBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SaveBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了存款&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加转账功能</span><br><span class="line"></span><br><span class="line">type TransferBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tb *TransferBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了转账&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以基于抽象层进行业务封装-针对interface接口进行封装</span><br><span class="line"></span><br><span class="line">func BankBusiness(banker AbstractBanker) &#123;</span><br><span class="line">   banker.Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sb := SaveBanker&#123;&#125;</span><br><span class="line">   sb.Business()</span><br><span class="line">   tb := TransferBanker&#123;&#125;</span><br><span class="line">   tb.Business()</span><br><span class="line">   BankBusiness(&amp;sb)</span><br><span class="line">   BankBusiness(&amp;tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>在设计一个系统的时候我们可以将模块分成三个层次，抽象层、实现层、业务逻辑层。我们首先将抽象层的模块和接口定义出来，然后通过interface接口的设计依照抽象层依次实现每个实现层的模块，在我们写实现层代码的时候，实际上只需要参考对应的抽象层，实现每个模块。而业务逻辑层也是通过抽象层暴露出来的接口进行实现的，可以使用的方法就是抽象层暴露出来的方法<br><strong>模块与模块之间依赖抽象而不是具体实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码耦合度很高，不满足依赖倒转原则</span><br><span class="line">// 如果要满足张三开宝马，李四开奔驰，就需要重新添加代码</span><br><span class="line">// 如果司机人数为m，汽车数量为n，那么需要编写的方法为m*n</span><br><span class="line"></span><br><span class="line">//type Benz struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Benz) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;Benz is running&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type BMW struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *BMW) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;BMW is runnning&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Zhang3 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (z *Zhang3) DriveBenz(benz *Benz) &#123;</span><br><span class="line">//	benz.Run()</span><br><span class="line">//	fmt.Println(&quot;Zhang3 is driving Benz&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Li4 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (l *Li4) DriveBMW(bmw *BMW) &#123;</span><br><span class="line">//	bmw.Run()</span><br><span class="line">//	fmt.Println(&quot;Li4 is driving BMW&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	benz := &amp;Benz&#123;&#125;</span><br><span class="line">//	zhang3 := Zhang3&#123;&#125;</span><br><span class="line">//	zhang3.DriveBenz(benz)</span><br><span class="line">//	bmw := &amp;BMW&#123;&#125;</span><br><span class="line">//	li4 := Li4&#123;&#125;</span><br><span class="line">//	li4.DriveBMW(bmw)</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Car interface &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Driver interface &#123;</span><br><span class="line">	Driver(car Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">// 每个车子都实现Run方法</span><br><span class="line">// 每个司机都实现Drive方法</span><br><span class="line">// 这样需要实现的方法为m+n </span><br><span class="line">// 而且实现层只依赖于抽象层</span><br><span class="line">type Benz struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Benz) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;Benz is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BMW struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *BMW) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;BMW is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Zhang3 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (z3 *Zhang3) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Li4 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l4 *Li4) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;li4 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var benz Car = new(Benz)</span><br><span class="line">	z := new(Zhang3)</span><br><span class="line">	z.Drive(benz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。<br><strong>使用组合来实现父类方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cat) Eat() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫吃饭&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用继承来实现 添加一个睡觉的方法</span><br><span class="line"></span><br><span class="line">type CatB struct &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CatB) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用组合来添加可睡觉的方法</span><br><span class="line"> </span><br><span class="line">type CatC struct &#123;</span><br><span class="line">	C *Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cc *CatC) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	c := &amp;Cat&#123;&#125;</span><br><span class="line">	c.Eat()</span><br><span class="line">	cb := &amp;CatB&#123;&#125;</span><br><span class="line">	cb.Eat()</span><br><span class="line">	cb.Sleep()</span><br><span class="line">	cc := &amp;CatC&#123;&#125;</span><br><span class="line">	cc.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>依赖第三方进行解耦</strong></p>
<h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p>接口的意义就是实现多态的思想，我们可以根据interface类型来设计API接口，那么这种API接口的适应能力不仅能够适应当下所实现的全部模块，也适应未来实现的模块来进行调用。<code>**调用未来**</code>也许是接口最大的意义所在，良好的架构师可以针对interface进行设计一套框架，在未来的许多年后仍然可以适用</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" alt="image.png"><br>思想就是可以通过添加一层<strong>工厂模块</strong>，来做到业务逻辑层和基础模块层之间的耦合，避免业务逻辑层对基础模块层的直接依赖。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式并不属于GoF的23种设计模式，它是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：</p>
<ul>
<li>工厂：简单工厂模式的核心，它负责创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需要的产品对象</li>
<li>抽象产品：简单工厂模式所创建的所有对象的分类，它负责描述实例所公有的公共接口</li>
<li>具体产品：简单工厂模式所创建的具体实例对象</li>
</ul>
<p>设计模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Fruit interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type Apple struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Apple) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Banana struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Banana) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pear struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pear) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂模块</span><br><span class="line"></span><br><span class="line">type Factory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Factory) CreateFruit(kind string) Fruit &#123;</span><br><span class="line">	var fruit Fruit</span><br><span class="line">	if kind == &quot;apple&quot; &#123;</span><br><span class="line">		fruit = new(Apple)</span><br><span class="line">	&#125; else if kind == &quot;banana&quot; &#123;</span><br><span class="line">		fruit = new(Banana)</span><br><span class="line">	&#125; else if kind == &quot;pear&quot; &#123;</span><br><span class="line">		fruit = new(Pear)</span><br><span class="line">	&#125;</span><br><span class="line">	return fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	factory := new(Factory)</span><br><span class="line">	apple := factory.CreateFruit(&quot;apple&quot;)</span><br><span class="line">	apple.Show()</span><br><span class="line">	banana := factory.CreateFruit(&quot;banana&quot;)</span><br><span class="line">	banana.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>实现了对象创建和使用的分离</li>
<li>不需要记住具体类名，记住参数就可以，减少使用者记忆量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对工厂职责过重，一旦不能工作，系统会受到影响</li>
<li>增加系统中类的个数，复杂度和理解度增加</li>
<li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的逻辑太复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>抽象工厂：工厂的核心，任何工厂类都必须实现这个接口</li>
<li>工厂：具体工厂是抽象工厂的一个实现，负责实例化产品对象</li>
<li>抽象产品：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品：工厂方法模式所创建的具体实例对象</li>
</ul>
<p>简单工厂+开闭原则&#x3D;工厂<br>模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type fruit interface &#123;</span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂类（抽象的接口）</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateFruit() fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基础模块层</span><br><span class="line"></span><br><span class="line">type apple struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *apple) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type banana struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *banana) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type pear struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *pear) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AppleFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *AppleFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(apple)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BananaFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *BananaFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(banana)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PearFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *PearFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(pear)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line">func main() &#123;</span><br><span class="line">	//需求1 需要一个具体的苹果对象</span><br><span class="line">	//需要一个具体的苹果工厂</span><br><span class="line">	var a AbstractFactory</span><br><span class="line">	a = new(AppleFactory)</span><br><span class="line">	//生产一个具体的水果</span><br><span class="line">	var apple fruit</span><br><span class="line">	apple = a.CreateFruit()</span><br><span class="line">	apple.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>不需要记住具体类名，甚至连具体参数都不用记忆</li>
<li>实现了对象创建和使用的分离</li>
<li>系统的可拓展性也变得非常好，不需要修改接口和原类</li>
<li>对于新产品的创建，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加系统中的类的个数，复杂度和理解度增加</li>
<li>增加了系统的抽象性</li>
</ul>
<p><strong>适用场景</strong></p>
<ol>
<li>客户端不知道它所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定创建哪个对象</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。因此，可以将一些相关的产品组成一个“产品族”，从而由同一个工厂来统一生产。</p>
<ul>
<li>抽象工厂：它声明了一组用于创建一组产品的方法，每一个方法对应一种产品</li>
<li>具体工厂：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某在产品等级结构中</li>
<li>抽象产品：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li>
<li>具体产品：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li>
</ul>
<p>模式例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type AbstractApple interface &#123;</span><br><span class="line">	ShowApple()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractBanana interface &#123;</span><br><span class="line">	ShowBanana()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractPear interface &#123;</span><br><span class="line">	ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的工厂</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateApple() AbstractApple</span><br><span class="line">	CreateBanana() AbstractBanana</span><br><span class="line">	CreatePear() AbstractPear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type ChinaApple struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaBanana struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaPear struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ca *ChinaApple) ShowApple() &#123;</span><br><span class="line">	fmt.Println(&quot;china apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cb *ChinaBanana) ShowBanana() &#123;</span><br><span class="line">	fmt.Println(&quot;china banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cp *ChinaPear) ShowPear() &#123;</span><br><span class="line">	fmt.Println(&quot;china pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateApple() AbstractApple &#123;</span><br><span class="line">	var apple AbstractApple</span><br><span class="line">	apple = new(ChinaApple)</span><br><span class="line">	return apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;</span><br><span class="line">	var b AbstractBanana</span><br><span class="line">	b = new(ChinaBanana)</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreatePear() AbstractPear &#123;</span><br><span class="line">	var p AbstractPear</span><br><span class="line">	p = new(ChinaPear)</span><br><span class="line">	return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 需要中国的水果</span><br><span class="line">	//1. 创建中国工厂</span><br><span class="line">	var cF AbstractFactory</span><br><span class="line">	cF = new(ChinaFactory)</span><br><span class="line">	var cApple AbstractApple</span><br><span class="line">	cApple = cF.CreateApple()</span><br><span class="line">	cApple.ShowApple()</span><br><span class="line">	var cBanana AbstractBanana</span><br><span class="line">	cBanana = cF.CreateBanana()</span><br><span class="line">	cBanana.ShowBanana()</span><br><span class="line">	var cPear AbstractPear</span><br><span class="line">	cPear = cF.CreatePear()</span><br><span class="line">	cPear.ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>用于工厂方法模式的优点</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li>
</ol>
<p>缺点</p>
<ol>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了”开闭原则“</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族，可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>产品等级结构稳定。设计完成之后，不会像系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<h3 id="三种工厂的区别"><a href="#三种工厂的区别" class="headerlink" title="三种工厂的区别"></a>三种工厂的区别</h3><ul>
<li>简单工厂：一个工厂负责创建所有产品，违反开闭原则，添加新产品需要修改工厂逻辑，工厂会变得越来越复杂</li>
<li>工厂：一个工厂创建一个产品，系统的可扩展性非常好，无需修改接口和类，但是系统中类的个数变多，复杂度和理解度增加</li>
<li>抽象工厂：一个工厂创建一系列（同一个产品族）的产品，增加新的产品族很方便，无需修改已有系统，符合开闭原则，增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，违背了开闭原则，相当于在工厂方法的模式下进行了折中，如果产品结构等级稳定，那么就相当于完全遵循开闭</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。<br>要解决的问题是：保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。<br>类图：<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//三个要点</span><br><span class="line">// 某个类只能有一个实例</span><br><span class="line">// 它必须自行创建这个实例</span><br><span class="line">// 必须自行向整个系统提供这个实例</span><br><span class="line"></span><br><span class="line">// 总结：一个类永远只能有一个对象，这个对象还能被系统的其他模块使用</span><br><span class="line"></span><br><span class="line">//1. 因为这个类必须保证私有化 所以首字母要小写</span><br><span class="line">type singelton struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 2.指针只能指向这个唯一对象，但是这个指针不能改变方向，也必须小写</span><br><span class="line">var instance *singelton = new(singelton)</span><br><span class="line"></span><br><span class="line">// 3.对外提供一个方法来获取到这个对象 把instance的写权限去掉 只暴露读权限</span><br><span class="line"></span><br><span class="line">func GetInstance() *singelton &#123;</span><br><span class="line">	return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *singelton) DoSomeThing() &#123;</span><br><span class="line">	fmt.Println(&quot;Do something&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := GetInstance()</span><br><span class="line">	s.DoSomeThing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 懒汉式的单例模式:只有被第一次访问的时候 才给instance赋值 平常为nil</span><br><span class="line">// 但是懒汉式可能有并发问题： 同时有两个Getinstance同一时刻首次调用 那么就会出现两个instance 可以加锁解决</span><br><span class="line">// 锁的粒度太大了 可以通过一个uint的标记 使用atomic.LoadUnit函数判断 不用每次访问都加锁</span><br><span class="line">// 或者直接使用sync.Once进行new 这是对atomic.LoadUint的封装</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>单例模式提供了对唯一实例的受控访问</li>
<li>节约系统资源，由于在系统内存中只存在一个对象</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩展性差，单利模式中没有抽象层</li>
<li>单例类的职责过重</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统只需要一个实例对象，比如系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li>
<li>客户调用类的单个实力只允许使用一个公共访问点，除了该节点之外，不能通过其他途径访问该实例</li>
</ol>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Proxy模式又叫代理模式，可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。<br>所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类进行交互</p>
<ul>
<li>抽象主题：真实主题与代理主题的共同接口</li>
<li>真实主题：定义了代理角色所代表的真实对象</li>
<li>代理主题角色：含有对真实主题角色的引用，代理角色通常在客户端调用给真实主题对象之前或者之后执行某些操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct &#123;</span><br><span class="line">	Kind string</span><br><span class="line">	Fact bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line">type Shopping interface&#123;</span><br><span class="line">	Buy(goods *Goods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">type KoreaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ks *KoreaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go korea buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AmericaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AmericaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go america buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AfricaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AfricaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go africa buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 海外代理</span><br><span class="line"></span><br><span class="line">type OverSeasProxy struct &#123;</span><br><span class="line">	shopping Shopping</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) Buy(good *Goods) &#123;</span><br><span class="line">	//1.辨别真伪</span><br><span class="line">	if op.distinguish(good) == true &#123;</span><br><span class="line">		op.shopping.Buy(good)</span><br><span class="line">		op.check(good)</span><br><span class="line">	&#125;</span><br><span class="line">	//2.调用具体需要被代理的Buy方法</span><br><span class="line">	//3.海关安检</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辨别真伪</span><br><span class="line">func (op *OverSeasProxy) distinguish(goods *Goods) bool &#123;</span><br><span class="line">	fmt.Println(&quot;对&quot;, goods.Kind, &quot;进行了辨别真伪&quot;)</span><br><span class="line">	if goods.Fact == false &#123;</span><br><span class="line">		fmt.Println(&quot;发现假货&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return goods.Fact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) check(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;通过海关&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewProxy(s Shopping) Shopping &#123;</span><br><span class="line">	return &amp;OverSeasProxy&#123;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g1 := Goods&#123;</span><br><span class="line">		Kind: &quot;韩国面膜&quot;,</span><br><span class="line">		Fact: true,</span><br><span class="line">	&#125;</span><br><span class="line">	g2 := Goods&#123;</span><br><span class="line">		Kind: &quot;苹果&quot;,</span><br><span class="line">		Fact: false,</span><br><span class="line">	&#125;</span><br><span class="line">	var k Shopping = new(KoreaShopping)</span><br><span class="line">	var p Shopping</span><br><span class="line">	p = NewProxy(k)</span><br><span class="line">	p.Buy(&amp;g1)</span><br><span class="line">	var a Shopping = new(AmericaShopping)</span><br><span class="line">	p = NewProxy(a)</span><br><span class="line">	p.Buy(&amp;g2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.能够协调调用者和被调用者，在一定程度上降低了系统的耦合度<br>2.客户端可以针对抽象主题角色进行编程，符合开闭原则，系统具有姣好的灵活性和可拓展性<br>缺点：<br>1.实现较为复杂<br><strong>适用场景</strong><br>为其他对象提供一种代理以控制对这个对象的访问</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式（Decorator）用来动态地给一个对象增加一些额外的职责，比生成子类实现更加灵活<br>装饰模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用模式的时候，我们常常在一个代理类中创建一个对象的实例。并且当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<ul>
<li>抽象构件：是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方法处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件：它是抽象构建类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">type Phone interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的装饰器，装饰器的基础类</span><br><span class="line"></span><br><span class="line">type Decorator struct &#123;</span><br><span class="line">	phone Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Decorator) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的构件</span><br><span class="line"></span><br><span class="line">type Huawei struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (hw *Huawei) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a huawei phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Xiaomi struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (xm *Xiaomi) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a xiaomi phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MoDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md *MoDecorator) Show() &#123;</span><br><span class="line">	md.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a mo phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMoDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;MoDecorator&#123;Decorator&#123;</span><br><span class="line">		p,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KeDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kd *KeDecorator) Show() &#123;</span><br><span class="line">	kd.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a ke phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewKeDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;KeDecorator&#123;Decorator&#123;p&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var hw Phone</span><br><span class="line">	hw = new(Huawei)</span><br><span class="line">	hw.Show()</span><br><span class="line">	var mo Phone</span><br><span class="line">	mo = NewMoDecorator(hw)</span><br><span class="line">	mo.Show()</span><br><span class="line">	var ke Phone</span><br><span class="line">	ke = NewKeDecorator(hw)</span><br><span class="line">	ke.Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰</li>
<li>具体构建类与具体装饰类可以独立变化，符合开闭</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活激动的解决方案，同时意味着排错也比较困难</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式</li>
</ol>
<h3 id="装饰与代理的区别"><a href="#装饰与代理的区别" class="headerlink" title="装饰与代理的区别"></a>装饰与代理的区别</h3><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<ul>
<li>目标抽象类：定义客户所需接口，可以是具体类也可以是抽象接口</li>
<li>适配器类：可以调用另一个接口，作为一个转换器，让目标抽象类和适配者类进行适配</li>
<li>适配者类：被适配的角色，定义了一个已经存在的接口，这个接口需要适配</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type V5 interface &#123;</span><br><span class="line">	Use5V()</span><br><span class="line">&#125;</span><br><span class="line">type V220 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type phone struct &#123;</span><br><span class="line">	v V5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *V220) Use220V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用220V的电压 &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adapter struct &#123;</span><br><span class="line">	v220 *V220</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Adapter) Use5V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用适配器，以220V的电压充电&quot;)</span><br><span class="line">	a.v220.Use220V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPhone(v V5) *phone &#123;</span><br><span class="line">	return &amp;phone&#123;v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAdapter(v220 *V220) *Adapter &#123;</span><br><span class="line">	return &amp;Adapter&#123;v220&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *phone) Charge() &#123;</span><br><span class="line">	fmt.Println(&quot;Phone 进行了充电&quot;)</span><br><span class="line">	p.v.Use5V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	phone := NewPhone(NewAdapter(&amp;V220&#123;&#125;))</span><br><span class="line">	phone.Charge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都很好，可以很方便地更换适配器，符合开闭原则</li>
</ol>
<p>缺点：<br>适配器中置换适配者类的某些方法比较麻烦<br><strong>适应场景</strong><br>1.系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码<br>2.想创建一个可以重复使用的类，用来与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式(Facade)，为一组具有类型功能的类群，比如类库，子系统等等，提供一个一致的简单的界面</p>
<ul>
<li>外观角色：为调用方，定义简单的调用接口</li>
<li>子系统角色：功能提供方，指提供功能的类群</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">type SubSystemA struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemB struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemC struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemD struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sa *SubSystemA) MethodA() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SubSystemB) MethodB() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method b&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sc *SubSystemC) MethodC() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method c&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sd *SubSystemD) MethodD() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method d&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类</span><br><span class="line">type Facade struct &#123;</span><br><span class="line">	a *SubSystemA</span><br><span class="line">	b *SubSystemB</span><br><span class="line">	c *SubSystemC</span><br><span class="line">	d *SubSystemD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodOne() &#123;</span><br><span class="line">	f.a.MethodA()</span><br><span class="line">	f.b.MethodB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodTwo() &#123;</span><br><span class="line">	f.c.MethodC()</span><br><span class="line">	f.d.MethodD()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f := Facade&#123;&#125;</span><br><span class="line">	f.MethodOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。<br>2.它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可<br>3.一个子系统的修改对其他子系统没有任何影响<br>缺点;<br>1.不能很好的限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性<br>2.如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则<br><strong>适用场景</strong></p>
<ol>
<li>复杂系统需要简单入口使用</li>
<li>客户端程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系</li>
</ol>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>抽象类：在抽象类中定义了一系列基本操作，可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或者实现这些步骤</li>
<li>具体子类：是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类 做饮料</span><br><span class="line"></span><br><span class="line">type Beverage interface &#123;</span><br><span class="line">	BoilWater()</span><br><span class="line">	Brew()</span><br><span class="line">	PourInCup()</span><br><span class="line">	AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装一套流程模板</span><br><span class="line">type template struct &#123;</span><br><span class="line">	b Beverage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *template) MakeBeverage() &#123;</span><br><span class="line">	if t == nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	t.b.BoilWater()</span><br><span class="line">	t.b.Brew()</span><br><span class="line">	t.b.PourInCup()</span><br><span class="line">	t.b.AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MakeCoffee struct &#123;</span><br><span class="line">	template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) BoilWater() &#123;</span><br><span class="line">	fmt.Println(&quot;boil the water&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) Brew() &#123;</span><br><span class="line">	fmt.Println(&quot;use boiled water to brew&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) PourInCup() &#123;</span><br><span class="line">	fmt.Println(&quot;pour the coffee to the cup&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) AddThings() &#123;</span><br><span class="line">	fmt.Println(&quot;add sugar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMakeCoffee() *MakeCoffee &#123;</span><br><span class="line">	m := new(MakeCoffee)</span><br><span class="line">	m.b = m</span><br><span class="line">	return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	makeCoffee := NewMakeCoffee()</span><br><span class="line">	makeCoffee.MakeBeverage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时不会改变算法中步骤的执行顺序<br>2.模板方法是一种代码复用技术，他提取了类库中的公共行为，将公共行为放在父类中<br>3.可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行<br>4.不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则<br>缺点：<br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。<br><strong>适用场景</strong><br>1.具有同一的操作步骤或操作过程<br>2.具有不同的操作细节<br>3.存在多个具有同样操作步骤的应用场景，但某些具体的操作系统却各不相同<br>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个子类和操作步骤解耦合</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>讲一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式。命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不比知道如何完成请求。</p>
<ul>
<li>抽象命令类：一个抽象类或者接口，通过这些方法可以调用请求接收者的相关操作</li>
<li>具体命令类：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中</li>
<li>调用者：请求发送者，通过命令对象来执行请求</li>
<li>接收者：接收者执行与请求相关的操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">type Doctor struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatEye() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat eye&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatMouth() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat mouth&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Command interface &#123;</span><br><span class="line">	Treat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatEye struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatEye) Treat() &#123;</span><br><span class="line">	cmd.d.treatEye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatMouth struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatMouth) Treat() &#123;</span><br><span class="line">	cmd.d.treatMouth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Nurse struct &#123;</span><br><span class="line">	CmdList []Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Nurse) Notify() &#123;</span><br><span class="line">	if len(n.CmdList) == 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	for _, cmd := range n.CmdList &#123;</span><br><span class="line">		cmd.Treat()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	doctor := new(Doctor)</span><br><span class="line">	cmdEye := CommandTreatEye&#123;doctor&#125;</span><br><span class="line">	cmdMouth := CommandTreatMouth&#123;doctor&#125;</span><br><span class="line">	nurse := new(Nurse)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdEye)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdMouth)</span><br><span class="line">	nurse.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.降低系统的耦合度<br>2.新的命令很容易添加到系统中，满足开闭原则<br>3.可以比较容易地设计一个命令队列或者宏命令<br>缺点：<br>使用命令模式可能会导致某些系统有过多的具体命令类，因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用<br><strong>适用场景</strong><br>1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无需知道接收者的存在，也许无知道接收者是谁<br>2.系统需要在不同的时间指定请求、将请求排队和执行请求<br>3.系统需要将一组操作组合在一起形成宏命令</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>环境类：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略，在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类：它为所支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或者具体类，也可以是接口</li>
<li>具体策略类：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类，使用一种具体的算法实现某个业务处理</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/14.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type WeaponStrategy interface &#123;</span><br><span class="line">	UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AK47 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ak *AK47) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用AK47战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Knife struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (k *Knife) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用匕首战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Hero struct &#123;</span><br><span class="line">	strategy WeaponStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) SetWeaponStrategy(s WeaponStrategy) &#123;</span><br><span class="line">	h.strategy = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) Fight() &#123;</span><br><span class="line">	h.strategy.UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	hero := Hero&#123;&#125;</span><br><span class="line">	hero.SetWeaponStrategy(new(AK47))</span><br><span class="line">	hero.Fight()</span><br><span class="line">	hero.SetWeaponStrategy(new(Knife))</span><br><span class="line">	hero.Fight()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为<br>2.使用策略模式可以避免多重条件选择语句<br>3.策略模式提供了一种算法的复用机制<br>缺点：<br>1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类<br>2.策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类<br><strong>适用场景</strong><br>准备一组算法，并将每一个算法封装起来，使得它们可以互换</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出翻译。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<ul>
<li>抽象主题：被观察的对象</li>
<li>具体主题：被观察者的具体实现</li>
<li>观察者：接口或者抽象类</li>
<li>具体观察者：观察者的具体实现</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/15.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">type Listener interface &#123;</span><br><span class="line">	OnTeacherComing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Notifier interface &#123;</span><br><span class="line">	AddListener(l Listener)</span><br><span class="line">	RemoveListener(l Listener)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhang3 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhang3) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhao4 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhao4) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhao4 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuWang5 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuWang5) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;wang5 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClassMonitor struct &#123;</span><br><span class="line">	listenerList []Listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) AddListener(l Listener) &#123;</span><br><span class="line">	m.listenerList = append(m.listenerList, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) RemoveListener(l Listener) &#123;</span><br><span class="line">	for index, li := range m.listenerList &#123;</span><br><span class="line">		if li == l &#123;</span><br><span class="line">			m.listenerList = append(m.listenerList[:index], m.listenerList[index+1:]...)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) Notify() &#123;</span><br><span class="line">	for _, listener := range m.listenerList &#123;</span><br><span class="line">		listener.OnTeacherComing()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := &amp;StuZhang3&#123;</span><br><span class="line">		Badthing: &quot;抄作业&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := &amp;StuZhao4&#123;</span><br><span class="line">		Badthing: &quot;玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s3 := &amp;StuWang5&#123;</span><br><span class="line">		Badthing: &quot;看别人玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	classMonitor := new(ClassMonitor)</span><br><span class="line">	classMonitor.AddListener(s1)</span><br><span class="line">	classMonitor.AddListener(s2)</span><br><span class="line">	classMonitor.AddListener(s3)</span><br><span class="line">	classMonitor.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>观察者模式可以实现表现层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>观察者模式在观察目标和观察者之间建立了一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，不需要了解其具体的观察者</li>
<li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li>观察者模式满足开闭原则</li>
</ol>
<p>缺点</p>
<ol>
<li>如果一个观察者对象有很多直接和间接的观察者，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间存在循环依赖，系统可能会发生崩溃</li>
<li>观察者模式没有响应的机制让观察者知道所观察到的对象是怎样发生变化的</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这两个方面封装在独立的对象中使得它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致一个或者多个其他对象也发生改变</li>
<li>需要在系统中创建一个触发链路，A对象的行为影响B，B对象的行为影响C</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"># 计算机基础</a>
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
              <a href="/tags/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/" rel="tag"># 后端学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/15/toms%E5%88%9D%E8%AF%86/" rel="prev" title="toms初识">
      <i class="fa fa-chevron-left"></i> toms初识
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/" rel="next" title="实习求职总结">
      实习求职总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjgwMy8zMzI2Nw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5"><span class="nav-number">1.0.1.</span> <span class="nav-text">设计模式从何而来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.2.</span> <span class="nav-text">软件设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="nav-number">2.0.1.</span> <span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="nav-number">2.0.2.</span> <span class="nav-text">开闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="nav-number">2.0.3.</span> <span class="nav-text">依赖倒转原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">2.0.4.</span> <span class="nav-text">合成复用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="nav-number">2.0.5.</span> <span class="nav-text">迪米特法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">2.0.6.</span> <span class="nav-text">接口的意义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.4.</span> <span class="nav-text">三种工厂的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.5.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">装饰模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E4%B8%8E%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.3.</span> <span class="nav-text">装饰与代理的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.4.</span> <span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.5.</span> <span class="nav-text">外观模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">模板方法模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.4.</span> <span class="nav-text">观察者模式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
