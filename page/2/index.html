<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/git%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/git%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">git学习与进阶命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 21:30:04" itemprop="dateCreated datePublished" datetime="2023-04-08T21:30:04+08:00">2023-04-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Gin复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-03 23:16:20" itemprop="dateCreated datePublished" datetime="2023-04-03T23:16:20+08:00">2023-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-10 22:58:14" itemprop="dateModified" datetime="2023-05-10T22:58:14+08:00">2023-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>周末想仔细了解一下http传参，包括GET方法的传参、POST方法的传参，索性把GIN也捡起来了一点</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>1.Gin.Use和Gin.Default的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Default加了两个中间件</span><br><span class="line">Gin.Use(Logger(),Recovery())</span><br></pre></td></tr></table></figure>

<p>有打印日志和从Panic中恢复的能力<br>Logger中间件会将日志写入gin.DefaultWriter，即使配置了GIN_MODE&#x3D;release<br>Recovery中间件会recover任何panic，如果有panic的话，会写入500响应码<br>    <strong>2.Gin怎么分组</strong><br>gin.Group对路由进行分组</p>
<h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><p>Gin怎么拿到URL中的参数<br>        用ID举例子<br><strong>Param</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C.Param(&quot;id&quot;)</span><br><span class="line"></span><br><span class="line">// 这个时候路由要这么写 id就成为了不定参数</span><br><span class="line">GET（&quot;/:id&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这时候url中的请求格式就应该如下</span><br><span class="line">http://localhost:8080/id=xx</span><br><span class="line">//如果有多的参数则应该是</span><br><span class="line">http://localhost:8080/id=xx&amp;name=xx</span><br><span class="line">GET(&quot;/:id/:name&quot;)</span><br><span class="line"></span><br><span class="line">//当我们想处理URL中所有的参数的时候</span><br><span class="line">//比如说有name id type等等</span><br><span class="line">//这个时候路由就该这么写</span><br><span class="line"></span><br><span class="line">c.Param(&quot;all&quot;)</span><br><span class="line">GET(&quot;/*all&quot;）</span><br></pre></td></tr></table></figure>

<p><strong>在URL中传参时必须传某个param该怎么做？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Produdct struct &#123;</span><br><span class="line">  	ID int `uri:&quot;id&quot; binding:&quot;required&quot; </span><br><span class="line">  	Name string `uri:&quot;name&quot; binding:&quot;required&quot;</span><br><span class="line">&#125;</span><br><span class="line">// uri也是tag支持的一个键值对之一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var p Product </span><br><span class="line">err := c.ShouldBindUri(&amp;p)</span><br><span class="line">// 如果这里err有问题了，那么很显然就是某个param没有传</span><br></pre></td></tr></table></figure>

<h2 id="struct-tag"><a href="#struct-tag" class="headerlink" title="struct tag"></a>struct tag</h2><p>在很多项目代码里面，很容易看到有一些结构体的定义是类似下面这个结构体的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Location struct &#123;</span><br><span class="line">    Longitude float32 `json:&quot;lon,omitempty&quot;`</span><br><span class="line">    Latitude  float32 `json:&quot;lat,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段后面会有一个标签，这个标签通常是由反引号给括起来的<br>Go提供了可通过发射发现的结构体标签，这些在标签库json&#x2F;xml中得到了广泛的使用，orm框架也支持了结构体标签，上面的这个例子就是因为encoding&#x2F;json支持json结构体标签，每种标签都有自己的特殊规则<br>不过所有标签都遵循一个总体规则，这个规则是不能更改的，具体格式如下<br><code>key1:&quot;value1&quot; key2:&quot;value2&quot; key3:&quot;value3&quot;...</code><br>结构体标签可以有多个键值对，键与值要用冒号分割，值要使用双引号括起来，多个键值对之间使用一个<strong>空格</strong>进行分割<br>而一个值中要传递多个信息，不同库的实现是不一样的，在encoding&#x2F;json中，多值使用逗号进行分割<br>例如下面的例子<br><code>json:&quot;lon,omitempty&quot;</code><br>在gorm中，多值使用分号进行分隔<br>&#96;&#96;gorm:”column:id;primaryKey”<code> 结构体标签的具体作用时机如下 **在编译阶段和成员进行关联，以字符串的形式进行关联，在运行阶段可以通过反射读取出来** 在Go项目的编译阶段是不会对struct tag做合法键值对的检查的，如果我们不小心写错了，就会很难被发现，这个时候我们就可以使用</code>go vet&#96;工具，帮助我们做CI检查<br>下面是Go支持的struct tag类型<br><img src="/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/1.png" alt="image.png"><br><img src="/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/2.png" alt="image.png"><img src="/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/3.png" alt="image.png"></p>
<h2 id="自定义结构体标签"><a href="#自定义结构体标签" class="headerlink" title="自定义结构体标签"></a>自定义结构体标签</h2><p>结构体标签是可以随意写的，只要符合语法规则。但是一些库没有支持该标签的情况下，随意写的标签是没有任何意义的，如果想要我们的标签变得有意义，就需要我们提供解析方法。可以通过反射的方法获取标签，下面是一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">	Name string `cheng:&quot;name&quot;`</span><br><span class="line">	ID   int    `cheng:&quot;id&quot;`</span><br><span class="line">	Type int    `cheng:&quot;type&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getStructTag(obj interface&#123;&#125;) &#123;</span><br><span class="line">	t := reflect.TypeOf(obj)</span><br><span class="line">	for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		value := t.Field(i)</span><br><span class="line">		tag := value.Tag.Get(&quot;cheng&quot;)</span><br><span class="line">		fmt.Println(&quot;get tag is&quot;, tag)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	t := test&#123;</span><br><span class="line">		Name: &quot;yuyating&quot;,</span><br><span class="line">		ID:   2021212345,</span><br><span class="line">		Type: 1,</span><br><span class="line">	&#125;</span><br><span class="line">	getStructTag(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">get tag is name</span><br><span class="line">get tag is id</span><br><span class="line">get tag is type</span><br></pre></td></tr></table></figure>

<h2 id="Post-body参数的类型"><a href="#Post-body参数的类型" class="headerlink" title="Post-body参数的类型"></a>Post-body参数的类型</h2><p>在POST请求中，常见的body数据类型包括</p>
<ol>
<li>application&#x2F;x-www-form-urlencoded: 这是最常见的POST请求数据格式，适用于简单的表单数据。在这种格式下，数据以键值对的形式出现，每个键值对之间使用&amp;符号分割，例如:key1&#x3D;value1&amp;key2&#x3D;value2</li>
<li>multipart&#x2F;form-data：适用于上传文件或者二进制数据，通常用于文件上传功能。在这种格式下，数据被分割成多个部分，每个部分有自己的Content-Type，例如Content-Type:image&#x2F;jpeg。这种格式下，数据以一定的边界符分割，每个部分之间以该边界符分割</li>
<li>application&#x2F;json：适用于发送JSON格式的数据，在这种格式下，数据以JSON格式组织，例如{“key1”:”value1”,”key2”:”value2”}</li>
<li>text&#x2F;xml: 适用于发送XML格式的数据，在这种格式下，数据以XML格式组织，例如<?xml version ="1.0" encoding="UTF-8"?><root><key1>value1</key1><key2></key2></root></li>
</ol>
<p>一般情况下，POST请求的body数据类型是需要根据API设计要求而选择的。如果混用不同类型的数据格式，服务器端可能无法正确解析请求的数据，导致请求失败。</p>
<h2 id="ShouldBind方法"><a href="#ShouldBind方法" class="headerlink" title="ShouldBind方法"></a>ShouldBind方法</h2><p>ShouldBind用于绑定请求中的参数，将其转换成Go结构体或者map类型，该方法的参数类型绑定顺序为</p>
<ol>
<li>如果是query string，则按照form表单的格式进行解析</li>
<li>如果是post表单数据，则按照form表单的进行解析</li>
<li>如果是json格式，按照json格式解析</li>
<li>如果是xml格式，按照XML格式解析</li>
<li>如果是protobuf格式，按照protobuf格式解析</li>
</ol>
<p>在绑定参数的时候，Gin会根据请求的Content-Type自动选择核实的参数绑定方式，可以通过ShouldBind方法来完成自动绑定。例如，如果请求的Content-Type为application&#x2F;json，则Gin会自动将请求体中的JSON数据解析为Go结构体</p>
<p><strong>为什么query string会按照form表单进行解析呢？form表单不是放在body里的吗？</strong><br>虽然form表单数据通常被放在POST请求中的body里面，但是在HTTP请求中，form表单数据也可以以query string的形式出现在url中。在这种情况下，query string中的键值对与form表单中的键值对是相同的，都是由键和值组成的键值对，通过&amp;符号进行分割<br>因此，Gin在解析query string时会按照form表单的格式进行解析，即将query string中的键值对解析为Go结构体或者Map类型。这样就能够通过Gin的ShouldBind方法统一处理query string和form表单数据，提高了代码复用性和可读性<br>需要注意的是，在将query string解析为Go结构体或者map类型的时候，需要将URL编码转义的字符进行解码。例如将%20转换为空格。Gin会自动进行这一步操作，不需要手动进行解码。</p>
<h2 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h2><p>Gin允许开发者在处理请求的过程中加上自己的钩子函数，这个钩子函数就被称为中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等等。<br>在JAVA等面向对象编程语言中，面向切面编程（AOP）的思想和中间件是类似的<br>而拦截器（interceptor）的思想和中间件也是类似的<br>AOP和MiddleWare、Interceptor都是用于改善软件系统架构的技术，但它们的实现和目标有所不同<br>相同点</p>
<ul>
<li>都是通过将特定功能从主要业务逻辑中分离出来，以改善系统的可维护性和可扩展性</li>
<li>都是在系统中插入特定代码来实现所需功能的（hook）</li>
<li>都可以提高代码的复用性，减少重复代码的编写</li>
</ul>
<p>不同点</p>
<ul>
<li>AOP关注的是切面，即与业务逻辑无关的横切关注点，如安全性、日志记录、性能检测等等，它们被成为切面，AOP使用依赖注入和动态代理等特定的技术，实现这些切面</li>
<li>中间件关注的是不同系统组件之间的通信和交互，是一种软件层，为应用程序提供基础服务，如消息传递、数据传输和远程调用等等</li>
</ul>
<p>AOP更关注于解决代码层面的问题，中间件则更关注于解决系统层面的问题</p>
<p>拦截器通常只在特定的代码路径或者逻辑流中执行，例如在特定的web请求或者调用特定的方法的时候，通常由程序本身实现，通过代码中的特定注解或配置来声明和使用，旨在通过拦截请求和响应来处理和修改它们，以实现特定的功能，如安全性、性能检测和日志记录等等<br>使用中间件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册全局中间件  </span><br><span class="line">c.Use(middleware())</span><br><span class="line">//注册某一条路由的中间件 </span><br><span class="line">r.GET(&quot;/xxx&quot;,MiddleWare(),handler)</span><br></pre></td></tr></table></figure>

<p>*<em>注意：在中间件或者handler中启用新的goroutine的时候，不能使用原始的上下文c <em>gin.Context，必须使用其只读副本c.Copy()</em></em><br>c.Next和c.Abort</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain &#123;</span><br><span class="line">	finalSize := len(group.Handlers) + len(handlers)</span><br><span class="line">	if finalSize &gt;= int(abortIndex) &#123;  // 这里有一个最大限制</span><br><span class="line">		panic(&quot;too many handlers&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	mergedHandlers := make(HandlersChain, finalSize)</span><br><span class="line">	copy(mergedHandlers, group.Handlers)</span><br><span class="line">	copy(mergedHandlers[len(group.Handlers):], handlers)</span><br><span class="line">	return mergedHandlers</span><br><span class="line">&#125;</span><br><span class="line">一个路由的中间件函数和处理函数结合到一起成为一条处理链条</span><br><span class="line">本质上就是一个由HandlerFunc组成的切片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Next:</span><br><span class="line">func (c *Context) Next() &#123;</span><br><span class="line">	c.index++</span><br><span class="line">	for c.index &lt; int8(len(c.handlers)) &#123;</span><br><span class="line">		c.handlers[c.index](c)</span><br><span class="line">		c.index++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">通过索引遍历HandlersChain链条，从而实现依次调用该路由的每一个函数</span><br><span class="line"></span><br><span class="line">Abort:</span><br><span class="line">func (c *Context) Abort() &#123;</span><br><span class="line">	c.index = abortIndex  // 直接将索引置为最大限制值，从而退出循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next:<br><img src="/2023/04/03/Gin%E5%A4%8D%E4%B9%A0/4.png" alt="image.png"><br>Abort:<br>中断整个调用链条，从当前函数返回<br>我们的handlers也是HandleFunc类型，所以如果一条路由的专用middleware，调用了c.Next，其实就是直接跳到了handlers中去执行</p>
<h2 id="优雅关机"><a href="#优雅关机" class="headerlink" title="优雅关机"></a>优雅关机</h2><p>优雅关机的使用场景，我们不能让一个项目随意的退出，因为这个时候可能还有请求没有处理完，如果你一个信号、或者一个stop按键能够直接让程序停止，那么显然这个项目是不合格的。正确做法是应该处理完所有请求、释放对应资源之后，再停止程序<br>下面是一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 把 run 放在子协程中执行</span><br><span class="line">go func() &#123;</span><br><span class="line"> r.Run()</span><br><span class="line">&#125;()</span><br><span class="line">// 一个信号通道</span><br><span class="line">exit:=make(chan os.Signal)</span><br><span class="line">// 监听通道中有没有这两种信号</span><br><span class="line">signal.Notify(exit,syscall.SIGINT,syscall.SIGTERM)</span><br><span class="line">&lt;-exit</span><br><span class="line">log.Println(&quot;process exit&quot;)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BC%9A%E6%8C%81%E7%BB%AD%E5%86%99%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BC%9A%E6%8C%81%E7%BB%AD%E5%86%99%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">为什么我会持续写面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:19:07 / 修改时间：22:23:43" itemprop="dateCreated datePublished" datetime="2023-03-27T22:19:07+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么我会持续写面经？"><a href="#为什么我会持续写面经？" class="headerlink" title="为什么我会持续写面经？"></a>为什么我会持续写面经？</h1><p>从我去年投出第一份简历，经历第一场面试，到现在应该已经陆陆续续面了好几十场了，小厂、中厂、大厂都有，基本上每一场面试我都有做记录并且review，我觉得这是一件很有意义并且回报很高的事情</p>
<h2 id="提升专业技能"><a href="#提升专业技能" class="headerlink" title="提升专业技能"></a>提升专业技能</h2><p>我认为在技术岗方面，对于在校生来说，不论是实习还是秋招、春招，对于你的专业技能硬性要求大概只有这些</p>
<ul>
<li>工程方面的能力：你写了什么项目，你对自己的项目理解的程度深不深，常用的技术栈你学的怎么样，你的debug能力，把你招进来是不是真的能有产出，一些常用的框架、命令、工具你会不会用，会不会协同合作等等</li>
<li>基础方面的能力：比如MySQL、Redis、MQ、Linux命令的使用，设计模式的理解，再到八股文（操作系统、计网、数据结构、计算机组成、编译原理、MySQL底层、Redis底层、MQ底层、一些工具的底层比如Docker等等）</li>
<li>做题的能力：目前来看算法题能不能写出来越来越重要了，写不出题面试过的概率微乎其微</li>
<li>知识的深度和广度：这些就属于随缘考察了，面试官问什么都可能，可能是智力题、逻辑题，也有可能是云原生、分布式、微服务这种比较新的东西</li>
</ul>
<p>而做好面试记录，编写面经的过程中你就能很清楚的知道，在面试过程中你哪些点答的好，哪些点答的不好，你可以听面试官的语气来察觉出你给出的答案是不是他想听到的，然后对自己的整个知识框架进行查漏补缺</p>
<p>注意：<strong>这里的查漏补缺不是一有答不上来的问题就去学</strong>，这样成本太大了，挑你觉得你需要会的东西去学。</p>
<p>比如你从来没用过某个技术栈，所以答不上来某个问题，这个技术栈你目前用不到，也不是必会的技能，那就完全没必要去学。</p>
<p>但是如果你是某个很重要的点，比如设计模式不会，那我强烈建议你去好好学一学。</p>
<h2 id="提升软素质"><a href="#提升软素质" class="headerlink" title="提升软素质"></a>提升软素质</h2><p>除了专业技能之外，面试也会考察候选人的软素质，比如语言表达能力、抗压能力等等。我觉得逻辑清晰，语句通顺，面试官能听懂你说的东西，并且觉得你说的有道理，这是很重要的一个能力。</p>
<p>比如说某个八股文的点，你和面试官的理解可能不一样，但是你能把自己的逻辑讲清楚，为什么会是这样，能够自圆其说，说出来的逻辑能够闭环，哪怕你说的东西是错的，都会比卡在那里好很多。</p>
<p>及时做面经能够很明显的感觉出来自己刚刚哪里表述有问题，哪里逻辑不清晰，哪里口误，哪里明明心里是会的，但是说出来很混乱，这样就能尽量避免下次再犯类似的错误。</p>
<h2 id="正向反馈"><a href="#正向反馈" class="headerlink" title="正向反馈"></a>正向反馈</h2><p>不得不承认，真正热爱技术的人绝对是少之又少，大部分人投身技术领域主要还是为了一口饭吃。讨厌技术和热爱技术在学习和工作中绝对是两种不同的心态，并且成长速度也是绝对不一样的。</p>
<p>那么该怎么让自己不讨厌技术，甚至爱上技术呢？</p>
<p>引入开源思想，写面经、写博客，绝对是一个很好的方法。当我写出来的东西能帮他人解决问题，能够获得别人的赞同，能起到哪怕一点点微小的帮助，对我来说也是一种认同+满足，不断的重复这个过程，慢慢的去影响越来越多的人，帮助到越来越多的人，是一件很快乐的事情，至少对于我来说是这样。</p>
<h2 id="养成review的习惯"><a href="#养成review的习惯" class="headerlink" title="养成review的习惯"></a>养成review的习惯</h2><p>及时复习，及时review绝对是帮助你提升效率的一大杀器，但是很遗憾的是大部分人都没有这个能力。从小我们接受的学习模式应该是：预习-正式学习-复习这么一个过程，上了大学之后基本没有预习这一说了，学习模式变成了：学习-复习这个过程。</p>
<p>不讨论这个模式是否正确，但是从记忆曲线来说，复习、及时复习、多次复习，这个过程的回报率是比只学习、不复习的模式强很多很多的，review一次的时间一般不会超过正式学习的20%，而效果会比只学习一次强很多很多。</p>
<p>所以不管是刷题、学技术、还是学知识，我都建议大家可以试着去review，如果不知道该如何踏出第一步，也许你可以试试从写一份面经开始。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/limit%E4%B8%8E%E5%88%86%E9%A1%B5%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/limit%E4%B8%8E%E5%88%86%E9%A1%B5%E9%94%AE/" class="post-title-link" itemprop="url">limit与分页键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:18:40 / 修改时间：22:24:19" itemprop="dateCreated datePublished" datetime="2023-03-27T22:18:40+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="limit与分页"><a href="#limit与分页" class="headerlink" title="limit与分页"></a>limit与分页</h2><p>在SQL中，limit用于限制返回的结果行数。LIMIT语句可以用于SELECT查询，用于<strong>限制查询结果集的行数</strong>，从而在处理大型数据集时，减少数据库的负载，提高查询的性能</p>
<p>基本语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name LIMIT [offset],row_count;</span><br><span class="line">//table_name是表名</span><br><span class="line">//offset是可选的偏移量，用于指定要从结构集的哪个位置开始返回行</span><br><span class="line">如果省略该参数，默认从第一行开始返回</span><br><span class="line">//row_count一共返回的行数，也就是查询得到的数量</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">select * from students limit 5,10;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">select * from students limit 10 offset 5;</span><br></pre></td></tr></table></figure>

<p>limit在实际应用中常用于分页查询</p>
<p>举个例子</p>
<p>现在我有一个article表，想要做到文章分页展示的功能，每一页展示10篇文章</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//表结构如下</span><br><span class="line"></span><br><span class="line">CREATE TABLE article (</span><br><span class="line">id int(11) not null auto_increment,</span><br><span class="line">title varchar(255) not null,</span><br><span class="line">content text,</span><br><span class="line">publish_time datetime not null,</span><br><span class="line">primary key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/这个时候调用方传来一个n，通常是Logic层往dao层传 伪代码如下</span><br><span class="line">select * from article order by</span><br><span class="line">publish_time desc limit ?,10 values (n*10);</span><br><span class="line"></span><br><span class="line">//这条SQL就能做到文章分页的功能，按照时间来分页</span><br><span class="line">//具体实践中可能没有这么简单，通常是热度、时间等等</span><br></pre></td></tr></table></figure>

<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>查询结果集中的某个位置之后的记录，即查询结果集的偏移量很大的情况。这样需要扫描的数据量就很大，可能导致查询的性能变得很低下</p>
<p>如何避免深分页的问题</p>
<ul>
<li>使用更小的偏移量：比如将偏移量从10000降低到100</li>
<li>使用分页键</li>
<li>缓存结果集，在内存层面进行返回</li>
<li>分库分表，减少每个表的数据量大小</li>
</ul>
<h2 id="分页键"><a href="#分页键" class="headerlink" title="分页键"></a>分页键</h2><p>分页键(pagination key)是一种用于分页查询的技术，它可以帮助我们在大数据集合中快速定位到需要查询的数据段。分页键通常是一个<strong>唯一的标识符</strong>，可以表示查询结果集中的某一行。在使用分页键的时候，通过查询分页键来定位结果集的起始位置，从而避免了偏移量很大的情况，也就是避免了SQL深分页的情况。</p>
<p>举个例子，假设我们需要查询一个包含一百万行数据的用户表，并且我们需要查询第500001到第500100行的数据。如果用偏移量的方式进行查询，需要查询前5000000行数据才能获得我们需要的结果，这将导致查询性能非常低下。而使用分页键的方式，可以在查询时直接指定分页键的值，从而定位到结果集的起始位置，避免了大量的数据扫描。</p>
<p>使用分页键的时候，我们需要选择一个合适的字段作为分页键，并确保该字段具有唯一性。通常情况下，自增长主键或者时间戳字段都是比较好的选择，分页键适用于有序数据集的分页查询</p>
<p>下面有一个具体的栗子</p>
<p>假设我们有一个包含大量文章的表，每篇文章都有一个唯一编号id和发布时间publish_time两个字段。我们需要查询发布时间在2022年1月1日到2022年3月31日之间的文章，并按照发布时间进行排序，每页显示十篇文章，显示第六页的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.选择分页键：根据查询条件，我们选择publish_time作为分页键</span><br><span class="line"></span><br><span class="line">2.查询第五页的最后一篇文章的发布时间</span><br><span class="line">我们得确定第五页最后一篇文章的发布时间</span><br><span class="line">select publish from articles </span><br><span class="line">where publish_time&gt;=&#x27;2022-01-01 00:00:00&#x27;</span><br><span class="line">and publish_time&lt;=&#x27;2022-03-31 23:59:59&#x27;</span><br><span class="line">order by pulish_time asc </span><br><span class="line">limit 1 offset 50;</span><br><span class="line"></span><br><span class="line">3.使用分页键查询数据</span><br><span class="line">select * FROM articels </span><br><span class="line">where publish_time&gt;=&#x27;分页键的值&#x27;</span><br><span class="line">and publish_time&lt;=&#x27;2022-03-31 23:59:59&#x27;</span><br><span class="line">order by publish_time asc </span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/" class="post-title-link" itemprop="url">深入理解异地多活</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:18:25 / 修改时间：22:22:51" itemprop="dateCreated datePublished" datetime="2023-03-27T22:18:25+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统性能三指标"><a href="#系统性能三指标" class="headerlink" title="系统性能三指标"></a>系统性能三指标</h1><p>要想理解异地多活，我们需要从架构设计的原则说起</p>
<p>现如今，我们开发一个软件系统，对其要求越来越高，一个好的软件架构应该遵循以下3个原则：</p>
<ol>
<li>高性能</li>
<li>高可用</li>
<li>易扩展</li>
</ol>
<ul>
<li>高性能：系统拥有更大流量的处理能力，同时接口返回的速度应该尽可能的快。</li>
<li>易扩展：系统在迭代新功能的时候，能够以最小的代价去扩展，系统遇到流量压力的时候，可以在不改动代码的前提下去扩容系统。</li>
<li>高可用：通常由两个指标来衡量，分别是平均故障时间和故障恢复时间</li>
</ul>
<p>不同的软件，不同阶段的公司，产品开发的不同阶段，对这些指标的要求是不一样的：比如一个初创公司，这个时候用户、流量最重要，开发功能，让页面尽可能美观，做产品比其他指标更重要；当流量上来了之后，怎么尽可能缩短响应时间，让系统能处理的QPS更大，就成了至关重要的问题；当产品使用的人数足够多，影响力足够大，可用性的重要就凸现出来了，怎么保证系统尽可能稳定，不出问题，对于公司来说才是最重要的。</p>
<p>系统发生故障是不可避免的，尤其是规模越大的系统，互相之间的调用也更加复杂，对于硬件的要求也越高，从理论上来说发生问题的概率也越大。这些故障一般提现在3个方面：</p>
<ol>
<li>硬件故障：CPU 内存 磁盘 网卡 交换机 路由器</li>
<li>软件问题：代码BUG 版本迭代 线上故障等等</li>
<li>不可抗力：地震 水灾 火灾  战争</li>
</ol>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/1.png" alt="img"></p>
<p>我们通常用N个9来表示系统的可用性高不高，从数据上能看出来，越到后面系统可用性带来的平均受益是越小的，但是难度是指数级别上升的。我们平常写的小玩具和企业级的应用差别也无非是这几个方面：高并发、高性能、高可用。</p>
<p>这些风险随时都有可能发生，所以在面对故障的时候，系统能否以【最快】的速度恢复，就成了可用性的关键。</p>
<p>如何做到快速恢复呢？</p>
<p><strong>异地多活</strong>就是为了解决这个问题，而提出的高效解决方案</p>
<h1 id="单机房"><a href="#单机房" class="headerlink" title="单机房"></a>单机房</h1><h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/2.png" alt="img"></p>
<p>客户端请求先进来，业务应用读写数据库，返回结果</p>
<p>这里的数据库是单机部署的，所以有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，这意味着所有数据就全部【丢失】了，这个损失是巨大的</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>我们可以对数据做备份，将数据库文件【定期】copy到另一台机器上，这样即使原机器丢失数据，依旧可以通过备份把数据【恢复】回来，以此保证数据安全</p>
<p>这个方案实施起来虽然比较简单，但存在两个问题</p>
<ol>
<li>恢复需要时间：业务需要先停机，在恢复数据，这段时间服务是不可用的，对于一个系统来说这显然不能忍受</li>
<li>数据不完整：因为是定期备份，数据肯定不是最新的，会有丢数据的风险。这里补充一句，其实现代系统想要做到数据实时强一致性，几乎是不可能的</li>
</ol>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/3.png" alt="img"></p>
<p>可以在另一台机器上，再部署一个数据库实例，成为这个原实例的副本，让两者保持【实时同步】，这里的实时同步要打上引号，因为两台机器有网络隔离，永远不可能真正的实时同步，比如当主库写一条数据，还没同步的时候就宕机了，这个时候从库就会有丢数据的可能。</p>
<p>我们一般把原实例称为主库（master），新实例称作从库（slave），这个方案的优点在于</p>
<ul>
<li>数据完整性高：主从副本实时同步，数据差异很小</li>
<li>抗故障能力提升：主库有任何异常，从库可以随时切换为主库，继续提供服务</li>
<li>读性能提示：从库可以直接用来读</li>
</ul>
<h2 id="主从-多机器"><a href="#主从-多机器" class="headerlink" title="主从+多机器"></a>主从+多机器</h2><p>同样的，业务应用也也可以在其他机器部署一份，避免单点。因为业务应用通常是【无状态】的，这里的无状态很好理解，业务代码的逻辑部分（除去数据库的部分），在什么机器上都能跑，且不会对机器造成持久化的影响，不像数据库一样存储数据，所以直接部署即可，非常简单。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/4.png" alt="img"></p>
<p>因为业务应用部署了多个，所以现在还需要一个接入层，来做请求的负载均衡，一般是用nginx或者是lvs，这样当一台机器宕机之后，另一台机器也可以【接管】所有流量，持续提供服务。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/5.png" alt="img"></p>
<h2 id="提高可用性的核心思想"><a href="#提高可用性的核心思想" class="headerlink" title="提高可用性的核心思想"></a>提高可用性的核心思想</h2><p>从这些方案可以看出，提升可用性的关键思路就是：<strong>冗余</strong></p>
<p>担心一个实例故障，那就部署多个实例；担心一个机器宕机，那就部署多台机器；担心一个数据库可能会崩然后丢数据，那就多整几个数据库；这种冗余的思想放在机房层面，就产生了同城灾备、同城双活等方案；放在城市层面，就产生了两地三中心、异地双活、异地多活等方案</p>
<p>以上说的方案还是有缺点的，因为应用虽然部署了多台机器，但是这些机器的分布情况，我们并没有去深究。</p>
<p>而一个机房有很多服务器，这些服务器通常会分布在一个个【机柜】上，如果使用的机器刚好在一个机柜，还是存在风险。</p>
<p>如果恰好链接这个机柜的交换机&#x2F;路由器发生故障，那么你的应用依旧有【不可用】的风险</p>
<p>哪怕是在不同机柜上，依旧会有风险，因为它们始终还是属于一个机房。</p>
<p>机房的故障率从现实角度来分析其实真的很低，建设一个机房的要求是很高的，地理位置、温湿度控制、备用电源等等。机房厂商会在各方面做好防护，但即使这样，还是有以下事故</p>
<ul>
<li>15年支付宝因为光纤被挖断，5小时无法访问支付宝</li>
<li>21年b站服务器着火，3小时无法访问</li>
<li>21年富途证券服务器断电，2小时无法访问</li>
</ul>
<p>可见，哪怕机房级别的防护已经做的足够好，但只要有概率出现问题，那现实情况就有可能发生。虽然概率很小，但一旦发生，就会造成重大损失。</p>
<p>像前文所说的一样，不同体量的系统，关注的重点是不一样的。小系统关注的重点是用户，这个阶段用户的规模、增长就是一切。在用户体量上来之后，会重点关注性能，优化接口响应时间，接口打开速度等等。这个阶段更多的是关注用户体验，而体量再大下去，可用性就会变得尤为重要。像微信、支付宝这种全民级别的应用，如果机房发生一次故障，那么影响和损失都是巨大的</p>
<p>我们该如何应对机房级别的故障呢？没错，还是冗余</p>
<h1 id="多机房"><a href="#多机房" class="headerlink" title="多机房"></a>多机房</h1><h2 id="同城灾备"><a href="#同城灾备" class="headerlink" title="同城灾备"></a>同城灾备</h2><p>简单起见，可以在同一个城市再搭建一个机房，原机房为A，新机房为B，这两个机房的网络用一条【专线】连通。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/6.png" alt="img"></p>
<p>为了避免A机房故障导致数据丢失，所以我们需要把数据在B机房也做【定时备份】。这种方案，我们成为【冷备】。因为B机房只做备份，不提供服务，只有在A机房故障的时候才会弃用。</p>
<p>或者可以把AB之间的关系换成主从的关系，这样不仅能提高系统吞吐量，也能够更加保证数据的完整性</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/7.png" alt="img"></p>
<p>在这个方案的设想中，如果A机房真挂掉了，要想保证服务不中断，还需要做这些事情</p>
<ol>
<li>B机房所有从库升级成主库</li>
<li>在B机房部署应用，启动服务</li>
<li>部署接入层，配置转发规则</li>
<li>DNS指向B机房接入层，接入流量，业务恢复</li>
</ol>
<p>整个过程的每一步需要人为介入，且需要花费大量时间，回复之前整个服务还是不可用的，如果想要做到故障之后立即【切换】，就需要考虑下面这种架构</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/8.png" alt="img"></p>
<p>这样的话，A机房整个挂掉，我们只需要做两件事</p>
<ol>
<li>B机房所有从库提升为主库</li>
<li>DNS指向B机房接入层，接入流量，业务回复</li>
</ol>
<p>这种方案我们叫【热备】，热备相比于冷备的最大优点是随时可切换，不同点有需要多加一层应用层和接入层，同时数据库层面的定时备份变成了实时备份，这些都是需要额外开销的。我们把这两个方案统称为：同城灾备</p>
<p>同城灾备的最大优势在于，我们不用担心【机房】级别的故障了，一个机房发生风险，我们只需要把流量切换到另一个机房，当然这不一定会没有问题，比如冷备的问题是之前的备用系统没有经过流量的测试，不一定能扛得住；热备也是，瘫了一个主系统，那么备用系统的压力范围，也不一定能抗住。</p>
<h2 id="同城双活"><a href="#同城双活" class="headerlink" title="同城双活"></a>同城双活</h2><p>虽然有了应对机房故障的解决方案，但是有个问题是不能忽略的：A机房挂掉，全部流量切到B机房，B机房是否真的能如我们所愿，正常提供服务？</p>
<p>另外从成本的角度上看，我们新部署一个机房，需要购买很多硬件资源，花费成本也是非常高昂的，如果只是放在那里不去使用，是很浪费资源的一种表现。</p>
<p>因此我们需要让B机房也接入流量，实时提供服务</p>
<p>只需要把B机房的接入层IP地址，加入到dns服务中，这样B机房从上层就可以有流量进来了</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/9.png" alt="img"></p>
<p>这里有一个新问题：B机房的存储都是从库，而从库默认都是不可写的，也就是说B机房是处理不了写请求的。这个问题就应该在业务应用层解决，需要区分读写分离，一般是通过中间件实现，写流量给A机房，读流量可以给两个机房</p>
<p>这种架构有什么问题呢？</p>
<h2 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h2><p>因为把两个机房当成一个整体来规划，如果是一个城市的话，当整个城市发生自然灾害的时候，例如地震、水灾，那么依旧可能有【全局覆没】的风险</p>
<p>这个时候就可以将备份机房放在另一个城市</p>
<p>两地三中心就是指两个城市，三个机房，其中2个机房在同一个城市，并且同时提供服务，第三个机房部署在异地，制作数据灾备。</p>
<p>这种架构方案，通常用在银行、金融、政企相关的项目中，问题还是启用后的服务，不确定能否如期工作。</p>
<p>所以想要真正抵御城市级别的故障，越来越多的互联网公司，开始实施【异地双活】</p>
<h2 id="异地双活"><a href="#异地双活" class="headerlink" title="异地双活"></a>异地双活</h2><p>主要问题是跨机房的延迟调用，当B地的应用去跨区域读写A地的存储，网络延迟就会让整个请求变得非常慢。而要解决这个问题，就必须在存储层做改造了。</p>
<p>B机房的存储不再是从库，而也要变为主库，同时两个机房的数据还要【互相同步】，无论客户端写哪一个机房，都要把数据同步到另一个机房。因为只有两个机房都拥有全量数据，才能支持任意切换机房，持续提供服务。MySQL本身是提供了双主架构的，支持双向数据复制，但平时用的不多。而且Redis、mongoDB等数据库是没有这个功能的，所以必须开发对应的【数据同步中间件】来实现双向同步的功能。</p>
<p>除了数据库这种有状态的软件之外，通常还会用到消息队列，例如rabbitMQ，kafka等，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房</p>
<p>业界开源出了很多数据同步中间件，例如阿里的canal、redisshake、mongoshake，可分别在两个机房同步MySQL、REDIS、MONGODB数据</p>
<p>这样的话有一个新的问题，两个机房都可以写，如果操作的是同一条数据，就很容易发生竞态的问题</p>
<p>分别有两个方案</p>
<ol>
<li>消息同步中间件要有自动解决数据的能力，区分出操作的先后顺序</li>
<li>从源头避免数据冲突的发生</li>
</ol>
<p>一般都是采用第二种方案：在最上层接入流量的时候，就不要让冲突的情况发生。</p>
<p>具体来讲就是将用户区分开，部分用户请求固定达到北京机房，其他用户请求固定打到上海机房。进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免【跨机房】。</p>
<p>这时候需要在接入层之上，再部署一个路由层，自己配置路由规则，把用户分流到不同的机房内。</p>
<p>一般来说有三种方式</p>
<ul>
<li>按业务类型分片，比如某个子域的请求固定全打在某个机房</li>
<li>直接哈希分片，先对请求进行哈希，再对机房的数量进行取模，这样可以保证流量均匀分布到某个机房，但是对于某些请求来说可能速度会慢，比如一个新疆的请求，打到了广州机房，网络延迟就会比打在西安机房大</li>
<li>按地理位置分片，请求只会打在距离自己最近的机房，处理请求的速度快，但是流量不均匀</li>
</ul>
<h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><p>把异地双活的思想推到多个城市，部署多个机房</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/" class="post-title-link" itemprop="url">我的本科前半生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-04 23:33:56 / 修改时间：23:48:31" itemprop="dateCreated datePublished" datetime="2023-03-04T23:33:56+08:00">2023-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一个很喜欢用文字记录生活与想法的人，但是由于文字功底太弱，这些文字大多都躺在我的备忘录和废纸篓里。<br>      昨天看到了一个我很尊敬的学长写的一篇博文，深有所感。于是想写一些东西，记录一下大学这两年的一些经历，感悟和想法。部分内容摘自<a target="_blank" rel="noopener" href="http://www.cbb777.fun/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">实习求职总结</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cbb777.fun/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/">我的本科前半生</a></p>
<h1 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h1><p>20年9月16日，我独自坐上了从景德镇到南昌的动车，在体验过人生的第一次地铁和第一次飞机之后，在晚上十一点抵达了重庆。当时订的酒店在机场附近有一个总店一个分店，很不幸，我订的是总店但是不小心跑到分店去了。当时下着淅淅沥沥的小雨，我背着我的电脑包和双肩包走在凌晨的大街上，忽然觉得有些冷，那晚我把QQ签名改成了“希望生活别把我揍的太惨”。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/1.png" alt="image.png"><br>        进入大学后，我并没有选择松懈。<strong>我觉得人就是这样，越长大要承受的东西只会越来越多，万万没有变轻松的道理，中学比小学难熬，大学比中学难熬，进了社会比在学校难熬。</strong>我选择了在报道的第二天就一头扎进了图书馆，并在一个礼拜内速通了《高等数学上》及《线性代数》的大部分内容。开学之后没多久就放国庆了，但是国庆我也没有闲着，在之后的几个礼拜我又陆陆续续的把《C语言程序设计》学完了，当时真的非常幼稚，一有问题就在群里问，一有看不懂的代码就直接打包让当时的C语言志愿者帮忙看，完全不知道这是一种多么不负责任的行为，现在想想真的是愧怍万分。<br>        当时其实完全没有思考过自己到底想在大学里面干什么事情，在毕业的时候成为什么样的人，只顾着努力学东西。我只是把高中的那一套东西复用在大学里了，打算成为班里面的尖子，然后争取保研，但是我真的需要一个硕士学位吗？<br>        <strong>这何尝不是一种懒惰呢？还没有确定明确的目标就慌不择路的随便选条路出发，现在回头看看只觉这是在用战术上的勤奋来掩盖战略上的懒惰罢了。</strong><br>        大概是十一月初，我大学生活最重要的一个转折点来了。我去参加了当时我们学院的优秀就业生宣讲，第一个宣讲人是胡仓学长，也是一个很厉害很厉害的学长，在听完他的经历之后我花了一下午仔细思考了之后的规划，最终决定不读研了，本科毕业直接就业。这个决定其实并没有得到家人和朋友的支持，但我并没有动摇我的想法，人生总得自己去体验嘛。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/2.png" alt="image.png"><br>        之后我就很少去上课了，因为我觉得那些课程真的很浪费时间，大部分课程都是通识课，对就业可以说是毫无帮助，开设的少部分专业课，老师只是在念年纪比我都大的PPT，一节课一个半小时，我想如果自学的话也许花不了二十分钟就能把一节课的内容给学完。<br>        大一也没有确定好方向，同时也缺乏学习的方法论，基本上ACM、CTF、安全、后端、前端，这些方向我都尝试过，当时很多开发环境我都装不上，经常是一个环境装好几个小时，最后还是不了了之；除此之外刷了一些算法题也并没有体现出来效果。这对一个刚接触技术的小白来说打击太大了。加上当时其实对写代码根本说不上有什么兴趣，我很快就慢慢对写代码这件事情丧失了动力，但我又决定了本科毕业就业，于是乎我开始选择逃避现实了，几乎每天都窝在寝室里，不去上课也不做正事，每天看看小说刷视频打游戏。<strong>一边因为迷茫而焦虑，同时又缺乏自驱力和行动力，无法走出自己的舒适圈，我想这是很多大学生的问题。</strong></p>
<h1 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h1><p><strong>我是一个很难因为自己而开心起来的人，我直到现在都没有找到真正能让我很开心的事情，我总觉得我存在的意义是为了周围的人，为了我的家人、伴侣和朋友。如果说取悦自己是一门课程的话，那我一定没有及格。</strong><br>        其实到现在我都不能理解为什么有人的开心能来的这么容易，我的好哥们会因为吃到好吃的而觉得开心，他可以为了吃专门跑出去一趟，我长这么大似乎都没有很喜欢很喜欢吃的东西，大部分食物都只是用来饱腹而已。<br>        这可能也和多巴胺能有关系，有的人就是很容易觉得幸福和满足，不需要出人头地，平平淡淡的生活已经能够让他们很开心很开心了。而有的人多巴胺能很强，对自己的现状很容易产生一种不满足的心理，这种人更容易取得一点成就，但是这一定就是好事吗？我并不觉得这种世俗意义上的成功和幸福感是有正相关性的。之前我一直希望我家的小孩能够好好读书，出人头地，大有作为；但现在我完全不这么想了，现在的小孩能活的开心的太少了，不需要有什么成就，开开心心的过一生就很好。<br>        <strong>如何经营好自己的生活、享受当下是我觉得我急需学习的一项技能。好消息是现在我已经迈出了第一步，我开始学画画、摄影、骑行、读书、分享自己的生活。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/3.png" alt="AB205C830C36C9F4AB42E05364A29BBA.jpg"><br>        就像中学一样，我是因为不想让家人过于担心我的成绩才开始努力学习，最终完成逆袭的。在大二开始之前的那个暑假我认识了当时的爱人，因为恋爱的原因，我觉得自己不能再继续颓废下去了，当时刚好极客勤奋蜂工作室开启了Go学员的培训，为了通过工作室的考核，我开始把大一学过的东西慢慢捡起来，然后每天把大量的时间丢在写代码，学技术上面。<strong>不知道是不是我的性格如此，不管是什么东西，只要我花了足够多的时间，我就会慢慢的不排斥这件事甚至喜欢上它。</strong>每做完一个嘉文学长设置的project我都会更热爱代码一分，每划掉每日to-do list中的一项我的成就感就会多一分，在成就感和满足感积累之中，我慢慢的开始喜欢上技术了。我想也许就是这样吧，在大学我也读过几本心理学的书籍，<strong>满足感、成就感、被需要感是做某些事情的最佳动力了，同时，一个最可怜的人也一定不是缺少财富、权利、地位，而一定是不被需要。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/4.png" alt="image.png"></p>
<p><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/5.png" alt="img"></p>
<p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，因为是第一次面试，我的印象真的非常深刻，问的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。<br>        之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在专业知识上被认可了，然后当天就去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。当天主要和峰哥、源哥聊的比较多，这也是我第一次了解创业相关的东西，比如融资是怎么一回事。<br>        之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装。<br>        差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，那边的环境是真的很好，呆着就容易让人心情愉悦，我慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/6.png" alt="56E6CD019183D099581FB095CF187A7C.jpg"><br>        源哥曾经说过这么一段话，我深以为然。<br>        “<strong>其实编程真的不是一件很难的事情，甚至是一个比较有意思的事情。只是大部分人还在学的阶段就放弃了，这个阶段他们只能抄别人的代码，自己写不出来东西，一旦自己能创造东西就能感受到编程的快乐了。</strong>”<br>        除了工程上的收获之外，我还认识了很多很厉害的大佬，基本上食铁兽成员的专业能力已经是我校一级梯队水准了，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来他思考的方面特别多。而且他知识的广度也很强，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐、洋哥，也都是很优秀的人，就不一一说了，食铁兽的氛围是真的挺好的，大家都是学生，没有那种领导的感觉，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。<br>        差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，也是我在校园最痛苦的一段时间，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，需要吃褪黑素才睡得着，不然脑子会一直处于活跃状态，明明身体很困，但是意识非常非常清晰。差不多准备了两个礼拜之后就开始投递简历了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，当时真的非常焦虑，觉得自己是不是要找不到工作了。最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是挂掉了，最后拿了一个小厂的offer但是不太想去。<br>    没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功，那段时间我对于linux和shell的熟悉程度也在直线上升。同时也和我校的研究生学长进行了交流和接触，更坚定了我不读研的想法。</p>
<p>“学长你学的什么方向啊？”<br>“开发吧，JAVA学了一半，没完全学完”<br>“那你发了paper吗？”<br>“还没有，还在写”<br>“打算毕业之后就业还是接着深造啊？”<br>“就业，读不下去了，读研都已经觉得很痛苦了。”<br>“读研究生有补贴吗？”<br>“一个月800”</p>
<h1 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h1><p>在大三入学后我又开始了新一轮的投递和面试，在开学的一周内拿了两家公司的offer，最后选择了去通明智云实习，这是一家搞负载均衡的公司，我们组负责开发负载均衡设备的纳管平台。<br>        那是第一次出远门实习，在此要感谢我的辅导员——林义钧老师，他是一位真正有师德，替学生考虑的老师，替我解决了学校里的很多麻烦，在大部分院都卡学生外出实习、完全不考虑当今就业市场学生可能毕业即失业、只顾学生就业率、升学率的情况下，林义钧老师仍然支持我实习，并替我解决了请假审批的问题。<br>        在通明智云我学到了很多东西，这是我第一次接触到生产级别的项目。我的leader韩哥是一个非常好的领导，并没有因为我是实习生就给我分配边角任务，而是真正有让我积极参与项目、融入到整个集体里面来，同时他也会让每个人不只负责一个模块，而是定期更换模块，让所有人对项目都有多方位的理解，也能真的学到技术。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/7.png" alt="689294415A37CFD7521DF177B8FA68A9.jpg"><br>        一开始主要负责部署相关的工作，负责和用户对接，能被leader信任，真的去做事情对我来说真的是一件挺有意义的事情。后面主要负责Prometheus相关的开发工作，但是没深入多久就和我当时的爱人分手了，后面整个人的状态其实都不太好，也没有多少产出，也确实是一件挺遗憾的事情。<br>        公司里还有来自北邮、北林的实习生，该说不说，长得都很帅。在之前我没觉得重邮本学历有多低，在实习之后发现好像确实有点低了。大家一起玩ranging loop、爬长城是真的挺开心的，长这么大第一次碰到除了LOL之外戳我的游戏，我之前一直以为自己不爱玩游戏呢。<br>        组里面的同事也很友好：说话很好笑很热心的美美、对技术很有追求的建国、像大哥哥一样很温暖的恩清、很腼腆的PM若培、喜欢玩摩托的士亮等等。还记得我理解不了需求、写不来mongo的查询语句、搞不懂prometheus实现原理、部署出问题的时候基本都是问的美美、建国和恩清，谢谢他们愿意花时间替我来擦屁股。总的来说大家都很好，氛围很温暖，下了班大家也会去地铁口那边一起吃饭，平常住在一栋楼里面交流也多。真的是一段很难忘也很有意义的经历，不仅仅是技术方面成长了，连带着待人接物、生活技能方面也学会了不少东西。<br>        现在我加入了百度APP业务中台部门，虽然呆的时间还不久，但是也能够感觉出来氛围挺好的，我的mentor宇哥和leader学明哥相处起来都给人一种很舒服的感觉，并且也是真的希望我能够学到东西，在我反应了我更想往Go方面去靠的时候，他们立马给我确定了之后的任务方向。百度给我的感觉是新人培养制度真的很不错，有很详细的培养方案，能够帮助实习生快速融入团队，同时整个部门的效率也非常高，不会在不该浪费时间的地方浪费时间，组里还有来自北大硕、北航硕的实习生，真的都是一群很优秀很优秀的人。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/8.png" alt="9CE5E3FDD31967D5D0140BB2F68751A9.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉自己真的很幸运，这么多年都没有碰到过坏人。从入学认识的室友、导员，到后面认识的学长学姐：胡仓学长、宋扬学长、彩嵘学长、文炀学长、嘉文学长，再到食铁兽认识的小伙伴：源哥、峰哥、婧姐、洋哥，再到通明智云的同事和leader，还有现在的mentor、同事和leader，大家都是很好很好的人，相处起来都非常舒服，感谢所有遇见。<br>        大三还没结束，要做的事情还有很多。回头看看其实比起刚入学那一会，我已经成长不少了，也学会了一些道理。也培养了一些比较好的习惯，比如我上大学前完全想不到我现在在假期也会学习、会定期阅读和运动、会主动走出舒适区去学一些我觉得我应该会的技能。</p>
<p>当然大学里也有一些不好的经历，甚至有些事情我到现在也没有想明白原因，不明白自己为什么要被这么对待。虽然不理解，但是也只能试着接受。</p>
<p>希望我能过好大学的最后一年零几个月的生活，收拾行囊，再度出发吧。也希望我能一直热爱编程，热爱我的事业。我几乎不在社交媒体上发编程相关的东西，一是觉得我还是个noob，需要学习的东西还有很多；二是不爱给自己打上程序员的这个tag，不想给自己设限。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">MySQL主键相关的一些思考及方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-02 23:10:48 / 修改时间：23:12:44" itemprop="dateCreated datePublished" datetime="2023-03-02T23:10:48+08:00">2023-03-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL创建表的时候可以不设置主键吗？"><a href="#MySQL创建表的时候可以不设置主键吗？" class="headerlink" title="MySQL创建表的时候可以不设置主键吗？"></a>MySQL创建表的时候可以不设置主键吗？</h3><p>MySQL创建表的时候是可以不主动设置主键的，但是表是一定需要一个主键的，MySQL会主动将第一个不为null的唯一索引设置为主键</p>
<h3 id="为什么MySQL推荐使用自增id作为主键？"><a href="#为什么MySQL推荐使用自增id作为主键？" class="headerlink" title="为什么MySQL推荐使用自增id作为主键？"></a>为什么MySQL推荐使用自增id作为主键？</h3><p>mysql官方推荐不要使用uuid或者不连续不重复的雪花作为主键，而是使用连续自增的主键id</p>
<p><strong>使用自增id的内部结构</strong></p>
<p>自增id的值是顺序的，所以innodb在索引B+树的叶子节点层面可以直接把每一条记录都存储在上一条记录的后面，当达到页面的最大填充因子的时候（页面容量已经满了）下一条记录就会写入新的页中，数据按照这种顺序的方式进行填充，主键页就会以近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费</p>
<p>新插入的行一定会在原有的最大数据行下一行，MySQL定位和寻址非常快，不会因为计算而做出额外的消耗，</p>
<p>并且能够减少页分裂和碎片的产生</p>
<p>页分裂：保证后一个数据页的所有行主键值比前一个数据页的主键值大，所以当ID不为自增的主键的时候，就会导致后一个页的所有行并不一定比前一个数据页的行的id大。这时就会触发页分裂的逻辑，对两个页之间的数据进行调整，甚至会涉及到多个数据页，导致性能降低</p>
<h3 id="使用自增id的缺点"><a href="#使用自增id的缺点" class="headerlink" title="使用自增id的缺点"></a>使用自增id的缺点</h3><ol>
<li>别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你业务的增长信息，从而分析出经营情况</li>
<li>对于高并发的负载，innodb在按照主键进行插入的时候会造成明显的锁争用，auto_increment锁机制会造成自增锁的争夺，有一定的性能损失</li>
</ol>
<h3 id="为什么分布式系统不用自增id，而是要用雪花算法生成id"><a href="#为什么分布式系统不用自增id，而是要用雪花算法生成id" class="headerlink" title="为什么分布式系统不用自增id，而是要用雪花算法生成id"></a>为什么分布式系统不用自增id，而是要用雪花算法生成id</h3><p>分布式id创建的业务需求</p>
<ol>
<li>全局唯一</li>
<li>趋势递增 innodb引擎的叶子结点是有序的双向链表，趋势递增可以增加性能，不会打乱树的结构</li>
<li>信息安全</li>
<li>最好包含时间戳</li>
</ol>
<p>为什么自增id不适合分布式系统？</p>
<p>当数据庞大的时候，在数据库分库分表之后，数据库自增id不能满足唯一id来表示数据；因为每个表都按照自己的节奏自增，会造成id冲突，从而无法满足需求</p>
<h3 id="使用auto-increment实现廉价的分布式唯一主键"><a href="#使用auto-increment实现廉价的分布式唯一主键" class="headerlink" title="使用auto_increment实现廉价的分布式唯一主键"></a>使用auto_increment实现廉价的分布式唯一主键</h3><p>flickr有类似的方案，构建是一个专用的数据库服务器，上面只有一个数据库，在数据库里面有用于32位id和64位id的id表，id是auto自增的，所有数据库生成id都会向这个服务器发请求，然后服务器分发id下去，也能达到一种分布式唯一主键的效果</p>
<p>类似于session-redis的思想，把所有的sessionid都存在redis里面，所有的服务器实例在比较cookie的时候就先去redis里面比较，这样就能避免因为负载均衡导致的cookie失效问题</p>
<p>当然这个廉价的做法显然是有很大问题的</p>
<ol>
<li>并发量很小，因为只有一台服务器</li>
<li>增加开销，并且整个请求流程变慢，因为需要向服务器发请求，并且是在硬盘层面进行操作的</li>
<li>flickr服务器成了整个系统的瓶颈和隐患，如果服务器宕机整个系统直接崩掉了</li>
</ol>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>是twitter开源的分布式id生成算法，结果是一个64位的longint类型，核心思想是用41位来作为时间戳，10位来作为机器的id,12位作为毫秒内的流水号（意味着每个节点可以在每毫秒生成4096个id），最后还有一个符号为永远为0 </p>
<p><strong>优点</strong></p>
<ul>
<li>完全在内存生成，高性能高可用</li>
<li>容量大，每秒可以生成几百万id</li>
<li>趋势递增，插入数据库索引树的时候，性能比较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>依赖系统时钟的一致性，如果某台机器的系统时钟回拨，有可能造成id冲突</li>
<li>多台机器的ID只能保证趋势增加，即每一台机器都能保证这台机器生成的ID是在增加的，但是多台机器并不一定绝对递增</li>
<li>41位时间戳只能保证69年无重复ID</li>
<li>因为是64位的ID，在传递给前端的时候需要用字符串的类型进行传递，因为js的number类型最大只支持53位</li>
</ul>
<h3 id="其他分布式ID方案"><a href="#其他分布式ID方案" class="headerlink" title="其他分布式ID方案"></a>其他分布式ID方案</h3><ul>
<li>UUID:JAVA自带的API，生成一个唯一性的字符串，不能保证有序递增</li>
<li>UidGenerator:百度开源的分布式ID生成器，基于雪花算法</li>
<li>Leaf:美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但是需要依赖关系数据库、Zookeeper等中间件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">中台是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 08:28:04 / 修改时间：08:28:51" itemprop="dateCreated datePublished" datetime="2023-03-01T08:28:04+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中台是一个非常宽泛的概念，可以是技术平台，比如框架、devops平台、容器云之类的，也可以是业务平台，像用户中心、订单中心、各种微服务集散。</p>
<h3 id="为什么需要中台？"><a href="#为什么需要中台？" class="headerlink" title="为什么需要中台？"></a>为什么需要中台？</h3><p>中台的产生可能是高层的战略设计，也可能是公司不断膨胀而暴露出来的种种问题需要被解决。</p>
<p>中台一开始诞生于16年阿里提出的“大中台，小前台”概念，中台的价值是以快速响应需求为依切，中台并不是一开始就有的，而是基于“前台+后台”的架构发展演变的</p>
<p>前台：系统的前端平台，是直接与终端用户进行交互的应用层，比如日常使用的app,h5（html5 通常用来写移动端的前端和web的前端）,pc端都是属于前台</p>
<p>后台：后台是指系统的后端平台，终端用户无法感知，提供后端服务</p>
<p>因为用户的需求是会高速变化的，而用户需求的变化决定了前台系统需要快速迭代响应用户需求，而前端的变化又需要后端的变化来进行支撑，这就对后台的快速应变提出了要求，而后台的核心目的并不是服务于前台，而是提升后端数据的安全及系统的管理效率</p>
<p>于是就产生了“前端为了用户需求，期望系统不断的快速迭代”与“后段为了数据安全与系统稳定，期望系统趋于稳定”的矛盾局面，为了解决这一矛盾，架构师们创造性的提出了“中台”这一概念，核心就是将后台的逻辑层进行拆离，形成前端（应用层）-中台（逻辑层）-后台（数据层）的产品架构，在这一架构下，当前端需求出现时，中台能够快速的进行响应，从而提升了研发效率，降低了创新成本</p>
<p>阿里中台战略最早从业务中台和数据中台建设开始，采用了双中台的建设模式，到后来发展出了移动中台，技术中台和研发中台等等。</p>
<p><img src="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/1677551872346-10e243df-5756-457d-ba84-cfa2585f525c.png" alt="img"></p>
<h3 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h3><p>一般是指支持企业线上核心业务的中台，承载了核心业务能力，实现企业级业务能力复用和各业务板块之间的联通和协同</p>
<h3 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h3><p>与业务中台相辅相成，共同支持前台一线业务，大部分数据来源于业务中台，经过数据建模和数据分析等操作之后，将加工后的数据返回业务中台为前台应用提供服务，或者直接以数据类应用的方式向前台应用提供api数据服务，一般包括数据采集、数据生成、数据治理、数据应用以及数据仓库或大数据等技术应用</p>
<h3 id="技术中台"><a href="#技术中台" class="headerlink" title="技术中台"></a>技术中台</h3><p>业务中台落地的时候需要很多的技术组建来支撑，这些不同技术领域的技术组建就组成了技术中台。比如一些业务关键技术的组件</p>
<ul>
<li>api网关</li>
<li>开发框架</li>
<li>微服务治理</li>
<li>分布式数据库</li>
<li>数据处理组件</li>
</ul>
<p> <strong>api网关</strong></p>
<p>前后端分离，通过网关实现前后端集成，api网关主要包括：鉴权、降级限流、流量分析、负载均衡、服务路由和访问日志等功能。api网关可以帮助用户方便地管理微服务api接口，实现安全的前后端分离，实现高效的系统集成和精细的服务监控</p>
<p><strong>开发框架</strong></p>
<p>开发框架主要包括前端开发和后端微服务开发框架，支持代码自动生成，本地调试和依赖管理等功能</p>
<p><strong>微服务治理</strong></p>
<p>服务治理是在为服务的运行过程中，针对微服务的运行状况采取的动态治理策略，如服务注册、发现、限流、 熔断和降级等等，以保障微服务能够持续稳定的运行</p>
<p>治理主要应用于微服务运行中的状态监控、微服务运行异常时的治理策略配置等场景，保障微服务在常见异常场景下的自恢复能力</p>
<p><strong>分布式数据库</strong></p>
<p>分布式数据库一般都具有较强的数据线性拓展能力，它们大多采用数据多副本机制实现数据库高可用，具有可拓展和低成本等技术优势，一般分为三类：交易型、分析型、交易分析混合型</p>
<ul>
<li>交易型：用于解决交易类业务的数据库计算能力，支持数据分库、分片、数据多副本，具有高可用的特性，提供统一的运维界面，具备高性能的交易型业务处理分析能力。</li>
<li>分析型：通过横向扩展能力和并行计算能力，提高数据整体计算能力和吞吐量，支持海量数据的分析</li>
<li>混合型：通过资源隔离、分时和数据多副本等技术手段，基于不同的数据存储、访问性能和容量等需求，使用不同的存储介质和分布式计算存储，同时满足业务交易和分析需求</li>
</ul>
<p><strong>数据处理组件</strong></p>
<p>为了提高应用性能和业务的承载能力，降低微服务的耦合度，实现分布式架构下的分布式事务等要求，技术中台还有很多数据处理相关的基础技术组件。如分布式缓存、搜索引擎、数据复制、消息中间件和分布式事务等技术组建</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生学习（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 12:45:05" itemprop="dateCreated datePublished" datetime="2023-02-26T12:45:05+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 22:43:12" itemprop="dateModified" datetime="2023-02-27T22:43:12+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC是一种现代化开源的RPC框架，由Google进行研发，能够运行于任何环境之中，最初由谷歌进行开发，它使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC中，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，帮助你更容易创建分布式应用程序和服务。gRPC是基于定义一个服务，制定一个可以远程调用的带有参数和返回类型的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用，在客户端，有一个stub提供和服务端相同的方法</p>
<p><img src="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/1676256947622-90dcc6f3-615b-4154-a261-5a45a2beedbc.png" alt="img"></p>
<h3 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h3><p>gRPC可以帮助我们一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，也就是说gRPC解决了<strong>不同语言以及环境间通信的复杂性</strong>。使用<code>protocol buffer</code>还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之，使用gRPC能够帮助我们更容易编写跨语言的分布式代码</p>
<p>IDL（Interface description Language） 是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成</p>
<h3 id="使用gRPC进行开发的步骤"><a href="#使用gRPC进行开发的步骤" class="headerlink" title="使用gRPC进行开发的步骤"></a>使用gRPC进行开发的步骤</h3><p><strong>1.编写.proto文件定义服务</strong></p>
<p>默认情况下gRPC使用<code>protocol buffers</code>作为接口定义语言（IDL）来描述服务接口和有效负载消息的结构</p>
<p>在gRPC中可以定义四种类型的服务方法 	</p>
<p>普通rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>服务器流式rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，知道没有更多的消息，gRPC保证在单个RPC调用的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>客户端流式rpc，其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应，同样，gRPC保证单个RPC调用中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LostsOfGreetings(stream HelloRequest) returns(HelloResponse);</span><br></pre></td></tr></table></figure>

<p>双向流式rpc，其中双方使用读写流发送一系列消息，这两个流独立运行，因此客户端和服务器可以按照自己指定的顺序读写；例如，服务器可以等待接受所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc StreamGreetings(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p><strong>2.生成指定语言的代码（客户端一份、服务端一份）</strong></p>
<p>在<code>.proto</code>文件中定义好服务之后，gRPC提供了生成客户端和服务端代码的protocol buffers编译器插件。</p>
<p>我们使用这些插件可以根据需要生成<code>Java Go C++ Python</code>等语言的代码，我们通常会在客户端调用这些API，并且在服务器端实现对应的API</p>
<ul>
<li>在服务器端，服务器实现服务声明的方法，并运行一个gRPC服务器来处理客户端发来的调用请求。gRPC底层会对传入的请求进行编码，执行被调用的服务方法，并对服务响应进行编码</li>
<li>在客户端，客户端有一个称为存根(stub)的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的<code>protocol buffers</code>消息类型中–gRPC在向服务器发送请求并返回服务器的<code>protocol buffers</code>响应之后进行处理</li>
</ul>
<p><strong>3.编写业务逻辑代码</strong></p>
<p>proto文件生成<code>pb.go</code>以及<code>grpc.pb.go</code>的命令</p>
<p>不指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>

<p>指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=xx --go_out=pb --go_opt=paths=source_relative --go-grpc_out=pb --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>



<h3 id="使用grpc实现一个简单的hello服务"><a href="#使用grpc实现一个简单的hello服务" class="headerlink" title="使用grpc实现一个简单的hello服务"></a>使用grpc实现一个简单的hello服务</h3><p><strong>Server</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer //当没有完全实现proto中的所有方法时依旧可以运行起来</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// gRPC通过.proto文件自动生成的SayHello方法  </span><br><span class="line">func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) &#123;</span><br><span class="line">	reply := &quot;hello&quot; + in.GetName()</span><br><span class="line">	return &amp;pb.HelloResponse&#123;Reply: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:8972&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to listen,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 注册服务</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	// 启动服务</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_server/pb&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//连接server 带加密连接</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:8972&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;grpc.Dial failed,err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	//创建客户端</span><br><span class="line">	c := proto.NewGreeterClient(conn)</span><br><span class="line">	//使用context进行控制，传入background和超时时间一秒钟</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	name := &quot;xiaocheng&quot;</span><br><span class="line">	resp, err := c.SayHello(ctx, &amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.SayHello failed, err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 拿到RPC响应</span><br><span class="line">	log.Printf(&quot;resp:%v&quot;, resp.GetReply())</span><br><span class="line">&#125;</span><br><span class="line">// 应该是同一份proto文件</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_client/proto&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块 必须与server端一致</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用grpc实现一个简单的add服务"><a href="#使用grpc实现一个简单的add服务" class="headerlink" title="使用grpc实现一个简单的add服务"></a>使用grpc实现一个简单的add服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedAddMethodServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *server) Add(ctx context.Context, in *pb.AddRequest) (*pb.AddResponse, error) &#123;</span><br><span class="line">	reply := in.GetArgs1() + in.GetArgs2()</span><br><span class="line">	return &amp;pb.AddResponse&#123;Number: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;net listen failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterAddMethodServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>proto文件应该在客户端和服务端都有一份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">option go_package=&quot;server/pb&quot;;</span><br><span class="line">package pb;</span><br><span class="line"></span><br><span class="line">service AddMethod &#123;</span><br><span class="line">   rpc Add(AddRequest) returns (AddResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddRequest &#123;</span><br><span class="line">  int32 args1 =1;</span><br><span class="line">  int32 args2 =2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddResponse &#123;</span><br><span class="line">  int32 number =1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:9999&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;grpc dail failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	c := pb.NewAddMethodClient(conn)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	var args1, args2 int32</span><br><span class="line">	args1 = 1</span><br><span class="line">	args2 = 2</span><br><span class="line">	resp, err := c.Add(ctx, &amp;pb.AddRequest&#123;Args1: args1, Args2: args2&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;c.Add failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(&quot;Add Response:&quot;, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protobuf语法"><a href="#protobuf语法" class="headerlink" title="protobuf语法"></a>protobuf语法</h3><p><strong>protobuf为什么体积小、解析快</strong></p>
<p>protobuf是google提出的数据交换格式，同一条消息数据，使用Protobuf序列化之后占用空间是json的1&#x2F;10，但是性能却是几十倍</p>
<p>原因</p>
<ul>
<li>编解码大多采用位运算，比JSON&#x2F;XML的字符匹配效率更高</li>
<li>pb定义了varint类型，使用变长编码压缩数值类型。值越小的数字，使用的字节数就越少</li>
<li>采用Tag-value类型，没有冗余字符</li>
</ul>
<p><strong>定义一个消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">	string query =1;</span><br><span class="line">	int32 page_number=2; </span><br><span class="line">&#125;</span><br><span class="line">//文件的第一行指定使用proto3语法，如果不这么写</span><br><span class="line">//pb的编译器默认使用proto2</span><br><span class="line"></span><br><span class="line">//SearchRequest定义了一个消息，使用了两个字段</span><br><span class="line">//每个字段需要定义类型 名字 和编号</span><br></pre></td></tr></table></figure>



<p><strong>字段编号</strong></p>
<p>消息定义中的每个字段都要有一个唯一的编号，这些编号用来在消息二进制格式中标识字段，<strong>在消息类型使用后就不能更改</strong>。在范围1到15中的字段需要一个字节进行编码，而16-2047的字段采用两个字节。所以应该为经常使用的消息元素保留数字1到15的编号，也要为将来可能添加的经常使用的元素留出一些编号</p>
<p><strong>指定字段规则</strong></p>
<p>消息字段可以是下列字段之一</p>
<ul>
<li>singular：格式正确的消息可以有这个字段的0个或者一个，默认使用singular字段</li>
<li>repeated：该字段可以在格式正确的消息中重复任意次数（包括0次），重复值的顺序将被保留</li>
<li>optional：该字段在传递的时候可选也可不选</li>
</ul>
<p><strong>保留字段</strong></p>
<p>如果你通过完全删除字段或者将其注释来<strong>更新消息类型，</strong>那么未来的用户在对该类型进行自己的更新的时候就可以重用字段号，如果其他人以后加载旧版本的相同<code>.proto</code>文件，这可能就会导致严重的问题，比如数据损坏、隐私漏洞等等。</p>
<p>解决方法是指定已经删除的字段的字段编号，如果将来有用户尝试使用这些字段标识符，protocol buffer编译器将发出提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">reserved 2,15,9 to 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>值类型</strong></p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java&#x2F;Kotlin Type[1]</th>
<th>Python Type[3]</th>
<th>Go Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint32代替。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>int64</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint64代替。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码。</td>
<td>uint64</td>
<td>long[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>sint32</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int32更有效地编码负数。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int64更有效地编码负数。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是四个字节。如果值经常大于228，则比 uint32更有效率。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8字节。如果值经常大于256，则比 uint64更有效率。</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是四个字节。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是八个字节。</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>字符串必须始终包含 UTF-8编码的或7位 ASCII 文本，且不能长于232。</td>
<td>string</td>
<td>String</td>
<td>str&#x2F;unicode[5]</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可以包含任何不超过232字节的任意字节序列。</td>
<td>string</td>
<td>ByteString</td>
<td>str (Python 2) bytes (Python 3)</td>
<td>[]byte</td>
<td>string</td>
</tr>
</tbody></table>
<p><strong>枚举</strong></p>
<p>在定义消息类型的时候，可能希望其中的一个字段只能是预定义的值列表中的一个值。下面是一个栗子，Conrpus字段的值只能是其中的一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">string query = 1;</span><br><span class="line">  int32 page_number = 2;</span><br><span class="line">  int32 result_per_page = 3;</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = 4;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>嵌套消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated Result results = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  string url = 1;</span><br><span class="line">  string title = 2;</span><br><span class="line">  repeated string snippets = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Any</strong></p>
<p>Any类型允许你将消息作为嵌入类型使用，使用Any类型需要导入<code>google/protobuf/any.proto</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">  repeated google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>oneof</strong></p>
<p>如果你有一条包含多个字段的消息，并且同时最多设置其中的一个字段，那么可以通过oneof来实现并节省内存，可以通过<code>case()</code>或者<code>WihchOneOf()</code>来检查one  of 中的哪个值被设置（如果有）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string name = 4;</span><br><span class="line">    SubMessage sub_message = 9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> SampleMessage message;</span><br><span class="line">  message.set_name(&quot;name&quot;);</span><br><span class="line">  CHECK(message.has_name());</span><br><span class="line">  message.mutable_sub_message();   // Will clear name field.</span><br><span class="line">  CHECK(!message.has_name());</span><br></pre></td></tr></table></figure>

<p><strong>Maps</strong></p>
<p>如果想创建一个关联映射作为数据定义的一部分，可以使用这个map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<h3 id="protobuf实战"><a href="#protobuf实战" class="headerlink" title="protobuf实战"></a>protobuf实战</h3><p><strong>oneof字段</strong></p>
<p>oneof中的值只能选择其中的一个  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message NoticeReaderRequest &#123;</span><br><span class="line">  string msg=1;</span><br><span class="line">  oneof notice_way&#123;</span><br><span class="line">    string email=2;</span><br><span class="line">    string phone=3;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的服务端代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func oneofDemo() &#123;</span><br><span class="line">	req := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is chengxisheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Email&#123;</span><br><span class="line">			Email: &quot;xxx&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	req2 := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is xishengcheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Phone&#123;</span><br><span class="line">			Phone: &quot;1008611&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req2.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithEmail(in *book.NoticeReaderRequest_Email) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by email:%v\n&quot;, in.Email)</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithPhone(in *book.NoticeReaderRequest_Phone) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by phone:%v\n&quot;, in.Phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里必须使用类型断言+switch case </span><br><span class="line">//来进行one of 字段的确认</span><br></pre></td></tr></table></figure>

<p><strong>wrapvalue类型</strong></p>
<p>首先让我们想一想Go中区分一个MySQL的int类型是默认值还是0值该怎么做？</p>
<p>其实就只有以下两种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">price sql.NullInt64</span><br><span class="line">price *int64</span><br><span class="line">//第一种方式是一个定义好的结构体 </span><br><span class="line">//里面有一个字段是 该结构体是否被赋值</span><br><span class="line">//第二种方式是直接用指针来做</span><br><span class="line">//对指针解引用，如果为0则赋值，如果为Nil则是默认值</span><br><span class="line">func wrapValueDemo() &#123;</span><br><span class="line">	// client</span><br><span class="line">	 book:=book.Book&#123;</span><br><span class="line">		 Title: &quot;learning go language&quot;,</span><br><span class="line">		 Price: &amp;wrapperspb.Int64Value&#123;Value: 600&#125;,</span><br><span class="line">		 Memo: &amp;wrapperspb.StringValue&#123;Value: &quot;学&quot;&#125;,</span><br><span class="line">	 &#125;</span><br><span class="line">	 // server </span><br><span class="line">	 if book.GetPrice()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetPrice().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">	 if book.GetMemo()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetMemo().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FieldMask类型</strong></p>
<p>当我们更新的时候，定义了很多字段，不可能全部进行全量更新Book的每个字段，因为通常操作只会更新1到2个字段。</p>
<p>当我们想知道更新操作涉及到的具体字段，就需要使用到filedmask类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // 操作人</span><br><span class="line">  string op =1;</span><br><span class="line">  // 要更新的书籍信息</span><br><span class="line">  Book book=2;</span><br><span class="line">  // 要更新的字段</span><br><span class="line">  google.protobuf.FieldMask update_mask=3;</span><br><span class="line">&#125;</span><br><span class="line">func fieldMaskDemo() &#123;</span><br><span class="line">	//client</span><br><span class="line">	paths := []string&#123;&quot;price&quot;&#125;</span><br><span class="line">	req := &amp;book.UpdateBookRequest&#123;</span><br><span class="line">		Op: &quot;chengxisheng&quot;,</span><br><span class="line">		Book: &amp;book.Book&#123;</span><br><span class="line">			Price: &amp;wrapperspb.Int64Value&#123;Value: 8800&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateMask: &amp;fieldmaskpb.FieldMask&#123;Paths: paths&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	mask, _ := fieldmask_utils.MaskFromProtoFieldMask(req.UpdateMask, generator.CamelCase)</span><br><span class="line">	var bookDst = make(map[string]interface&#123;&#125;)</span><br><span class="line">	fieldmask_utils.StructToMap(mask, book.UpdateBookRequest&#123;&#125;.Book, bookDst)</span><br><span class="line">	fmt.Printf(&quot;bookDst:%#v\n&quot;, bookDst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端流式RPC"><a href="#服务端流式RPC" class="headerlink" title="服务端流式RPC"></a>服务端流式RPC</h3><p>对应的proto（client和server）中添加一个流式方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>



<p>Server添加一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfReplies(in *pb.HelloRequest, stream pb.Greeter_LotsOfRepliesServer) error &#123;</span><br><span class="line">	words := []string&#123;</span><br><span class="line">		&quot;你好&quot;,</span><br><span class="line">		&quot;hello&quot;,</span><br><span class="line">		&quot;こんにちは&quot;,</span><br><span class="line">		&quot;안녕하세요&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	for _, word := range words &#123;</span><br><span class="line">		data := &amp;pb.HelloResponse&#123;</span><br><span class="line">			Reply: word + in.GetName(),</span><br><span class="line">		&#125;</span><br><span class="line">		// 使用Send方法发送多个数据 每当有一个data就send一次数据</span><br><span class="line">		if err := stream.Send(data); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端添加一个新的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func callLotsOfReplies(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	stream, err := c.LotsOfReplies(ctx, &amp;proto.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	for &#123;</span><br><span class="line">		//依次从流式响应中读取返回的响应数据</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;got reply: %q\n&quot;, res.GetReply())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端流式RPC"><a href="#客户端流式RPC" class="headerlink" title="客户端流式RPC"></a>客户端流式RPC</h3><p>在<code>hello.proto</code>中添加这么一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在server端添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfGreetings(stream pb.Greeter_LotsOfGreetingsServer) error &#123;</span><br><span class="line">   reply := &quot;你好:&quot;</span><br><span class="line">   for &#123;</span><br><span class="line">      //接受客户端发来的流式数据</span><br><span class="line">      res, err := stream.Recv()</span><br><span class="line">      if err == io.EOF &#123;</span><br><span class="line">         return stream.SendAndClose(&amp;pb.HelloResponse&#123;</span><br><span class="line">            Reply: reply,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         return err</span><br><span class="line">      &#125;</span><br><span class="line">      reply += res.GetName()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Client端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func runLotsOfGreeting(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	defer cancel()</span><br><span class="line">	// 客户端要流式的发送请求消息</span><br><span class="line">	stream, err := c.LotsOfGreetings(ctx)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.LotsOfGreetings failed,err:%v\n&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	names := []string&#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;</span><br><span class="line">	for _, name := range names &#123;</span><br><span class="line">		stream.Send(&amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">		time.Sleep(200 * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	//关闭流</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	log.Printf(&quot;res:%v\n&quot;, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向流式RPC"><a href="#双向流式RPC" class="headerlink" title="双向流式RPC"></a>双向流式RPC</h3><p>在proto中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在client中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在Server端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// magic 一段价值连城的“人工智能”代码</span><br><span class="line">func magic(s string) string &#123;</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吗&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吧&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;你&quot;, &quot;我&quot;)</span><br><span class="line"></span><br><span class="line">	s = strings.ReplaceAll(s, &quot;？&quot;, &quot;!&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;?&quot;, &quot;!&quot;)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MetaData元数据"><a href="#MetaData元数据" class="headerlink" title="MetaData元数据"></a>MetaData元数据</h3><p>metadata是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用的是键值对列表 的形式，其中键是string类型，值通常是[]string类型，但也可以是二进制数据。gRPC中的metadata类似于我们在HTTP headers中的键值对，元数据可以包含认真token、请求标识和监控标签等等</p>
<p>metadata中的键是大小写不敏感的，不能以grpc-开头，并且二进制的简明必须以-bin结尾，元数据对gRPC本身是不可见的，通常在应用程序代码或者中间件中处理元数据，我们不需要再.proto中指定元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MD map[string][]string</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-24 12:07:13 / 修改时间：12:08:30" itemprop="dateCreated datePublished" datetime="2023-02-24T12:07:13+08:00">2023-02-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h3><p>用架构历史</p>
<p>1.单体架构 堆机子 高耦合 一改动就需要重新部署 而且编译时间很长，不容易拓展，不支持多语言技术栈 </p>
<p>2.分层架构 典型的有MVC和MSC架构 当访问量逐渐增大，单体架构扛不住了，把单体项目进行垂直划分，耦合还是很大，项目之间的接口多为数据同步，比如不同项目之间的数据库同步。 架构简单，成本低开发周期短，经过垂直拆分之后原来的单体项目不至于太大，每一层可以用不同的技术，但还是不易拓展和维护 </p>
<p>3.SOA面向服务架构 ：当垂直架构的应用越来越多，就会出现多个应用都依赖的业务组件，比如数据库，而且各个应用交互越来越频繁，此时就需要把部分通用的组件拆分独立处理，于是SOA面向服务架构诞生了，它带来了模块化开发、分布式拓展部署和服务接口定义等概念</p>
<p>实时SOA需要建立企业服务总线，外部应用通过总线调用服务，有以下特征：可从企业外部访问、随时可用、标准化的服务接口等</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>已经具有微服务的影子了，将重复的功能抽离出来，提高开发效率</li>
<li>减少接口耦合</li>
</ul>
<p>SOA架构适用于大型软件服务企业对外提供服务的场景，并不适合一般的业务场景，其服务的定义、注册和调用都需要繁琐的配置，业务总线的吞吐量决定了整个系统的上限，因为整个系统都是通过总线进行任务分配的。并且业务总线也容易导致系统崩掉、影响性能。</p>
<p>4.微服务架构：</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt="img"></p>
<p>特点</p>
<p>1.服务层完全独立出来 并将服务层抽取为一个一个的微服务</p>
<p>2.微服务遵循单一原则</p>
<p>3.微服务之间采用RESTful等轻量协议通信</p>
<p>4.微服务一般用容器技术部署 运行在自己的独立进程中</p>
<p>微服务架构下服务的拆分粒度更细，有利于资源重复利用，提高开发效率，采用去中心化思想，更轻量级</p>
<p>缺点：如果服务实例过多，治理成本就会很大，不利于维护；服务之间相互依赖，可能形成复杂的依赖链条，往往单个服务异常，其他服务也会受到影响，出现服务雪崩效应。</p>
<p>微服务与SOA的区别：</p>
<p>微服务继承了SOA的众多优点和理念</p>
<p>SOA更适合与许多其他应用程序继承的大型复杂企业应用程序环境，小型的应用并不适合SOA，微服务则更适合于较小和良好的分割式web业务系统</p>
<p>微服务不再强调SOA架构中比较重要的ESB企业服务总线，而是通过轻量级通信机制相互沟通</p>
<p>SOA注重的是系统继承，而微服务关注的则是完全分离，SOA尝试采用中心化管理来确保各个应用能够协同运作，微服务则尝试部署新功能，快速有效地拓展开发团队，它着重于分散管理、代码再利用和自动化执行。</p>
<h3 id="微服务的优势和劣势"><a href="#微服务的优势和劣势" class="headerlink" title="微服务的优势和劣势"></a>微服务的优势和劣势</h3><p>微服务的优势</p>
<p>1.快：更注重CI&#x2F;CD 敏捷开发、持续交付</p>
<p>2.准：服务粒度小、服务质量精准可控</p>
<p>3.狠：适用于互联网时代、产品迭代周期更短</p>
<p>微服务的劣势</p>
<p>1.系统的复杂性</p>
<p>2.服务依赖管理</p>
<p>3.数据的一致性保障</p>
<p>4.测试更加艰难</p>
<p>5.对于DevOps等基础设施的高要求</p>
<h3 id="如何划分微服务界限"><a href="#如何划分微服务界限" class="headerlink" title="如何划分微服务界限"></a>如何划分微服务界限</h3><p>如何进行服务划分？</p>
<p>1.按照业务职能进行划分</p>
<p>由公司内部不同部门提供的只能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能</p>
<p>2.按照DDD的限界上下文划分</p>
<p>限界上下文是DDD中用来划分不同业务边界的元素</p>
<p>这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域</p>
<p>为了解决某种类型的业务问题，贴近领域只是，也就是业务</p>
<p>CQRS将系统中的操作划分为两类，即【命令】Command和【查询】Query</p>
<p>命令则是对会引起数据发生变化操作的总称，即我们常说的新增、更新、删除的这些操作，都是命令。</p>
<p>而查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查询数据。</p>
<p>CQRS的核心思想是将两类不同的操作进行分离，然后在两个独立的【服务】中实现。这里的服务一般指的是两个独立部署的应用，在某些特殊情况下，也可以部署在同一个应用内的不同接口上。 </p>
<h3 id="微服务的迭代"><a href="#微服务的迭代" class="headerlink" title="微服务的迭代"></a>微服务的迭代</h3><p>1.第一代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt="img"></p>
<p>2.第二代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt="img"></p>
<p>把那些服务监控、服务管理作为基础服务提供给我们的业务</p>
<p>架构分层</p>
<p> <img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/5.png" alt="img"></p>
<p>核心组件</p>
<ul>
<li>API网关</li>
<li>服务注册中心</li>
<li>配置中心</li>
<li>服务通信</li>
<li>服务治理</li>
<li>服务监控</li>
</ul>
<h2 id="net-x2F-rpc"><a href="#net-x2F-rpc" class="headerlink" title="net&#x2F;rpc"></a>net&#x2F;rpc</h2><h3 id="RPC出现的原因"><a href="#RPC出现的原因" class="headerlink" title="RPC出现的原因"></a>RPC出现的原因</h3><p>RPC需要解决三个问题</p>
<p>1.如何要确定要执行的函数？在本地调用中，函数主体通过函数指针函数指定，然后调用add函数，编译器你通过函数指针函数确定add函数在内存中的位置。但是在RPC中，调用不能通过函数指针完成，因为他们的内存地址可能完全不同。因此，调用方和被调用方都需要维护一个{fuction&lt;-&gt;ID}映射表，以确保调用正确的函数</p>
<p>2.如何表达参数？本地过程调用中传递的参数是通过堆栈结构实现的，但是RPC不能直接使用内存传递参数，因此参数或返回值需要在传输期间徐丽湖儿啊并转换成字节流，反之亦然</p>
<p>3.如何通过网络传输？函数的调用方和被调用方通常是通过网络连接的，也就是说 function ID和序列化字节流需要通过网络传输，因此，只要能够完成传输，调用方和被调用方就不受某个网络协议的限制。例如，一些RPC框架使用TCP协议，一些使用HTTP。</p>
<p>以往实现跨服务调用的时候，我们会采用restful api的方式，被调用方会对外提供一个HTTP接口，调用方按要求发起HTTP请求并接收API接口返回的响应数据。</p>
<p>本地调用，通过HTTP的API的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">//定义参数和响应  </span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(x, y int) int &#123;</span><br><span class="line">	return x + y</span><br><span class="line">&#125;</span><br><span class="line">// addHandler 解析参数+调用add+响应写回</span><br><span class="line">func addHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	// parse parameters</span><br><span class="line">	b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	var param addParam</span><br><span class="line">	json.Unmarshal(b, &amp;param)</span><br><span class="line">	// use the add func</span><br><span class="line">	ret := add(param.X, param.Y)</span><br><span class="line">	// return the response</span><br><span class="line">	respBytes, _ := json.Marshal(addResult&#123;Code: 0, Data: ret&#125;)</span><br><span class="line">	w.Write(respBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/add&quot;, addHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:9090&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	url := &quot;http://127.0.0.1:9090/add&quot;</span><br><span class="line">	param := addParam&#123;</span><br><span class="line">		X: 10,</span><br><span class="line">		Y: 20,</span><br><span class="line">	&#125;</span><br><span class="line">	// marshal to json</span><br><span class="line"></span><br><span class="line">	paramBytes, _ := json.Marshal(param)</span><br><span class="line">	// call</span><br><span class="line">	resp, _ := http.Post(url, &quot;application/json&quot;, bytes.NewReader(paramBytes))</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line">	respBytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	var respData addResult</span><br><span class="line">	json.Unmarshal(respBytes, &amp;respData)</span><br><span class="line">	fmt.Println(respData.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而RPC调用则不需要如此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">service.go</span><br><span class="line">type Args struct &#123;</span><br><span class="line">	X, Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ServiceA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Add is an out method</span><br><span class="line">// has two args and a return </span><br><span class="line">// two params must be out </span><br><span class="line">// and the return value must be error type </span><br><span class="line">func (s *ServiceA) Add(args *Args, reply *int) error &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line">server.go</span><br><span class="line">func main() &#123;</span><br><span class="line">  //new service instance   </span><br><span class="line">	service := new(yunyuansheng.ServiceA)</span><br><span class="line">  //register rpc service   </span><br><span class="line">	rpc.Register(service) </span><br><span class="line">  //botton on http  </span><br><span class="line">	//rpc.HandleHTTP()      </span><br><span class="line">  //botton on tcp   </span><br><span class="line">	l, e := net.Listen(&quot;tcp&quot;, &quot;:9091&quot;)</span><br><span class="line">	if e != nil &#123;</span><br><span class="line">		log.Fatal(&quot;listen error:&quot;, e)</span><br><span class="line">	&#125;</span><br><span class="line">	//http.Serve(l, nil)</span><br><span class="line">	for &#123;</span><br><span class="line">	  // accpet the request and serve   </span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">client.go</span><br><span class="line">func main() &#123;</span><br><span class="line">	//因为服务端是HTTP请求 所以要建立HTTP连接</span><br><span class="line">	client, err := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:9091&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 同步调用 Call</span><br><span class="line">	args := &amp;yunyuansheng.Args&#123;10, 20&#125;</span><br><span class="line">	reply := new(int)</span><br><span class="line">	err = client.Call(&quot;ServiceA.Add&quot;, args, reply)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;ServiceA.Add error:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;ServiceA.Add %d+%d=%d\n&quot;, args.X, args.Y, *reply)</span><br><span class="line"></span><br><span class="line">	//异步调用 Go</span><br><span class="line">	var reply2 int</span><br><span class="line">	divCall := client.Go(&quot;ServiceA.Add&quot;, args, &amp;reply2, nil)</span><br><span class="line">	replyCall := &lt;-divCall.Done //Done是一个调用结果的通知 有值了就说明调用完成了</span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>RPC的最终目的：让调用远程方法更加简单，并且速度更快</strong></p>
<p><strong>Go原生net&#x2F;rpc库需要注意的几点</strong></p>
<p><strong>1.可以支持很多种协议，包括但不限于HTTP和TCP，如果使用HTTP的话，那么客户端就使用DialHTTP，服务端通过HandleHTTP进行HTTP连接的处理，使用TCP的话，客户端使用Dial，服务端就应该for循环处理连接</strong></p>
<p><strong>2.客户端支持同步调用和异步调用两种方式，对应的分别是Call和Go</strong></p>
<p><strong>3.暴露出的服务必须满足两个条件，两个参数，一个返回值，返回值必须要是error类型，第二个参数必须是指针</strong></p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt="img"></p>
<ol>
<li>client以本地调用方式调用服务</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体</li>
<li>client stub找到服务地址，并将服务发送到服务端</li>
<li>server 接收到消息之后，通过server stub对消息进行解码</li>
<li>server stub根据解码的结果调用本地服务</li>
<li>本地服务执行并把消息返回给server stub</li>
<li>server stub将结果打包成能够进行网络传输的结构体，发送到消息方</li>
<li>client 收到消息并进行解码，得到最终结果</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">141k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:08</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
