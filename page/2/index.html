<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/toms%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/toms%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">toms初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:43 / 修改时间：22:19:45" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:43+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="toms初识"><a href="#toms初识" class="headerlink" title="toms初识"></a>toms初识</h1><p>tmos一个特征和功能的集和，为了满足当今市场而出现的一个代理、高性能的一系列操作系统和固件，他们都在big-ip硬件设备上或BIG-IP虚拟版中运行</p>
<p>基于包设计和基于代理（全权代理）设计的区别<br>- 基于包：这些网络设备都是网络数据流中间的节点，并不是数据交互流的终点或起点，并且这些设备只需要满足部分协议而不是整个协议栈，比如一个位于第三层（IP）的设备，可能只需要会读写IP地址TCP地址即可，至于第二层第一层的协议将与其无关。现在这些设备越来越智能了，可以修改tcp数据流，甚至能修改tcp数据包的头部（seq ack）字段，而这些是通过一个状态跟踪引擎来实现的这些设备可以识别出哪些是单独的http请求（第一次的）这些基于包设计的设备是比后者快的，而且也没有那么复杂，最根本的原因就是它们只需要理解一部分协议</p>
<p>- 基于代理： 全权代理和基于包的设计刚好是相反的，它需要理解整个网络传输的协议栈，同时他们也是协议的发起者和接收者，而一个代理服务器和客户端之间的通信与一个代理服务器和后段服务器之间的通信是不同的（反向代理、正向代理）<br>二者之间的矛盾基于代理的设计比基于包的设计更加智能，但是目前来说基于代理的设计性能更强。当流量激增的时候，基于包管理的性能也会被限制，所以在企业进行选型的时候，二者都可以被考虑</p>
<p>什么是tmos<br>- 模块的集和 每个模块提供一部分功能 比如arp ip tcp各自有各自的模块，每个模块都是自称一体的，这样将可以减少系统的复杂性，类似于搭积木一样，当需要增加对某个协议的支持时，我再去构建这么一个单独的模块<br>- 自主&amp;独立的 tmos具有自己的CPU 内存 和外围设备的接口，当一个基于tmos的设备受到数据包的时候，这些线路的子管理系统是完全在tmos中独立的，linux是不参与这个过程的，也就是说tmos并不与linux操作系统发生耦合，linux只用来管理程序<br>- 实施操作系统 （非抢占式的操作系统） 对于tmos这样高性能、大流量的操作系统来说，抢占式的os会浪费掉cpu的部分性能（高优先级插队），tmos的设计是每个组件执行必要的操作，然后把cpu让出去给下一个组件运行。这样将消除了中断、上下文切换等cpu开销，并且让程序有序运行<br>- 基于软件与硬件 它可以从软件和硬件两方面来解决问题，如果是难度比较高的，可能优先走的就是软件，如果是资源密集的，那么优先丢给硬件执行<br>- 事件驱动 因为tmos是模块化并且实时的，也就意味着它能够在任何时间内切换任务，也能够在短时间内改变性能来满足当前的需求<br>- 状态检测 tmos的内核是基于高速代理的，<br>- 动态数据包筛选 tmos能够筛选数据包，它有一个重要优势就是全权代理隐藏了后端服务的网络对战，f5的iRules允许动态控制应用程序流量，可以重定向，动态过滤，或者阻止流量等等<br>以上：tmos三一个功能强大、适应性强的解决反感，模块化与字包含、实时、事件驱动的操作系统相结合，为tmos提供了前所未有的功能<br>tmos体系中的特殊模块<br>tcp express 基于包管理的设计无法提供这个功能，tcp express包括了 延迟和选择性确认、显示拥塞统治、快重传，拥塞避免等等算法，tmos基本上把tcp能优化的地方全部进行了优化，这才能实现显著的加速</p>
<p>tmm（多线程进程）:流量管理微内核处理big-ip系统上的所有负载均衡流量，在tmos中作为额u一个实时用户进程运行，cpu和内存资源在big-ip配置中明确配置</p>
<p>影响tmm使用cpu资源的因素</p>
<p>每个处理器的内核</p>
<p>每个核心的超线程数</p>
<p>big-ip版本</p>
<p> big-ip系统许可的模块</p>
<p>单cpu </p>
<p>单核的cpu使用率<br>在big-ip 11.5.0之前，每个cpu内核被分配一个单独的tmm实例，每个内核处理数据平面任务（tmm特定）和控制平面任务（非tmm特定） 。从big-ip11.5.0开始，数据平面任务和控制平面任务都采用英特尔超线程技术在CPU的系统上使用单独的逻辑内核，偶数编号给TMM，奇数编号给其他进程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/Map%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Map详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:30 / 修改时间：22:15:37" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:30+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Map详解"><a href="#Map详解" class="headerlink" title="Map详解"></a>Map详解</h1><h3 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h3><p>基本上每种计算机语言里面都会内置一个map类型，map是一个由一组key,value组成的数据类型，并且同一个key只会出现一次。同时map支持增删改查四种操作，map的主要实现方式有两种，分别是哈希查找表(hash table)和搜索树(search tree)</p>
<p>哈希表：使用一个哈希函数将key分配到不同的bucket(桶，可以理解成数组中的索引)，开销主要是在哈希函数的计算和数组的常数访问时间，很多场景下，我们可以简单的把哈希表的时间复杂度看成O(1)。哈希表通常还会有一个碰撞的问题，所谓的哈希碰撞就是多个key被哈希函数分配到了同一个bucket。一般有两种解决方法：链表法和开放地址法。链表法是将一个bucket实现程一个链表，落在同一个bucket中的key会插入这个链表。而开发地址法则是在发生碰撞之后，通过一定的规律，在空着的bucket里面挑选，用来放置新的key </p>
<p>搜索树：一般使用自平衡二叉树，比如AVL树和红黑树</p>
<p>二者的区别是，自平衡搜索树的时间复杂度最低为O(logN)，而哈希表的最差情况是O(N)，哈希表平均查找效率是O(1)。 还有一个区别是，遍历自平衡搜索树，返回的key是有序的，而哈希表则是乱序的</p>
<h3 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h3><p>Go中的Map使用的是哈希表，并且使用链表的方式解决哈希冲突</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	<span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line">	<span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B就是buckets数组的长度对数，也就是buckets数组长度为2^B，buckets里面存放着key-value对，buckets也是一个指针，类似于slice中指向数组的指针。</p>
<p>buckets指向的是下面这个东西</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后就变成了</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其中bmap就是我们所说的哈希桶，每个桶里面最多装下8个key-value对，这些key之所以会落入同一个桶中，是因为他们经过哈希计算之后，得到的结果是一类的(哈希结果得到的后八位相同)，之后会根据key计算出来的hash值的高8位来决定key到底落入桶内的那个位置(哪个槽)</p>
<p><img src="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/1.png"></p>
<p>其中每个bmap的key1…key8是存放在一起的，value1….value8是存放在一起的，这样的目的是为了节省因为内存对齐造成的空间浪费。</p>
<p>每个bucket设计成最多只能存放8个key-value对，如果有第九个key-value落入当前的bucket，则需要再构建一个bucket,然后通过overflow指针连接起来。</p>
<p><strong>创建map</strong></p>
<p>底层调用的是makemap函数，主要做的工作就是初始化hamp结构体的各种字段，比如计算B的大小，设置哈西种子hash0等等</p>
<p><strong>哈希函数</strong></p>
<p>map的一个关键点在于哈希函数的选择，在程序启动时会检测cpu是否支持aes，如果支持则使用aes hash，否则使用memhash。hash函数有加密型和非加密型，加密型的一般用于加密数据、数字摘要等，典型代表就是md5 sha1 sha256 aes256这种，非加密型的就是查找，而map就是使用的查找hash函数</p>
<p><strong>key定位过程</strong></p>
<p>key经过哈希计算后得到哈希值，共64bit，计算它落到那个桶的时候，会用到最后B个bit位，最后B个bit位的值，就是落入桶的序号、当两个不同的key落在同一个桶中，也就是发生了哈希冲突，解决手段是链表法，从前往后找到第一个空位，这样，在查找某个key的时候先找到对应的桶，然后再去遍历bucket里的key。</p>
<p>在槽内的查找过程：使用高八位的bit值，高八位的值就是槽位，如果在bucket中没找到，并且overflow不为空，还要继续去overflow bucket中查找，直到找到或是所有的key槽位都遍历完</p>
<p>综上，这是一个双重循环的过程，外层循环查找所有bucket和overflow bucket，内层循环遍历单个bucket的所有槽位</p>
<p><strong>get</strong></p>
<p>Go中读取map有两种语法，带comma和不带comma，当要查询的key不在map里，带comma的用法会返回一个bool型变量提示key是否在map中，而不带comma的语法则会返回一个对应类型的零值</p>
<p><strong>遍历</strong></p>
<p>本来map的遍历过程比较简单：遍历所有的bucket以及它后面挂的overflow bucket(第一层遍历)，然后挨个遍历bucket中的所有cell(槽)，每个bucket包含8个cell，从有key的cell中取出key value </p>
<p>但是现实并没有这么简单，因为扩容并不是一个原子的操作，每次最多只搬运两个bucket，所以如果触发了扩容操作，那么很长时间内，map状态都是处于一种中间态，有些bucket已经搬迁到新家，有些bucket还呆在老地方</p>
<p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老bucket的过程</p>
<p>具体是遍历老的bucket，然后再遍历老的bucket裂变到新的bucket里的元素</p>
<p><strong>赋值</strong></p>
<p>调用的是mapassign函数，语法和插入key的过程一样，只不过前者的key在map在不存在，后者存在</p>
<p>具体过程</p>
<p>1.检查map标志位flgas,如果为1则说明其他协程在执行写操作，导致程序panic</p>
<p>2.如果map正在扩容，那么当key定位到了某个bucket后，需要确保这个bucket对应的老bucket完成了迁移，即老bucket的key都要迁移到新的bucket中之后，才能在新的bucket中进行插入或者更新的操作</p>
<p><strong>删除</strong></p>
<p>调用的是底层的mapdelete函数</p>
<p>1.检查标志位flags，如果发现标志位为1，说明其他协程在执行写操作，直接panic </p>
<p>2.计算key的哈希，找到落入的bucket，如果正在扩容中，直接完成一次扩容</p>
<p>3.同样是两层循环，找到key的具体位置，然后删掉</p>
<p><strong>扩容</strong></p>
<p>使用哈希表的目的是快速找到目标key，随着map中添加的key越来越多,key发生碰撞的概率也越来越大，当bucket中的8个cell倍塞满的时候，效率就是最低的，最理想的情况是一个bucket只装一个key，这样就能达到o1的效率，当然这样空间消耗太多了</p>
<p>触发扩容的条件</p>
<p>1.装载因子超过阈值6.5</p>
<p>2.overflow的bucket数量过多，当B&lt;15如果overflow的数量大于2^B,当B&gt;&#x3D;15，如果overflow的数量大于2^15(装载因子比较小，map的插入和查找效率也很低，但是bucket的数量很多)</p>
<p>两种扩容方式</p>
<p>1.元素太多，bucket太少，将B+1，让bucket的数量翻倍</p>
<p>2.元素不多，但overflow bucket很多，说明很多bucket都没满，开辟一个新的bucket空间，将老bucket中的元素移动到移动到新的bucket，是的一个bucket中的key排列更加紧密</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Slice详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-03 22:10:39 / 修改时间：23:01:35" itemprop="dateCreated datePublished" datetime="2022-11-03T22:10:39+08:00">2022-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Slice详解"><a href="#Slice详解" class="headerlink" title="Slice详解"></a>Slice详解</h1><h3 id="slice和数组的区别"><a href="#slice和数组的区别" class="headerlink" title="slice和数组的区别"></a>slice和数组的区别</h3><p>众所周知，go是一门强类型的语言，什么是强类型呢？就是对类型要求非常严格(在运算时)，所以go中的float不能和int进行运算，甚至int和int64也不能进行运算。</p>
<p>数组是指长度固定的数据集合，比如 [3] int 指的就是长度为3的int类型集合，它和[4] int是两个完全不同的类型，所以不能作比较，比较也是一种运算。</p>
<p>而slice则是动态数组，长度不固定，可以动态扩容，slice的类型和长度没有关系，所以不同的slice可以进行比较(但这个操作通常没有意义)</p>
<h3 id="slice本质"><a href="#slice本质" class="headerlink" title="slice本质"></a>slice本质</h3><p>slice其实就是一个结构体，里面有着对数组的封装，还有len和cap两个字段来描述数组的长度和容量</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 元素指针 指向的其实是一个底层的数组</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要判断slice是否为空，要使用</p>
<p><code>len(slice)==0</code></p>
<p>而不能使用</p>
<p><code>slice==nil</code></p>
<p>因为slice&#x3D;0判断的是数组内是否有元素，如果没有元素则为空，而slice&#x3D;&#x3D;nil判断的是一整个结构体是否为Nil 如果我们用var 的方式声明，不会给slice分配内存，那么slice确实&#x3D;nil。但如果我们使用make的方式进行声明，那么就会给slice分配内存，所以slice就!&#x3D;nil了</p>
<p>同理的 要判断两个slice是否相同，不能简单的通过slice1&#x3D;&#x3D;slice2进行判断，而是要循环切片进行判断</p>
<h3 id="slice传参"><a href="#slice传参" class="headerlink" title="slice传参"></a>slice传参</h3><p>在我们把slice作为参数传递出去的时候，传的是<strong>值</strong>，这也就是为什么我们在被调函数中对数组进行append，在主调函数中看不到这个变化。但是如果直接通过下标的方式对slice进行修改，那么是可以反映到主调函数中的(因为下标修改是直接对底层的数组进行修改)</p>
<p>准确的来说，go中所有的参数传递，都是值传递，并没有引用传递，那有的同学可能就疑惑了，我传递map的话不是在被调函数中的改变可以反映到主调函数中吗？</p>
<p>因为进行函数调用的时候，slice类型会调用runtime.makeslice函数，这个函数的返回值类型是值，而map类型会调用runtime.makemap函数，这个函数的返回值类型是一个指针</p>
<h3 id="slice的扩容过程"><a href="#slice的扩容过程" class="headerlink" title="slice的扩容过程"></a>slice的扩容过程</h3><p>网上流传的版本是:当slice容量小于1024的时候，每次扩容翻倍，在1024长度之后，每次扩容1.25倍，而在1.18版本之后变为了，当容量小于256的时候，扩容为两倍，超过256，newcap&#x3D;oldcap+(oldcap+3*256) &#x2F;4</p>
<p>这个说法不对，或者说只对了一半</p>
<p>go 1.9.5源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//内存对齐 </span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>go 1.18源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.18 src/runtime/slice.go:178</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//内存对齐</span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只看前半部分，那么网上的各种文章说的是对的，现实是，后半部分还对newcap做了一个内存对齐，这个和内存分配策略有关，进行内存对齐之后，新slice的容量&gt;&#x3D;未进行内存对齐之前的cap</p>
<h3 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h3><p>首先new和make都是Go内置的用来分配内存的函数，区别是make用来给slice map channel等引用类型分配内存，返回值是一个值类型，而new用来给数组、结构体值类型来分配内存，后者返回值是一个指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Go-web%E4%B8%8EContent-Type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Go-web%E4%B8%8EContent-Type/" class="post-title-link" itemprop="url">Go web与Content-Type</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-03 22:07:05 / 修改时间：23:01:41" itemprop="dateCreated datePublished" datetime="2022-11-03T22:07:05+08:00">2022-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-web与Content-Type"><a href="#Go-web与Content-Type" class="headerlink" title="Go web与Content-Type"></a>Go web与Content-Type</h1><p>首先要对http的工作方式有一定的了解，这里默认大家都会。这里只是随手写了点东西记录一下Content-Type的类型和内容。</p>
<h3 id="http请求与响应"><a href="#http请求与响应" class="headerlink" title="http请求与响应"></a>http请求与响应</h3><p>http request的具体组成</p>
<ul>
<li>请求行：请求类型+url+协议版本</li>
<li>请求头:Host(表明请求目的地 主机域名) User-Agent(客户端的信息 由浏览器定义) Content-Type Content-Length等等</li>
<li>空行</li>
<li>请求体：实体数据</li>
</ul>
<p>http response的具体组成</p>
<ul>
<li>状态行：由协议版本号、状态码和状态消息组成</li>
<li>响应头： 客户端可以使用的一些信息 比如Date Content-Type Connection(是否为长链接) 等等</li>
<li>空行</li>
<li>响应体：实体数据</li>
</ul>
<h3 id="net-x2F-http"><a href="#net-x2F-http" class="headerlink" title="net&#x2F;http"></a>net&#x2F;http</h3><p>这个库里面主要是与http相关的一些API，可以分为客户端和服务端两个部分</p>
<ul>
<li>服务端相关：server serverMux Handler&#x2F;HandlerFunc</li>
<li>客户端相关: client response header request cookie</li>
</ul>
<p>具体过程如下</p>
<p><img src="/2022/11/03/Go-web%E4%B8%8EContent-Type/1.png"></p>
<p>首先服务端创建Listen Socket监听指定的端口，等待客户端请求到来，之后Listen socket接受客户端的请求，得到Client Socket，通过这个socket和客户端进行通信；每次处理客户端的请求时，首先从Client Socket读取HTTP协议头，如果是POST可能还要读取数据，然后交给相应的Handler处理，处理完毕之后准备好客户端需要的数据，通过Client Socket写回给客户端。</p>
<p>ListenAndServe函数的具体流程</p>
<ul>
<li>监听某个端口  如果有新连接进来 创建一个goroutine处理新的连接 </li>
<li>在goroutine中 将请求和响应分别封装为http.Request和http.ResponseWriter对象，将这两个对象作为参数传递给server.Handler的serveHTTP,这个server.handler就是listenandserve函数的参数(http.servemux)</li>
<li>查找http.Request对象的url(在servemux中的map中进行) 然后执行</li>
<li>监听之后内部有一个for循环不断接受请求，每个请求创建一个conn,最后创建一个goroutine</li>
</ul>
<h3 id="Content-Type初识"><a href="#Content-Type初识" class="headerlink" title="Content-Type初识"></a>Content-Type初识</h3><p>Content-Type 是http的首部字段，用于说明请求或者返回的消息body是以何种方式进行编码，在request header和response header里都存在，网页通过这个类型定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。</p>
<p>常见的媒体格式类型如下</p>
<ul>
<li>text&#x2F;html html格式</li>
<li>text&#x2F;plain 纯文本格式</li>
<li>text&#x2F;xml xml格式</li>
<li>text&#x2F;gif gif图片格式</li>
<li>text&#x2F;jpeg jpg图片格式</li>
<li>text&#x2F;png png图片格式</li>
</ul>
<p>以application开头的媒体格式类型</p>
<ul>
<li>application&#x2F;xhtml+xml XHTML格式</li>
<li>application&#x2F;xml XML格式</li>
<li>application&#x2F;atom+xml Atom XML聚合格式</li>
<li>application&#x2F;json JSON数据格式</li>
<li>application&#x2F;pdf pdf格式</li>
<li>application&#x2F;msword Word文档格式</li>
<li>application&#x2F;octet-stream 二进制数据流格式</li>
<li>application&#x2F;x-www-form-unlencoded 表单默认的提交数据格式(被编码为key&#x2F;value的格式)</li>
</ul>
<p>另一种常见的媒体格式的上传文件之时使用的</p>
<ul>
<li>multipart&#x2F;form-data 需要在表单中进行文件上传时，就需要使用到这个格式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Go编译相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-31 22:52:56" itemprop="dateCreated datePublished" datetime="2022-10-31T22:52:56+08:00">2022-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-15 22:14:25" itemprop="dateModified" datetime="2022-11-15T22:14:25+08:00">2022-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go编译相关"><a href="#Go编译相关" class="headerlink" title="Go编译相关"></a>Go编译相关</h1><h2 id="Go的一些环境变量"><a href="#Go的一些环境变量" class="headerlink" title="Go的一些环境变量"></a>Go的一些环境变量</h2><p>在我们安装Go语言的时候，都要设置一些环境变量，最重要的就是GOROOT和GOPATH，那么他们分别代表的是什么呢？</p>
<p>下图是所有的Go环境变量</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/1.jpg"></p>
<p>随便挑几个</p>
<ul>
<li><p>GOROOT是GO的安装路径，有一些关于操作系统方面的支持和编译器、链接器等等</p>
</li>
<li><p>GOPATH是一个工作空间，目的是提供一个寻找.go源码的路径，可以设置多个目录，GO官方要求需要包含三个文件夹，src存放源文件，pkg存放编译后的库文件，后缀为.a，bin则存放可执行文件。</p>
</li>
<li><p>GOOS是Go当前所在的操作系统</p>
</li>
<li><p>GOARCH是Go所在的计算机架构</p>
</li>
<li><p>GO111MODULE表示是否开启Gomod</p>
</li>
<li><p>GOPROXY表示代理，direct表示是否直接走代理</p>
</li>
<li><p>CGO表示是否开启CGO</p>
</li>
</ul>
<p>在交叉编译的时候就要使用到GOOS和GOARCH，交叉编译指的是：编译的平台和代码最终运行的平台不一样，我们都知道，不同机器的机器码是不一样的，不是说一个二进制文件，在所有机器上都可以执行的。</p>
<p>比如这么一个场景：你的开发环境是Win10，但是服务器是Centos7，这时候你想要让代码在服务器上运行，可以有这么两种解决方案</p>
<ol>
<li>把整个工程文件传到服务器上，在服务器上进行编译和运行，但这显然不方便，因为你还要在服务器上安装Go</li>
<li>在开发环境进行编译，编译出的二进制文件能够在服务器上运行</li>
</ol>
<p>显然第二种解决方案更加简单</p>
<p>那么该怎么做呢？</p>
<ol>
<li>修改GOOS和GOARCH为对应的平台与计算机架构，在Go1.13之后修改环境变量要用到go env -w  </li>
<li>GOOS&#x3D;linux GOARCH&#x3D;amd64 go build &#x2F;&#x2F;分别指定对应的平台和机器的位数</li>
</ol>
<p>当然，在实际开发中一般环境都是和服务器相同的(操作系统和机器位数)，这样就不会有类似的问题。</p>
<h2 id="Go代码编译链接过程"><a href="#Go代码编译链接过程" class="headerlink" title="Go代码编译链接过程"></a>Go代码编译链接过程</h2><p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/2.png"></p>
<p>从上图可以看出来，一份Go代码需要先经过编译器的编译称为汇编程序，再通过汇编器成为二进制可执行程序，再经过链接器的链接，最后才成为了一份二进制可执行文件。</p>
<p>具体过程：go build其实就是编译和链接的过程，编译是指对源文件进行词法分析、语法分析、语义分析、优化，最后生成汇编代码文件，以.s作为文件的后缀。之后，汇编器会将汇编代码转变成机器可以执行的指令，每一条汇编语句都与一条机器指令对应。编译是一个很智能的过程，里面还包含了优化的部分，而汇编则是比较机械的部分，将汇编语句转换成机器指令。</p>
<p>编译过程</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/3.png"></p>
<p>主要过程就是：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化</p>
<p>词法分析（扫描）：将源代码字符序列转换为标记(token)序列的过程 进行这个步骤的程序叫做词法分析器，也叫作扫描器(scanner)，一般以函数的方式存在，.go文件被输入到scanner，它使用一种类似于有限状态机的算法，将源代码的字符系列分割成一系列的token。token分为这几种：关键字、标识符、字面量、特殊符号等等</p>
<p>Go语言scanner的具体逻辑就是通过next函数，获取下一个未被解析的字符，并且跳过之后的空格，回车，换行，tab这些字符，进入一个大的switch-case语句，匹配不同的情况。</p>
<p>语法分析：上一步生成的token序列，需要经过进一步的处理，生成一颗以表达式为结点的语法树（把符号组成一个句子）</p>
<p>语义分析：检查常量、类型、函数声明等等，可以把这一步看成静态检查，如果有很明显的语法错误，就会报错。</p>
<p>中间代码生成：编译过程可以分为前端和后端，前端生成和平台无关的中间代码，而后端会针对不同的平台，生成不同的机器码，前面的词法分析、语法分析、语义分析都属于编译器前端，后面的阶段属于编译器后端。</p>
<p>目标代码生成与优化：不同机器的机器字长、寄存器都不一样，意味着在不同机器上跑的机器码是不一样的，最后一步的目的就是要生成能在不同CPU架构上运行的代码。目标代码优化器会对一些指令进行优化，提升程序的效率。</p>
<p>链接：将编译器生成的一个个目标文件链接成可执行文件，最后得到的文件是分成各种段的。</p>
<p>其实关于编译链接这部分的内容还有很多需要学习的，这里只是简单的说明了一下，具体可以参考《程序员自我修养》这本书</p>
<h2 id="Go编译相关命令"><a href="#Go编译相关命令" class="headerlink" title="Go编译相关命令"></a>Go编译相关命令</h2><p>Go语言的源码分为三类：命令源码、库源码、测试源码</p>
<p>命令源码：Go程序的入口，包含func main() 函数，且第一行用package main声明属于main包</p>
<p>库源码：主要是各种函数、各种接口，例如工具类的函数</p>
<p>测试源码：以_test.go为后缀，用于测试功能、性能等</p>
<p>与编译相关的Go命令主要有三个</p>
<ul>
<li>go build</li>
<li>go install</li>
<li>go run</li>
</ul>
<p>go build的一些参数</p>
<ul>
<li>-a 强制重新编译所有涉及到的包</li>
<li>-n 打印命令执行过程 不真正执行</li>
<li>-p n 打印命令执行的并行数 n默认为cpu核数</li>
<li>-race 检测并报告程序中的数据竞争问题</li>
<li>-v 打印命令执行中涉及到的代码包名称</li>
<li>-x 打印命令过程中涉及到的命令 并执行</li>
<li>-work 打印编译过程中的临时文件夹，编译完成后会被删除</li>
</ul>
<p>go build：编译过程会忽略掉测试源码 执行过程是递归寻找main.go所依赖的包，以及依赖的依赖，直至最低层的包，如果有循环依赖，则直接退出</p>
<p>go install ：编译并安装指定的代码包，相比于Go build，它多了一个“安装编译后的结果文件到指定目录”的步骤</p>
<p>go run ：先编译，再链接，再执行</p>
<h2 id="Go程序启动过程"><a href="#Go程序启动过程" class="headerlink" title="Go程序启动过程"></a>Go程序启动过程</h2><p>1.检查运行平台的CPU 设置好程序运行需要相关标志</p>
<p>2.TLS的初始化</p>
<p>3.runtime包进行变量和调度器的设置</p>
<p>4.创建新的goroutine绑定用户的main方法</p>
<p>5.开始进行goroutine的调度</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/4.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Go-defer%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/31/Go-defer%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Go defer详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-31 22:52:12 / 修改时间：22:56:57" itemprop="dateCreated datePublished" datetime="2022-10-31T22:52:12+08:00">2022-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-defer详解"><a href="#Go-defer详解" class="headerlink" title="Go defer详解"></a>Go defer详解</h1><h3 id="什么是defer"><a href="#什么是defer" class="headerlink" title="什么是defer"></a>什么是defer</h3><p>在进行编程的时候，经常需要在代码中申请一些资源，比如数据库连接，文件句柄等等，这些资源需要在用完之后进行释放，否则会造成内存泄漏（内存一直被占用而不被释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果），而Go就提供了一个defer关键字，可以实现延迟调用。defer可以让函数或者语句在当前函数执行完毕后执行（包括程序正常退出和panic导致的异常结束）</p>
<p>以下代码有什么问题？</p>
<p><code>r.mu.Lock()</code></p>
<p><code>rand.Intn(param)</code></p>
<p><code>r.mu.Unlock()</code></p>
<p>看起来这段代码是没有什么问题的，但这是建立在程序正常运行的基础上，如果rand.Intn出现了异常而造成了panic，就会出现r一直占用着锁而不释放的问题，所以即使是简单的释放资源的代码，使用defer也是很有必要的。</p>
<h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><p>defer的语句并不会马上执行，而是会进入一个栈，所以执行的顺序也会和栈一样，即先进后出，也就是说最先被定义的defer语句最后执行，这个原因是后面定义的函数可能对前面的资源有依赖，所以要先执行；否则如果前面先执行了，对某些资源进行释放，后面的函数就会出错。</p>
<p>在defer函数定义时，对外部变量的引用有两种方式，函数参数和闭包引用，前者在defer定义时就把值（广义的值，如果传的是引用类型，那么和定义的时候可能不一样）传给defer，并被存起来，而后者则会在defer真正调用的时候根据上下文确定值。</p>
<p>如果是闭包的话，则会和定义的时候不一样，看下面这个栗子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var t [3]struct&#123;&#125;</span><br><span class="line">   for i := range t &#123;</span><br><span class="line">      defer func() &#123;</span><br><span class="line">         fmt.Println(i) //defer 后面接的是闭包 在for 循环结束后的i的值为2</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   // 2</span><br><span class="line">   // 2</span><br><span class="line">   // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：在Go使用close()关闭某些资源的时候，最好提前判断调用主体是否为空，否则很可能会解引用一个空指针，从而造成panic的问题</p>
<h3 id="return与defer"><a href="#return与defer" class="headerlink" title="return与defer"></a>return与defer</h3><p>return并不是一条原子指令，return的执行顺序是这样的</p>
<p>1.返回值&#x3D;xxx</p>
<p>2.调用defer函数</p>
<p>3.ret指令</p>
<p>下面是两道defer经典题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func f1() int &#123;  //返回值没有取名</span><br><span class="line">   x := 5</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   return x       //1.返回值赋值 2.defer 3.执行RET返回  //开辟了一份空间 return语句先将5赋值给x defer修改了x的值 但是RET命令执行的对象还是那个‘5’</span><br><span class="line">&#125;</span><br><span class="line">func f2() (x int) &#123;  //返回值有名字</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++ //闭包</span><br><span class="line">   &#125;()</span><br><span class="line">   return 5  //修改的是x的值</span><br><span class="line">&#125;</span><br><span class="line">func f3() (y int) &#123;</span><br><span class="line">   x := 5</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   return x   //y = x = 5  defer修改的是 x 真正返回的y还是5</span><br><span class="line">&#125;</span><br><span class="line">func f4() (x int) &#123;</span><br><span class="line">   defer func(x int) &#123;</span><br><span class="line">      x++   //改的是函数值的副本  //如果这里是 defer func(x *int) &#123; x ++ &#125;(x) </span><br><span class="line">   &#125;(x)     //那么结果就会变成6</span><br><span class="line">   return 5  </span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(f1())  //5</span><br><span class="line">   fmt.Println(f2())  //6</span><br><span class="line">   fmt.Println(f3())  //5</span><br><span class="line">   fmt.Println(f4())  //5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   x := 1</span><br><span class="line">   y := 2</span><br><span class="line">   defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">   x = 10</span><br><span class="line">   defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">   y = 20</span><br><span class="line">    //1.调用calc中的calc(&quot;A&quot;,x,y)  输出:&quot;A&quot;,1,2,3 因为函数调用时会确定每个参数的值</span><br><span class="line">    //2.defer calc(&quot;AA&quot;,x,3)</span><br><span class="line">    //3.调用第二个calc中的calc(&quot;B&quot;,x,y)  此时x y是20 输出:&quot;B&quot;,10,2,12</span><br><span class="line">    //4.defer calc(&quot;BB&quot;,x,12)</span><br><span class="line">    //5.先进后出 调用第二个calc 输出:&quot;BB&quot;,10,12,22</span><br><span class="line">    //6.调用第二个calc 输出:&quot;AA&quot; 1,3,4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包&#x3D;函数+引用环境 不推荐在生产环境中使用，就算你自己对闭包的使用很熟练，但是代码写出来是给人看的，不能苛求你的同事、测试对这部分也很熟悉，而且闭包很容易出现错误。</p>
<p>Go中的所有匿名函数都是闭包程序</p>
<h3 id="defer配合recover使用"><a href="#defer配合recover使用" class="headerlink" title="defer配合recover使用"></a>defer配合recover使用</h3><p>执行初始化的时候出问题，最好直接panic掉，避免上线之后出现更大的问题，有些时候，需要从异常中恢复，比如服务器的严重问题产生了panic，这个时候需要在程序崩溃之前做一些扫尾工作，比如关闭客户端的连接。并且一个panic不应该影响整个服务器的运行，这时候就需要defer 和 recovery进行配合 </p>
<p>defer配合recovery使用:recovery必须在defer的函数中 才是标准格式 </p>
<p>比如这种</p>
<p><code>func main() &#123;</code><br>    <code>defer f()</code><br>    <code>panic(404)</code><br><code>&#125;</code></p>
<p><code>func f() &#123;</code><br>    <code>if err := recover(); err != nil &#123;</code><br>        <code>fmt.Println(&quot;recover&quot;)</code><br>        <code>return</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p>或者采用匿名函数</p>
<p><code>func main() &#123;     defer func() &#123;         if err := recover(); err != nil &#123;             fmt.Println(&quot;recover&quot;)             return         &#125;     &#125;()     panic(404) &#125;</code></p>
<p>但是注意，一定要在<strong>函数</strong>里，像这样是不行的</p>
<p><code>func main() &#123;     defer recover()     panic(404) &#125;//还是会panic</code></p>
<h3 id="defer链是如何被执行的"><a href="#defer链是如何被执行的" class="headerlink" title="defer链是如何被执行的"></a>defer链是如何被执行的</h3><p>前面我们说到过，一个函数中的defer语句是按照栈的顺序执行的，每一条defer语句都会创建一个_defer结构体，这些结构体以链表的形式挂载在G下（Goroutine)。</p>
<p>defer首先会调用deferporc函数，new一个_defer结构体，挂到G上，当然，调用new之前会从当前G绑定的P中的defer pool中取，如果没有的话则会去全局的defer pool中取，是在没有就新建一个，这是Go runtime的常规操作，也就是设置多级缓存，提高运行效率。 </p>
<p>之后按照顺序，处理一个个_defer结构体，即完成了defer链的执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/RSA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/RSA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">RSA详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-22 11:07:45 / 修改时间：11:11:34" itemprop="dateCreated datePublished" datetime="2022-10-22T11:07:45+08:00">2022-10-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RSA详解"><a href="#RSA详解" class="headerlink" title="RSA详解"></a>RSA详解</h1><h2 id="1-RSA思想"><a href="#1-RSA思想" class="headerlink" title="1.RSA思想"></a>1.RSA思想</h2><p>  RSA公开密钥密码体制是一种使用不同的加密密钥和解密密钥，由“已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p>
<p>  在这种体制中，加密秘钥（公钥）PK是公开信息，而解密密钥（私钥）SK是需要保密的，加密算法E和解密算法D也都是公开的，这样的话虽然SK是由PK决定的，但是不能通过PK计算出SK。</p>
<p>​	基于这种思想，在1978年出现了著名的RSA算法。</p>
<ol>
<li>通常是先生成一对RSA密钥</li>
<li>其中的一个是私钥，用户保存，另一个是公钥，可对外公开，甚至可以在网络服务器中注册</li>
<li>为了提高保密强度，密钥至少为500位，一般推荐1024位</li>
<li>为了减少计算量，传送信息的时候通常采用传统加密与公开密钥加密结合的方式</li>
</ol>
<p>算法原理：根据数论的理论，找两个大素数比较简单，对他们的乘积进行因式分解却很困难，因此可以将乘积公开作为加密秘钥</p>
<h2 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2.算法描述"></a>2.算法描述</h2><ol>
<li>任意选两个不同的大素数p和q计算乘积n&#x3D;pq，欧拉函数n&#x3D;p-1 * q-1 </li>
<li>任意选一个大整数e，满足 gcd (e,欧拉n)&#x3D;1，整数e用作加密钥</li>
<li>确定的解密要d 满足(de) mod 欧拉n &#x3D;1 很容易计算出d </li>
<li>公开n和e 保存d</li>
<li>将明文m(m&lt;n)加密成c 加密算法为 c&#x3D;m^e mod n </li>
<li>将密文c解密为明文m  解密算法为 m&#x3D;c^d mod n</li>
</ol>
<p>通俗易懂的解释：</p>
<p>1.第一步 随机选择两个不相同的质数 p 和 q  比如61和53，在实际应用中，这两个质数越大，就越难破解</p>
<p>2.第二步 计算p和q的乘积n  上面的栗子 n&#x3D;61*53&#x3D;3233</p>
<p>这个n就是密钥，写成二进制位110010100001，一共12位，那么这个密钥长度就是12位，在实际应用中,RSA密钥长度要到1024位，才具有足够的保密性</p>
<p>3.第三步，计算n的φ(n)</p>
<p>欧拉n&#x3D;p-1* q-1 上面的栗子为3120</p>
<p>4.第四步 随机选择一个整数e 条件为1&lt;e&lt;φ(n)，且e与欧拉n互质，实际应用中常用65537，我们这边随便选个17</p>
<p>5.计算e对于φ(n)的模反元素d </p>
<p>所谓模反元素就是指有一个整数d 可以让ed 被 φ(n) 除的余数为1</p>
<p>可以通过扩展欧几里得算法求解 </p>
<p>6.将n和e封装成公钥，n和d封装成私钥</p>
<p>可靠性：能不能在已知n和e的情况下，推出d，也就是能不能在已知公钥的情况下，推出私钥？</p>
<p>结论：不行，需要对大整数进行因式分解，这个过程很困难，目前被破解的最长RSA密钥为768位</p>
<p>7.加密过程：</p>
<p>通过公钥(n,e)对m进行加密，m必须为整数，且m必须小于n</p>
<p>加密过程</p>
<p>m ^ e ≡ c (mod n)</p>
<p>8.解密过程</p>
<p>c ^ d ≡ m (mod n)</p>
<h2 id="3-安全性描述"><a href="#3-安全性描述" class="headerlink" title="3.安全性描述"></a>3.安全性描述</h2><ul>
<li>保密强度随着密钥的长度增加而增强，但是密钥越长，加解密的时间也就夜场</li>
<li>RSA安全性依赖于大数分解</li>
<li>因为进行的都是大数计算，使得RSA的速度比DES慢上好几倍甚至好几十倍，因为AES这类算法通常厂商会在硬件方面进行优化，RSA一般只用于少量的数据加密，RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E5%B7%A5%E4%B8%9A%E7%95%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E5%B7%A5%E4%B8%9A%E7%95%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工业界的几种发布模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 11:07:35" itemprop="dateCreated datePublished" datetime="2022-10-22T11:07:35+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 14:46:50" itemprop="dateModified" datetime="2023-02-22T14:46:50+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="工业界的几种发布模式"><a href="#工业界的几种发布模式" class="headerlink" title="工业界的几种发布模式"></a>工业界的几种发布模式</h1><h2 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h2><ul>
<li>蓝绿发布的本质上是通过系统冗余来解决上线风险的问题，通常生产环境中配置两套完全一样的环境，一组是active的生产环境配置（绿色），一组是inactivate的准备环境配置（蓝色），两套系统都是功能完善的，并且正在运行的系统，只是系统版本和对外服务情况不同</li>
<li>最初始的状态下，没有任何系统，也没有蓝绿之分，然后第一套系统开发完成直接上线，只有一个系统，后来业务更新，要用新版本替换线上的旧版本，这时候就有两个系统，正在对外提供服务的是老系统为绿色，新部署的系统为蓝色</li>
</ul>
<p>为什么要有蓝色系统？因为蓝色其实是为了对新版本进行全方位的测试</p>
<ul>
<li>如果测试没出问题，可以通过负载均衡器&#x2F;反向代理&#x2F;路由指向蓝色环境，之后只要检测这个环境是否有故障，如果运行良好， 就可以删除v1.0使用的资源，为下一次蓝绿部署空出可用资源</li>
<li>如果测试有问题，直接修改指向，快速回滚到绿色环境</li>
</ul>
<p>优点：部署过程中，应用始终在线，并且新版本没有修改老版本的任何内容，在部署期间，老版本的转改不收影响，风险很小，并且理论上可以在任何时间回滚到老版本</p>
<p>缺点：需要两套环境，冗余的基础设施。而且对于设计数据表结构变更等不可逆转的升级，不太适合</p>
<h2 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h2><p>金丝雀发布就是灰度发布，这两个东西是同一类策略，策略就是只有一套系统，并且逐渐替换这套系统。</p>
<p>指的是增量发布的一种类型，在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”，测试新版本的性能和表现，以保证整体系统的稳定性。</p>
<p>发布过程</p>
<ul>
<li>从负载均衡列表里下掉</li>
<li>升级金丝雀应用</li>
<li>重新添加到负载均衡列表中</li>
<li>如果测试成功，升级其他的服务器，否则回滚</li>
</ul>
<p>通常会AB测试一起使用</p>
<h2 id="AB测试"><a href="#AB测试" class="headerlink" title="AB测试"></a>AB测试</h2><p>AB测试是效果测试，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分，核心目的是用来测试应用功能表现的方法。比如页面的样式、颜色不一样，最后通过分析各个服务的实际效果，选择效果最好的版本。</p>
<h2 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h2><p>所谓滚动发布一般是取出一个或者多个服务器停止服务，执行更新，并重新投入使用，周而复始，直到集群中的所有实例都更新成新版本，比如每次选出集群中的20%进行升级。比蓝绿部署更节省资源。</p>
<p>缺点：</p>
<ul>
<li>没有一个确定OK的环境</li>
<li>需要回滚的话很麻烦</li>
</ul>
<h2 id="红黑部署"><a href="#红黑部署" class="headerlink" title="红黑部署"></a>红黑部署</h2><p>这是Netfix采用的部署手段，主要基础设施在AWS上，它利用了AWS的特性，在部署新的版本的时候，通过AutoScaling Group 用包含新版本的AMI创建新的服务器，服务始终在线，同时采用不可变部署的方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E5%AE%B9%E9%94%99%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E5%AE%B9%E9%94%99%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E7%81%BE%E5%A4%87/" class="post-title-link" itemprop="url">容错、高可用和灾备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-22 11:07:22 / 修改时间：11:13:19" itemprop="dateCreated datePublished" datetime="2022-10-22T11:07:22+08:00">2022-10-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>429</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容错、高可用和灾备"><a href="#容错、高可用和灾备" class="headerlink" title="容错、高可用和灾备"></a>容错、高可用和灾备</h1><p>容错：指的是在发生故障时，系统仍然能够继续运行，比如飞机的设计就遵从了容错的思想，如果一个引擎坏了，剩下几个引擎，仍然能够飞。容错的目的是：发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失效。</p>
<p>高可用：系统能比正常时间更久地保持一定的运行水平，骑车的备胎就是一个高可用的栗子，如果没有备胎，轮胎坏了，车就开不久，备胎延长了骑车行驶的可用时间。指的是一旦中断能够快速恢复，且中断必须是短暂的。</p>
<p>灾备：发生灾难时恢复业务的能力。如果飞行员是业务的话，飞机就是基础设施，飞行员的弹射装置就是灾备措施，一旦飞机即将坠毁，基础设施就要没了，灾备可以让业务幸存下来。目的：保留系统的核心部分，一个好的灾备方案，就是从失败的基础佘时仲获取企业最宝贵的数据，然后在新的基础设施上恢复它们。</p>
<p>总结可以通过以上的三个方面结合起来，设计一个可靠的系统</p>
<ul>
<li>容错：发生故障的时候，如何让系统继续运行</li>
<li>高可用：系统中断时，如何尽快恢复</li>
<li>灾备：系统毁灭时，如何抢救数据</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/18/CPU%E4%B8%8EGPU%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/18/CPU%E4%B8%8EGPU%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">CPU与GPU的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-18 20:33:36 / 修改时间：20:37:35" itemprop="dateCreated datePublished" datetime="2022-10-18T20:33:36+08:00">2022-10-18</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>912</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CPU和GPU的区别"><a href="#CPU和GPU的区别" class="headerlink" title="CPU和GPU的区别"></a>CPU和GPU的区别</h1><p>CPU：Central Processing Unit 中央处理器，是计算机的大脑，包括运算器、控制器、寄存器、高速缓存以及总线</p>
<p>GPU：Graphics Processing Unit 图形处理器，最初是用在个人电脑、工作站、游戏机和一些移动设备上运行绘图运算工作的微处理器。</p>
<p>CPU和GPU之所以大不相同，主要是由于设计目标的不同，分别针对两种不同的应用场景。</p>
<p>CPUI需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断引入大量的分支跳转和中断的处理，这些使得CPU的内部结构是很复杂的。</p>
<p><img src="/2022/10/18/CPU%E4%B8%8EGPU%E7%9A%84%E5%8C%BA%E5%88%AB/image-20221018203400386.png" alt="image-20221018203400386"></p>
<p>而GPU所面对的数据则是类型高度统一、相互无依赖的大规模数据和不需要被打断的纯净的计算环境，所以GPU的构成相对简单，有数量众多的计算单元和超长的流水线，特别适合处理量大且同一的数据。在设计上采用了众多的计算单元和超长的流水线，但只有简单的控制逻辑并且省去了cache</p>
<p>除了渲染图形的能力，在并行处理方面GPU是很强的，因此在密码破译，大数据处理，金融分析等领域应用广泛（所以为什么会有那么多矿卡知道了吧）。其实GPU并没有专门为图像服务的部件。</p>
<p>为什么GPU擅长处理图像数据呢？这是因为图像上的每一个像素带你都有被处理的需要，而且每个像素点处理的过程和方式都十分类似，很适合机械的GPU进行处理。但是GPU无法单独工作，必须由CPU进行控制调用，CPU可单独作用，处理复杂的逻辑运算和不同的数据类型。</p>
<p>打个比方，GPU的运算速度取决于雇佣了多少小学生，CPU的运算速度取决于请了多么厉害的教授，教授处理复杂任务的能力是碾压小学生的，但是对于没那么复杂的任务，还是顶不住人多。</p>
<p>为什么在人工智能领域GPU十分盛行呢？因为深度学习是模拟人脑神经系统简历的数学网络模型，这个模型的最大特点是需要大数据来训练。所以需要大量的并行的重复计算，在深度学习方面GPU有以下特点</p>
<ul>
<li>提供了多核并行计算的基础结构，且核心数很多（通常有成百上千个核心），可以支撑大量数据的并行计算。</li>
<li>用于更高的访存带宽和速度</li>
<li>具备更高的浮点运算能力</li>
</ul>
<p>独立显卡：把GPU焊死在了显卡的电路板上，上面有一个散热风扇</p>
<p>集成显卡：把GPU和CPU放在一起，共用缓存来工作，并共用风扇。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">93k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:24</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
