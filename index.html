<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/%E2%80%9C%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%8D%E5%AE%9AJSON%E6%95%B0%E6%8D%AE%E2%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E2%80%9C%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%8D%E5%AE%9AJSON%E6%95%B0%E6%8D%AE%E2%80%9D/" class="post-title-link" itemprop="url">“如何解析不定JSON数据”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:41 / 修改时间：15:37:43" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:41+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p>在开发中常常会碰到很多JSON类型的数据进行交互，而其中有很多JSON数据你是不能确定它的字段和结构的，而Go语言是一门静态强类型的语言，在进行JSON解析的时候必须要确定字段的类型，定义出对应的结构体，然后再进行Unmarshal，那这二者之间的冲突我们该如何解决呢？</p>
<h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ul>
<li>json是JavaScript Object Notation（JavaScript对象表示法）</li>
<li>json是轻量级的文本数据交换格式</li>
<li>json独立于语言</li>
<li>json具有自我描述性，更容易理解</li>
<li>json使用js语法来描述数据对象，但是json仍然独立于语言和平台，json解析器和json库支持许多不同的编程语言</li>
</ul>
<p>json是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，之所以json这么流行，是因为json的结构和多级结构体（对象）刚好能对应上，而前后端交互的时候后端通常会返回给前端一个多级的结构体，于是json慢慢开始流行了，且json是跨语言和跨平台的，自身也足够轻量级。<br>json的标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">一个标准的json数据</span><br><span class="line">//每个key对应的是一个value</span><br><span class="line">&#123;</span><br><span class="line">“k1&quot;: 1,</span><br><span class="line">&quot;k2&quot;: 2 //注意结尾的这个不能有逗号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json字符串</span><br><span class="line">&#123;</span><br><span class="line">&quot;k1&quot;: &quot;1&quot;,</span><br><span class="line">&quot;k2&quot;: &quot;2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json数组</span><br><span class="line">&#123;</span><br><span class="line">“k1”: [1,2],</span><br><span class="line">“k2”: [3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json对象</span><br><span class="line">&#123;</span><br><span class="line">“k1”: &#123;“1”: “haihai”&#125;,</span><br><span class="line">“k2”: &#123;“2”:”haihahai”&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json对象数组</span><br><span class="line">&#123;</span><br><span class="line">“k1”: [</span><br><span class="line">&#123;“k11”: “hellohello”&#125;,</span><br><span class="line">&#123;“k12”: “badbad”&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json数组对象</span><br><span class="line">&#123;</span><br><span class="line">“k2”: &#123;</span><br><span class="line">	“hello”: [1,2,3]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所有的JSON数据都是由上述几种JSON数据组合而成</span><br></pre></td></tr></table></figure>

<h2 id="如何在Go中解析不确定的JSON数据"><a href="#如何在Go中解析不确定的JSON数据" class="headerlink" title="如何在Go中解析不确定的JSON数据"></a>如何在Go中解析不确定的JSON数据</h2><h3 id="通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体"><a href="#通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体" class="headerlink" title="通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体"></a>通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 请求其他服务   </span><br><span class="line">jsonStr := xxx</span><br><span class="line"></span><br><span class="line">var data interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := json.Unmarshal([]byte(jsonStr),&amp;data)</span><br><span class="line"></span><br><span class="line">fmt.Println(data)</span><br></pre></td></tr></table></figure>

<p>比如可以先拿一个interface{}类型来接住JSON数据，然后看这个interface{}的值，来确定这个JSON数据哪些字段是string 哪些是object 哪些是int float等等<br>当然这也不是完全适用的，比如下面这种情况，有一个字段如下<br>type : []<br>能看出来type是一个切片类型的值，但是具体的类型你并不知道，可能是[]int 也有可能是[]string []float等等</p>
<h3 id="map-string-interface"><a href="#map-string-interface" class="headerlink" title="map[string] interface{}"></a>map[string] interface{}</h3><p>这个类型是map键值对，值可以是任意类型，因为在go中任意类型都实现了空接口interface{}，而json数据也是key value的键值对，所以map[string] interface{}天然支持解析json类型数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := xxx</span><br><span class="line">var data map[string]interface&#123;&#125; </span><br><span class="line">err := json.Unmarshal([]byte(jsonStr),&amp;data)</span><br><span class="line"></span><br><span class="line">// 你想取的字段</span><br><span class="line">fieldValue := data[&quot;field&quot;]</span><br><span class="line"></span><br><span class="line">// 类型断言</span><br><span class="line">if value,ok := data[&quot;field&quot;].(float64);ok &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if vluae,ok := data[&quot;field&quot;].(int64); ok &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理论上所有的合法的JSON数据都可以被反序列化到map[string]interface&#123;&#125;中</span><br><span class="line">但是实际应用中 可能会出现一些无法被map[string]interface&#123;&#125;解析的JSON数据</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON 数据中包含了多层嵌套的数据结构。在这种情况下，如果没有使用递归或者其他方式对嵌套数据进行处理，可能会导致反序列化失败。</li>
<li>JSON 数据中包含了数组类型，但是数组元素类型不一致或者无法转换成相应的类型。在这种情况下，可能需要手动处理数组元素或者使用其他数据类型来保存数组数据。</li>
<li>JSON 数据中包含了自定义数据类型或者复杂的数据结构，无法使用 map[string]interface{} 类型来反序列化。在这种情况下，需要定义相应的结构体或者使用其他适合的数据类型来反序列化。</li>
</ul>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>除了encoding&#x2F;json之外，还有很多第三方库可以用来解析不确定的JSON数据，例如gjson和jsonparser，这些库通常提供了更加灵活和高效的JSON解析方式，可以根据具体的需求选择合适的库来使用</p>
<h2 id="json-RawMessage与json-Number"><a href="#json-RawMessage与json-Number" class="headerlink" title="json.RawMessage与json.Number"></a>json.RawMessage与json.Number</h2><ul>
<li>json.RawMessage 是一个非常高效的数据类型，因为她不需要进行任何解析和类型转换，直接保存了未经处理的原始JSON数据，在反序列化的时候只需要将<code>json.RawMessage</code>转化为对应的数据类型即可，无需重新解析JSON数据</li>
<li>json.Number 表示JSON中的数字类型，可以用来保存任意精度的数字。这个数字可以特别大，可能会无法用Go中的整数或者浮点数来表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    jsonData := []byte(`&#123;</span><br><span class="line">        &quot;id&quot;: 12345,</span><br><span class="line">        &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">        &quot;age&quot;: 30,</span><br><span class="line">        &quot;score&quot;: 95.5,</span><br><span class="line">        &quot;is_student&quot;: true,</span><br><span class="line">        &quot;tags&quot;: [&quot;tag1&quot;, &quot;tag2&quot;, &quot;tag3&quot;],</span><br><span class="line">        &quot;extra&quot;: &#123;</span><br><span class="line">            &quot;field1&quot;: &quot;value1&quot;,</span><br><span class="line">            &quot;field2&quot;: 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;`)</span><br><span class="line"></span><br><span class="line">    var m map[string]json.RawMessage</span><br><span class="line">    err := json.Unmarshal(jsonData, &amp;m)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var id int</span><br><span class="line">    err = json.Unmarshal(m[&quot;id&quot;], &amp;id)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;id: %d\n&quot;, id)</span><br><span class="line"></span><br><span class="line">    var name string</span><br><span class="line">    err = json.Unmarshal(m[&quot;name&quot;], &amp;name)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;name: %s\n&quot;, name)</span><br><span class="line"></span><br><span class="line">    var age int</span><br><span class="line">    err = json.Unmarshal(m[&quot;age&quot;], &amp;age)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;age: %d\n&quot;, age)</span><br><span class="line"></span><br><span class="line">    var score float64</span><br><span class="line">    err = json.Unmarshal(m[&quot;score&quot;], &amp;score)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;score: %f\n&quot;, score)</span><br><span class="line"></span><br><span class="line">    var isStudent bool</span><br><span class="line">    err = json.Unmarshal(m[&quot;is_student&quot;], &amp;isStudent)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;is_student: %v\n&quot;, isStudent)</span><br><span class="line"></span><br><span class="line">    var tags []string</span><br><span class="line">    err = json.Unmarshal(m[&quot;tags&quot;], &amp;tags)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;tags: %v\n&quot;, tags)</span><br><span class="line"></span><br><span class="line">    var extra map[string]json.RawMessage</span><br><span class="line">    err = json.Unmarshal(m[&quot;extra&quot;], &amp;extra)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    var field1 string</span><br><span class="line">    err = json.Unmarshal(extra[&quot;field1&quot;], &amp;field1)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;extra.field1: %s\n&quot;, field1)</span><br><span class="line"></span><br><span class="line">    var field2 int</span><br><span class="line">    err = json.Unmarshal(extra[&quot;field2&quot;], &amp;field2)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;extra.field2: %d\n&quot;, field2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不确定的类型</span><br><span class="line">data := make(map[string]interface&#123;&#125;)</span><br><span class="line">if err := json.Unmarshal(rawData, &amp;data); err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if value, ok := data[&quot;age&quot;].(float64); ok &#123;</span><br><span class="line">    // 处理年龄为浮点数的情况</span><br><span class="line">&#125; else if value, ok := data[&quot;age&quot;].(int); ok &#123;</span><br><span class="line">    // 处理年龄为整数的情况</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 处理年龄为其他类型或不存在的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：类型断言的底层为反射，因为在运行时需要判断一个接口值的具体类型，而这个类型是在编译时无法确定的，需要在运行时动态地获取。效率比正常的代码低一到两个数量级，而且需要消耗额外的时间和内存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go模糊测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:32 / 修改时间：15:36:33" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:32+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p>在Go 1.18开始提供了Fuzzing能力的支持，testing包在我们常见的T B类型之外新增了F的类型，用于支持模糊测试</p>
<h2 id="Fuzzing-Test"><a href="#Fuzzing-Test" class="headerlink" title="Fuzzing Test"></a>Fuzzing Test</h2><p>日常测试代码的时候我们经常使用table driven test的方式来构造一组输入和预期的结果，之后调用我们的待测函数，检查结果是否和我们的预期匹配，也就是我们平常说的Mock数据</p>
<p>这就引出了一个问题，这个table要多大呢？<br>通常大家都只是写一个【正常】的case 一个【异常】的case<br>但是这些样例其实是不够的，比如一些异常值、corner case，可能无法处理，或者可能有程序挂掉、安全问题等等</p>
<p>而fuzzing test的作用就是帮我们自动生成输入数据，以下是维基百科对于fuzzing test的定义</p>
<p><code>Fuzzing is a technique where you automagically generate input values for your functions to find bugs</code></p>
<p>模糊测试能够【持续】、【自动】地生成一系列【半随机】的数据作为待测函数的输入，来找到程序里隐藏的bug，对于边界case能够很好的验证。模糊测试中的输入不是由人工指定的，而是自动生成的随机数据，所以可以规避掉人工主观判断造出来的数据。</p>
<p>模糊测试通常可以不依赖于开发测试人员定义好的数据集，取而代之的则是一组通过数据构造引擎自行构造的一系列随机数据。模糊测试会讲这些数据作为输入提供给待测程序，并且监测程序是否出现panic、断言失败、无限循环，或者其他的异常情况</p>
<p>这些通过数据构造引擎生成的数据被称为<strong>语料（corpus）</strong>，另外模糊测试其实也是一种持续测试的手段，因为如果不限制执行的次数或者执行的最大时间，它就会一直不停的执行下去</p>
<h2 id="Go模糊测试"><a href="#Go模糊测试" class="headerlink" title="Go模糊测试"></a>Go模糊测试</h2><p>让我们来看看一个Golang实现的模糊测试长什么样<br><img src="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1682407394290-f8c3006a-9f60-4362-a4e8-025536043457.png"></p>
<p>签名部分：从常见的<code>func TestXxx(t *testing.T)</code> 变成了<code>func FuzzXxx(f *testing.F)</code></p>
<p>seed corpus：一组用户提供的语料，fuzzing引擎会使用这个语料来生成随机数据。其实就是一个样本，之后引擎就知道要生成什么类型的随机数据了</p>
<p>Fuzzing arguments: 接受*testing.t和想要随机生成的数据类型<br><img src="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1682408593234-75061a31-701a-4f88-8121-7cb8c0d683df.png"><br>模糊测试的要求</p>
<ul>
<li>模糊测试必须是一个名称类似于<code>FuzzXxx</code>的函数，仅接受一个<code>*testing.F</code>参数，无返回值</li>
<li>模糊测试必须在<code>*_test.go</code>中运行</li>
<li>Fuzz target(模糊目标)必须是对<code>(*testing.F).Fuzz</code>的方法调用，参数是一个函数，并且这个函数的第一个参数是<code>*tesing.T</code>，然后是模糊参数（fuzzing argument），没有返回值</li>
<li>一个模糊测试中必须只有一个模糊目标</li>
<li>所有种子语料库（seed corpus）必须具有与模糊参数相同的类型，顺序相同</li>
<li>模糊参数只能是以下的类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string, []byte</span><br><span class="line">int, int8, int16, int32/rune, int64</span><br><span class="line">uint, uint8/byte, uint16, uint32, uint64</span><br><span class="line">float32, float64</span><br><span class="line">bool</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，在Go执行的过程中，多个fuzzing target是并行来处理的，底层会有多个worker，调度的顺序也不一定，所以不能做持久化，也不能依赖一些全局状态，不要尝试改变入参</p>
<p><strong>运行模糊测试</strong></p>
<p>我们依然可以使用<code>go test</code>命令来跑模糊测试，只是需要加上一个<code>-fuzz=FuzzTestName</code>的选项。同时这个包下所有其他类型的test都会优先于模糊测试执行，毕竟比较耗费资源，随机数据生成是有样本的。</p>
<p>执行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~ go test -fuzz FuzzFoo</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/192 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 192/192 completed, now fuzzing with 8 workers</span><br><span class="line">fuzz: elapsed: 3s, execs: 325017 (108336/sec), new interesting: 11 (total: 202)</span><br><span class="line">fuzz: elapsed: 6s, execs: 680218 (118402/sec), new interesting: 12 (total: 203)</span><br><span class="line">fuzz: elapsed: 9s, execs: 1039901 (119895/sec), new interesting: 19 (total: 210)</span><br><span class="line">fuzz: elapsed: 12s, execs: 1386684 (115594/sec), new interesting: 21 (total: 212)</span><br><span class="line">PASS</span><br><span class="line">ok      foo 12.692s</span><br></pre></td></tr></table></figure>

<p>Fuzzing test的局限性，在单元测试中因为测试输入是固定的，所以可以和把得到的结果和预期结果进行比较来判断执行结果是否与预期相符合。</p>
<p>但是在使用fuzzing的时候，我们无法预测输出结果是什么，因为测试的输入除了我们代码只能给指定的用例之外，还有fuzzing随机生成的输入，所以我们无法提前知道预期结果是什么</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/Go%E5%B8%B8%E8%A7%81%E6%89%8B%E6%90%93demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Go%E5%B8%B8%E8%A7%81%E6%89%8B%E6%90%93demo/" class="post-title-link" itemprop="url">Go常见手搓demo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:23 / 修改时间：15:35:50" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:23+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="手搓快排"><a href="#手搓快排" class="headerlink" title="手搓快排"></a>手搓快排</h2><p>需要注意的点有两个<br>1.循环里两数交换的条件为 i &lt; j 意味着左指针还在右指针的左侧 即两者还没相遇<br>2.递归的时候一个是j  一个是j+1 把数组一分为二进行递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	nums := []int&#123;3, 1, 2, 4, 6, 5&#125;</span><br><span class="line">	quickSort(nums, 0, len(nums)-1)</span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func quickSort(nums []int, l, r int) &#123;</span><br><span class="line">	if l &gt;= r &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	i, j, mid := l-1, r+1, nums[(l+r)/2]</span><br><span class="line">	for i &lt; j &#123;</span><br><span class="line">		i++</span><br><span class="line">		for nums[i] &lt; mid &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		j--</span><br><span class="line">		for nums[j] &gt; mid &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		if i &lt; j &#123;</span><br><span class="line">			nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort(nums, l, j)</span><br><span class="line">	quickSort(nums, j+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手搓堆排"><a href="#手搓堆排" class="headerlink" title="手搓堆排"></a>手搓堆排</h2><p>需要注意的点：<br>1.heapify用来递归做调整 其中heapSize表示堆大小 i表示要操作的节点下标 left 和 right 的值分别是 2_i+1 与 2_i+2<br>2.buildHeap和heapify都传参都是i,n，而堆排的时候是维护一个当前大小的堆，所以是0,i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	nums := []int&#123;3, 1, 2, 4, 6, 5&#125;</span><br><span class="line">	heapSort(nums)</span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func buildHeap(nums []int, heapSize int) &#123;</span><br><span class="line">	for i := heapSize / 2; i &gt;= 0; i-- &#123;</span><br><span class="line">		heapify(nums, i, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func heapSort(nums []int) &#123;</span><br><span class="line">	heapSize := len(nums)</span><br><span class="line">	buildHeap(nums, heapSize)</span><br><span class="line">	for i := heapSize - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">		nums[i], nums[0] = nums[0], nums[i]</span><br><span class="line">		heapify(nums, 0, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func heapify(nums []int, i, heapSize int) &#123;</span><br><span class="line">	largest := i</span><br><span class="line">	left, right := 2*i+1, 2*i+2</span><br><span class="line">	if left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest] &#123;</span><br><span class="line">		largest = left</span><br><span class="line">	&#125;</span><br><span class="line">	if right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest] &#123;</span><br><span class="line">		largest = right</span><br><span class="line">	&#125;</span><br><span class="line">	if largest != i &#123;</span><br><span class="line">		nums[largest], nums[i] = nums[i], nums[largest]</span><br><span class="line">		heapify(nums, largest, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个生产者-消费者模型"><a href="#实现一个生产者-消费者模型" class="headerlink" title="实现一个生产者-消费者模型"></a>实现一个生产者-消费者模型</h2><p>要注意的就是<br>通过select来实现一有消息就读，如果读完就退出<br>那怎么判断是否读完呢？这里就需要生产者主动关闭channel了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int,10)</span><br><span class="line">	go Processor(ch)</span><br><span class="line">	go Consumer(ch)</span><br><span class="line">  //睡一会</span><br><span class="line">	time.Sleep(15 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Processor(ch chan int) &#123;</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		// 模拟发时间的时延 这里可有可无</span><br><span class="line">		//time.Sleep(1 * time.Second)</span><br><span class="line">		fmt.Println(&quot;process:&quot;, i)</span><br><span class="line">	&#125;</span><br><span class="line">	close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Consumer(ch chan int) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">  	// 有数据就读出来 关闭了就退出</span><br><span class="line">		case i, ok := &lt;-ch:</span><br><span class="line">			if ok &#123;</span><br><span class="line">				fmt.Println(&quot;consumer:&quot;, i)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				fmt.Println(&quot;over!&quot;)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现两个goroutine打印奇偶数"><a href="#实现两个goroutine打印奇偶数" class="headerlink" title="实现两个goroutine打印奇偶数"></a>实现两个goroutine打印奇偶数</h2><p>需要注意的点是<br>关闭通道的时候需要异步进行，也就是异步Wait()，然后立马关掉ch<br>同步的话会有一个问题就是Even和Odd都往这个ch中写东西了，但是没有人去消费它，所以我们只能选择手动关闭。但是等待for range完毕，然后同步关闭的话会导致ch阻塞（因为for range不是消费）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func Even(wg *sync.WaitGroup, ch chan int) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	for i := 0; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(wg *sync.WaitGroup, ch chan int) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	for i := 1; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	wg.Add(2)</span><br><span class="line">	go Even(&amp;wg, ch)</span><br><span class="line">	go Odd(&amp;wg, ch)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		close(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	for v := range ch &#123;</span><br><span class="line">		fmt.Println(&quot;number:&quot;, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现两个goroutine交替打印奇偶数"><a href="#实现两个goroutine交替打印奇偶数" class="headerlink" title="实现两个goroutine交替打印奇偶数"></a>实现两个goroutine交替打印奇偶数</h2><p>需要注意的点：<br>通道必须得是有缓冲的，不然在main goroutine中往里面&lt;-1就会阻塞住，下面的go协程就不会执行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func Even(ch chan int) &#123;</span><br><span class="line">	for i := 0; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Println(&quot;number:&quot;, i)</span><br><span class="line">		ch &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(ch chan int) &#123;</span><br><span class="line">	for i := 1; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Println(&quot;number:&quot;, i)</span><br><span class="line">		ch &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int, 1)</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">	go Even(ch)</span><br><span class="line">	go Odd(ch)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/go-sum%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/go-sum%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">go.sum是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:11 / 修改时间：15:35:18" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:11+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>802</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p><code>go.sum</code>是Go语言管理包管理 <code>go mod</code>而使用的一种锁文件，用于记录Go项目中所有依赖包的路径和哈希值。每一行记录了一个依赖项的信息，包括依赖项的模块路径、版本、哈希值等等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github.com/pkg/errors v0.8.1 h1:OIzxFfzpYLMvPCkkN+UD9dJ9yRuoxzZbDvI8Du5OJ+E=</span><br><span class="line">github.com/pkg/errors v0.8.1/go.mod h1:9JFJoAoLZpNq3W4x/+xGw15jqJ7VHvq3u/L7V9XbTcg=</span><br><span class="line">golang.org/x/crypto v0.0.0-20210322153248-947e6a75a262 h1:2Q1cGh1Zpq/NWDTzDxKk/gZN+Yyo0F8wgJOu09Kml9Q=</span><br><span class="line">golang.org/x/crypto v0.0.0-20210322153248-947e6a75a262/go.mod h1:XTbTeuV6yl+B2H/UsM6UStw6z/5PhRlQIyH9/pXli/Y=</span><br></pre></td></tr></table></figure>

<p>go.sum文件的作用在于记录各个依赖项的版本和哈希值，用于验证项目的依赖关系是否发生变化。<br>当使用go mod安装依赖包的时候，会根据go.mod文件中指定的版本号下载相应的依赖包，并计算依赖包的哈希值，将这些信息记录到go.sum中，当再次构建项目的时候，go.mod会检查go.sum文件，确保依赖项的哈希值和之前记录的值一样，以此来保证项目的构建过程是可重现的<br>go.sum文件的重要性在于保证Go项目的依赖关系的可靠性和安全性，避免因为依赖包版本不一样导致的不可预期的问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/" class="post-title-link" itemprop="url">一周撸完K8S基础概念 Day1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-30 13:03:31 / 修改时间：13:04:49" itemprop="dateCreated datePublished" datetime="2023-05-30T13:03:31+08:00">2023-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="K8S概述"><a href="#K8S概述" class="headerlink" title="K8S概述"></a>K8S概述</h2><h3 id="什么是K8S？"><a href="#什么是K8S？" class="headerlink" title="什么是K8S？"></a>什么是K8S？</h3><p>Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。名字源于希腊语，意味”舵手”</p>
<p><strong>k8s出现的必要性</strong><br><img src="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/1685096676336-cedce0c3-dafd-4972-8a64-71c8dceec279.png" alt="image.png"><br>按照部署的方式来进行划分，我们可以简单的划分成四个时代</p>
<p><strong>传统部署时代</strong><br>如图一一样，APP部署在OS上，OS跑在硬件上。这会导致一个问题，如果在同一台机器上运行多个应用程序，如果某一个APP占用了机器的大部分资源，那么就会影响到其他APP，造成性能抖动甚至饿死的严重后果</p>
<p><strong>虚拟化部署时代</strong><br>为了解决上述问题，虚拟化技术被引进了，虚拟化技术允许你在单个物理服务器的CPU上运行多台虚拟机（VM）。虚拟化能使应用程序在不通过的VM之间被彼此隔离，且能提供一定程度的安全性，因为一个应用程序的信息不能被另一应用程序随意访问。<br>虚拟化技术能够更好地利用物理服务器的资源，并且可以更加轻松地添加、更新应用程序，因此具有更强的可扩缩性，以及降低硬件成本等等的好处</p>
<p><strong>容器部署时代</strong><br>容器类似于VM，但是相比于VMWare生成的那种VM，容器更加轻量级，并且与VM类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等等，容器之间可以共享OS。容器和基础架构是分离的，因此可以跨云和OS发行版进行移植</p>
<p><strong>容器的优势</strong></p>
<ul>
<li>敏捷应用程序的创建和部署：相比于VM镜像更加简便，提高了容器镜像创建的简便性和效率</li>
<li>持续开发、集成和部署：基于镜像不可变性，通过快速简单的回滚，提供可靠且频繁的容器镜像构建和部署</li>
<li>关注开发和运维的分离：在构建、发布时创建镜像，而不是部署的时候，从而将应用与基础架构进行分离</li>
<li>可观察性：不仅可以显示OS级别的信息和指标，还能够显示应用程序的运行状态、其他指标信号</li>
<li>跨开发、测试和生产的环境一致性：在开发物理机上也可以和在云中运行一样的应用程序</li>
<li>跨云和操作系统发行版本的可移植性：可在任意环境运行</li>
<li>松耦合、分布式、弹性：一个大的单体被分解成较小的服务，并且可以动态的管理和部署，而不是在一台大型单机上整体运行</li>
<li>资源隔离：可预测的应用程序性能</li>
<li>资源利用：高效率和高密度</li>
</ul>
<p><strong>K8S能做什么</strong><br>上文我们说到，容器是打包和运行应用程序的很好的一种方式，而在生产环境中，我们需要对很多容器（容器的集群）进行管理，保证服务不会出故障、确保服务的可靠性，稳定性。<br>例如一个容器发生故障，则需要把这个容器下掉，新增一个运行该服务的容器，再把它上线。而K8S就是帮助我们实现这个过程，简化操作流程的工具</p>
<p>K8S的功能</p>
<ul>
<li>服务发现与负载均衡：K8S可以使用DNS、或者自己的IP来暴露容器，如果进入容器的流量很大，K8S通过Kube-Proxy来实现的负载均衡，可支持的负载均衡算法有（轮询、最少链接、IP哈希），默认为轮询，通过负载均衡来分配网络流量，从而使部署更加稳定</li>
<li>存储编排：K8S允许自动挂载你选择的存储系统，例如本地存储、公共云提供商等</li>
<li>自动部署和回滚：可以使用K8S描述已部署容器的所需状态，并控制状态更改的速率</li>
<li>自动完成装箱计算：当K8S拥有许多节点组成一个集群之后，在这个集群上运行容器化的任务时，可以告知K8S每个容器需要多少资源（CPU 内存等），K8S可以将这些容器按实际情况调度到节点上，以最佳方式利用分配的资源</li>
<li>自我修复：K8S将重新启动失败的容器、替换容器、杀死不响应用户定义的健康检查的容器，并且在准备好服务之前不将其通告给客户端</li>
<li>密钥与配置管理：K8S允许你存储和管理敏感信息，例如密码、OAuth令牌和SSH密钥，可以在不重建容器镜像的情况下部署和更新密钥以及应用程序配置，也无需在堆栈配置中暴露密钥</li>
</ul>
<h2 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h2><p><img src="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/1685330733242-4d722d72-3d62-41f8-a370-527489669c2e.svg"><br>上述是K8S运行的架构流程图，我们可以看得出来，一个K8S集群主要由两部分组成，分别是<code>Control Plane</code>控制平面，老版本也叫做Master；<code>Node</code>工作节点，老版本也叫做Worker Node </p>
<p>我们将一组工作机器称为节点，节点会运行容器化应用程序，每个集群至少有一个工作节点。工作节点会托管Pod，控制平面管理集群中的工作节点与Pod</p>
<p>整体的一个典型的工作流程如下：</p>
<ol>
<li>用户使用K8S API与API服务器交互，发布应用程序的描述（如Pod Service等）</li>
<li>调度器根据应用程序的要求选择合适的节点，并将任务指派给节点上的Kubelet </li>
<li>Kubelet根据指令在节点上创建和管理容器，确保它们的状态与期望的状态</li>
</ol>
<h3 id="控制平面组件"><a href="#控制平面组件" class="headerlink" title="控制平面组件"></a>控制平面组件</h3><p>控制平面组件会为集群做出全体决策，比如资源的调度，以及检测和响应集群事件。可以理解成K8S集群的大脑，负责管理和控制整个集群的行为。<br>控制平面组件可以在集群中的任何节点上运行，通常来说为了简单起见，只会在同一个计算机上启动所有的控制平面组件，并且不会在这台机器上运行任何容器</p>
<p>**kube-apiserver **<br>API服务器是K8S控制平面的组件之一，提供了与K8S集群通信的接口，允许用户和其他组件通过HTTP RESTful API与K8S进行交互，这个组件负责公开K8S API，负责处理接受请求的工作，验证并配置API对象的数据，这些对象包括pods services replicationcontrollers等，为REST操作提供服务，可以将它简单理解为K8S控制平面的前端，其他所有组件都通过该前端进行交互。<br>同时，API SERVER还负责验证请求的身份和权限，通过Token UserName&#x2F;Password TLS证书等进行确认和交互，验证用户或者组件的身份，一旦用户验证成功，API Server会使用访问控制策略进行角色授权<br>并且它负责资源管理，维护一组持久化存储(etcd)来存储资源的配置、状态和元数据<br>它还负责记录集群中的事件和日志信息，当资源对象发生变化或者出现错误的时候，它会生成事件并将其发送给订阅者 </p>
<p><strong>etcd</strong><br>它是一个分布式的一致且高可用的键值存储，用作k8s所有集群数据的后台数据库，存储集群的配置数据、元数据和状态信息的可靠持久化存储。etcd提供了高可用性、一致性和分布式的特性，为K8S的控制平面组件提供了一个共享的数据存储，API Server、kube scheduler 和 CM 等组件通过使用etcd来存储和检索集群的配置信息、资源对象的状态以及各种元数据，这些信息包括Pod Service Namespace PersistentVolume等的定义和状态</p>
<p>etcd的一些关键功能</p>
<ul>
<li>分布式存储：etcd使用Raft一致性算法来实现数据的分布式存储，它将数据分片并复制到集群中的多个节点上，确保数据的可用性和容错性，这意味着即使一些节点失效，集群应该可以继续正常工作</li>
<li>一致性：etcd的Raft算法保证了数据的一致性，所有的写操作都需要经过多数节点的确认，确保数据的正确复制和同步，这样可以避免数据损坏和不一致的情况发生</li>
<li>高可用性：etcd具有高可用性，通过在集群中的多个节点上复制数据，提供了容错能力</li>
<li>快速读写：etcd通过在内存中保持数据的副本，实现了快速的读写操作，使用B+树作为底层数据结构，提供高效的索引和检索功能</li>
<li>监控和故障恢复：etcd提供了一些监控和故障恢复机制，可以监测节点的状态和健康状况。当节点发生故障或变得不可用时，集群可以自动进行重新选举，选择新的领导者节点来接管工作</li>
</ul>
<p>**kube-scheduler **<br>负责监视新创建的、未指定运行节点（node）的Pods，并选择节点来让Pod运行在该节点上，以实现负载均衡、资源利用率最大化和高可用性<br>调度决策考虑的因素包括：单个Pod及Pods集合的资源需求、软硬件及策略约束、亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限<br>scheduler的主要功能如下</p>
<ol>
<li>资源调度：scheduler根据容器的资源需求（如CPU 内存）和节点的资源利用率，决定将工作负载调度到哪个节点上运行</li>
<li>节点选择：scheduler根据工作负载的要求，选择适合的节点进行调度，通过筛选和评分机制来选择节点，同时scheduler还考虑亲和性规则，以便将相关的工作负载调度到同一节点上，提高应用程序的性能和效率</li>
<li>拓展性和灵活性：scheduler具有可插拔的架构，允许用户根据自己的需求自定义和拓展调度算法，用户可以实现自定义的调度策略，通过调整评分函数和优先级规则来满足特定的业务需求</li>
<li>调度器扩展：k8s提供了灵活的调度器扩展机制，允许用户添加额外的带哦赌气，这些调度器可以根据特定的需求和场景来实现自定义的调度逻辑</li>
</ol>
<p>工作流程如下：</p>
<ol>
<li>用户创建或者更新一个工作负载的描述，例如Deployment StatefulSet等</li>
<li>当新的工作负载被提交时，Scheduler接收到这个事件，并根据工作负载的需求和集群状态进行调度决策</li>
<li>Scheduler遍历集群中的可用节点，评估每个节点的适合程度，并为每个节点打分</li>
<li>Schedulergenuine打分结果选择最合适的节点，并将工作负载的调度决策通知给相应的节点的Kubelet </li>
<li>Kubelet在选择的节点上启动和管理容器，并把容器的状态报告给控制平面</li>
</ol>
<p><strong>kube-controller-manager(cm)</strong><br>负责运行控制器进程，理论上来说每个控制器都是一个独立的进程，但是为了降低复杂性，它们都被编译到一个可执行文件中，并且在同一个进程中运行。<br>这些控制器包括</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的JOB对象，然后创建Pods来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片对象，以提供给Service和Pod之间的链接</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>CM启动时，它的各个控制器开始监视集群中的特定资源对象</li>
<li>控制器通过API Server获取资源对象的当前状态，并将其与所需要的期望状态进行对比</li>
<li>如果二者不一致，那么控制器会触发相应的操作来使它们保持一致，这可能包括创建、更新或者删除资源对象</li>
<li>控制器通过API Server发出相应的操作请求，将更改应用于集群中的资源对象</li>
<li>控制器不断循环执行，以确保资源对象的状态和行为与期望状态保持一致</li>
</ol>
<p>**cloud-controller-manager(ccm)  **<br>嵌入了特定的云平台控制逻辑，云控制器管理器允许将你的集群连接到云提供商的API之上，并将与该云平台交互的组件同你的集群交互的组件分离开来。<br>与cm类似，ccm将若干逻辑上独立的控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。你可以对其执行水平扩容以提升性能或者增强容错能力。</p>
<ul>
<li>节点控制器（Node Controller）： 用于在节点终止响应后检察云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>CCM组件在启动的时候与云平台的API进行认证和链接，并监视云资源对象的状态</li>
<li>CCM的控制器通过与云平台的API进行交互，获取云平台资源对象的状态，并将其与K8S中的对象进行比较</li>
<li>如果二者状态不一致，CCM的控制器会触发相应的操作，通过与云平台的API发出请求，将更改应用于云资源</li>
</ol>
<h3 id="工作节点组件"><a href="#工作节点组件" class="headerlink" title="工作节点组件"></a>工作节点组件</h3><p>节点组件会在每个节点上运行，负责维护运行的pod并提供K8S运行环境</p>
<p>**kubelet **<br>kubelet会在集群中每个节点(node)上运行，它保证容器(containers)都运行在Pod中。<br>kubelet接收一组通过各类机制提供给它的PodSpecs，确保这些PodSpecs中描述的容器处于运行状态且健康，kubelet不会管理不是由k8s创建的容器，kubelet是k8s集群中的每个node上的主要组件之一，负责管理节点上的容器化工作负载，与控制平面交互，确保集群中的容器正确运行，并且维护节点的健康状态</p>
<p>主要功能：</p>
<ul>
<li>容器管理：kubelet负责在节点上创建、启动、停止和销毁容器，它通过与容器运行时（Docker Containerd）进行交互，执行容器的生命周期管理操作</li>
<li>资源管理：Kubelet监控节点的资源使用情况，并根据预定义的资源配额和调度策略来分配资源给容器，它会定期向K8S控制平面报告节点上的资源状态</li>
<li>健康检查：Kubelet定期对节点上的容器进行健康检查，包括容器的存活状态、资源利用率等，如果容器故障或者资源不足，Kubelet会尝试重启、恢复或迁移容器</li>
<li>节点注册：Kubelet在节点启动时将自身注册到K8s控制平面，使控制平面能够管理和监控该节点上的容器化工作负载</li>
<li>网络管理：Kubelet配置节点上的网络参数，包括容器网络和节点网络。它为容器分配IP地址，并配置容器之间和容器与外部的网络通信</li>
<li>卷管理：Kubelet负责挂在和卸载容器中使用的持久卷，它与卷插件交互，使容器能访问和使用持久化存储</li>
<li>日志和监控：Kubelet收集和管理节点上容器的日志和监控数据，它可以将日志发送到集中式日志系统，并提供容器的运行指标和事件信息</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>Kubelet监听来自K8S控制平面的指令和命令</li>
<li>K8S获取需要在节点上运行的pod列表，并根据指定的pod规范创建和管理容器</li>
<li>对于每个容器，Kubelet通过容器运行时（如Docker）来启动和停止容器，并监控其状态</li>
<li>Kubelet定期向K8s控制平面报告节点的资源使用情况和容器状态</li>
<li>Kubelet定期凑够控制平面获取Pod的更新和变更，并相应地执行容器的生命周期管理操作</li>
</ol>
<p><strong>kube-proxy</strong><br>kube-proxy是集群中每个节点(node)上所运行的网络代理，实现k8s概念的一部分，它维护节点上的一些网络规则，这些网络规则会允许从集群内部或外部的网络会话与Pod进行网络通信。运行在每个节点上，并与K8S控制平面和节点上的网络组件进行交互，以实现服务的可访问性和网络流量的转发<br>如果操作系统提供了可用的数据包过滤层，则kube-proxy会通过它来实现网络规则，否则，kube-proxy只做流量转发</p>
<p>主要功能：</p>
<ul>
<li>服务代理：Kube-proxy监听K8S控制平面中的服务和短空定义，并为它们创建对应的网络代理规则，这些规则通常基于IP Tables或者IPVS，根据服务的选择器和端口信息，将流量转发到相应的后端pod </li>
<li>负载均衡：Kube-proxy实现了负载均衡功能，将来自集群内部和外部的网络请求均匀地分发到后端的Pod。它可以基于轮询、随机选择或最少连接等算法来进行负载均衡</li>
<li>服务发现：Kube-proxy监听K8S控制平面中国的服务和端口定义的变化，当服务的Pod副本数量发生变化、服务的标签或者端口信息发生变更时，Kube-proxy会相应地更新代理规则，以确保服务的访问正常</li>
<li>节点故障处理：Kube-proxy监测节点的健康状态，并在节点故障或网络中断的情况下自动更新代理规则，它会将流量重新路由到其他健康节点上的Pod，以保证服务的高可用性</li>
<li>透明代理：Kube-proxy支持透明代理模式，可以在不修改应用程序代码的情况下，将应用程序流量转发到后端Pod。这种方式对应用程序是透明的，它们无需感知代理的存在</li>
</ul>
<p>Kube-proxy的工作流程如下：</p>
<ol>
<li>Kube-proxy从K8S控制平面获取服务和端口定义，并为每个服务创建代理规则</li>
<li>当有新的服务或端口定义添加到集群中，或者现有的定义发生变化时，Kube-proxy监测到变化并相应地更新代理规则</li>
<li>Kube-proxy监听来自服务暴露的端口上的网络流量</li>
<li>根据代理规则，Kube-proxy将流量转发到后端Pod上的容器，实现负载均衡和服务发现的功能</li>
</ol>
<p><strong>Container Runtime 容器运行时</strong><br>容器运行环境是负责运行容器的软件，K8S支持许多容器运行环境，例如containerd CRI-O 以及K8S CRI的其他任何实现<br>Container Runtime（容器运行时）是 Kubernetes 中负责管理和运行容器的核心组件。它提供了创建、启动、停止和销毁容器的功能，以及管理容器的资源和隔离性。</p>
<p>Kubernetes 支持多种容器运行时，其中最常用的是 Docker 和 Containerd。下面将详细介绍容器运行时的工作原理和功能：</p>
<ol>
<li>容器生命周期管理：容器运行时负责与容器生命周期相关的操作。它可以根据容器镜像创建并启动容器，监控容器的运行状态，并在需要时停止或销毁容器。 </li>
<li>容器隔离性：容器运行时使用 Linux 内核的命名空间和控制组（cgroup）等特性，为容器提供隔离的运行环境。每个容器都具有独立的文件系统、网络栈、进程空间和资源限制，从而实现容器之间的隔离和安全性。 </li>
<li>容器网络：容器运行时负责设置和管理容器的网络。它为每个容器分配唯一的 IP 地址，并处理容器之间的网络通信。容器运行时还可以与网络插件协同工作，以实现更高级的网络功能，如跨主机的容器通信和负载均衡。 </li>
<li>容器存储：容器运行时管理容器的存储。它可以为容器提供本地存储卷或挂载外部存储卷，使容器能够持久化存储和访问数据。 </li>
<li>容器镜像管理：容器运行时负责下载、管理和缓存容器镜像。它可以从容器镜像仓库中拉取镜像，并将其存储在本地节点上，以便在需要时快速创建容器。 </li>
<li>容器资源管理：容器运行时与 Kubernetes 的调度器和资源管理器交互，以确保容器在节点上得到适当的资源分配。它可以根据容器的资源需求和节点的可用资源进行调度和限制，以实现资源的公平分配和利用。</li>
</ol>
<p>容器运行时在 Kubernetes 中的工作流程如下：</p>
<ol>
<li>Kubernetes 控制平面下发容器启动的指令，包括容器镜像、资源要求等信息。 </li>
<li>容器运行时根据指令从容器镜像仓库拉取镜像，并创建容器的运行时环境。 </li>
<li>容器运行时使用 Linux 命名空间和控制组等功能，为容器提供隔离的运行环境。 </li>
<li>容器运行时启动容器中的应用程序，并监控容器的运行状态。 </li>
<li>容器运行时与容器网络 插件协同工作，为容器分配 IP 地址，并处理容器之间的网络通信。</li>
<li>容器运行时根据 Kubernetes 控制平面的指令，停止或销毁容器。</li>
</ol>
<p>总之，容器运行时是 Kubernetes 中关键的组件之一，它负责管理和运行容器，提供容器的隔离性、生命周期管理、网络和存储功能，与其他 Kubernetes 组件协同工作，实现容器化应用程序的高效运行和管理。</p>
<p><strong>node、kubelet、pod和container之间的联系</strong></p>
<p>Node：是K8S集群中的工作节点，也被称为主机或者服务器，每个Node提供容器运行的基础设施，并承载运行着的容器<br>Kubelet：是运行在每个Node上的K8S组件之一，是Node上的代理程序，Kubelet负责管理和运行Node上的容器，并与K8S控制平面交互<br>Pod:Pod是K8S的最小调度和部署单元，它是一个逻辑上相关的容器组，可以包含一个或者多个容器，Pod提供了一个抽象层，为容器提供共享的网络和存储资源，使容器之间可以进行通信和共享数据，Pod是在Node上进行调度和运行的<br>Container：容器是在Pod中运行的实际应用程序或服务，一个Pod可以包含一个或者多个容器，这些容器共享同一个网络命名空间和存储卷，容器被kubelet创建、启动、停止和销毁</p>
<p>通过这种方式，kubelet作为Node上的代理程序，负责与Kubernetes控制平面交互，并协调管理Node上的容器。Pod是在Node上调度和运行的最小单元，它可以包含一个或多个容器，这些容器共享同一个网络和存储环境。这种关系使得kubernetes可以以分布式和高可用的方式运行和管理容器化应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">消息队列系统学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-28 23:07:27" itemprop="dateCreated datePublished" datetime="2023-05-28T23:07:27+08:00">2023-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-30 13:03:52" itemprop="dateModified" datetime="2023-05-30T13:03:52+08:00">2023-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列，我们一般会称为MQ（Message Queue）,也就是说消息队列的本质就是一个队列，而队列是一种先进先出的数据结构，提供<strong>消息传递和消息排队</strong>模型，可以在分布式环境下提供应用解耦、弹性伸缩、流量削峰、异步通信、数据同步、微服务之间通信等功能，作为分布式系统架构中的一个重要组件，有着举足轻重的地位<br>我们会将要传输的数据、消息放在消息队列中<br>其中，往MQ里放东西的叫做生产者<br>从MQ里面取消息的叫做消费者</p>
<h2 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>现在有一个系统A，A可以产生一个UserId<img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565301195-6a5df167-0f49-4812-b648-247b6c15cf0e.png"><br>然后有系统B和系统C都需要这个UserId去做相关的操作<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565335300-52330f30-1d93-49be-b70b-c50906a61096.png"><br>这样就会有一个问题，每当出现改动的时候，我都要改动整个系统，比如B不需要A的消息了，那么就要改A、B，新来的一个D服务，需要用到A的消息，那么又需要修改，整个系统的冗余度很高<br>引入消息队列之后：系统A将id写到消息队列中，BC服务从消息队列中拿数据</p>
<p>系统A只负责写数据，不关心数据的消费、处理，而BC服务只负责拿数据，即使BC服务挂了，也和系统A没关系，只和消息队列有关，这样就能做到多个服务之间的解耦</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565724785-78356256-717e-4f5a-865d-90afe84f7226.png"><br>如果是同步的话，A必须要等待B C D 处理完之后才能返回，整个时间比较久<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565780159-8d1d3475-6244-4a13-b440-bf94f90cedab.png"><br>如果是异步的话，A（比如注册服务）将消息写道消息队列之后就可以返回，之后再发给邮件服务和短信服务消费</p>
<h3 id="限流、削峰"><a href="#限流、削峰" class="headerlink" title="限流、削峰"></a>限流、削峰</h3><p>当请求来的时候，先把请求放在消息队列中，然后系统再根据自己能够处理的请求数去消息队列里面拿数据，这样即使每秒请求数很大，也不会把系统打崩</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>消息队列通常有很多种方式来实现流量控制</p>
<p>1.配额控制：通过为每个生产者或者消费者分配配额，限制它们可以发送或者接受的消息数量。这可以保证消息队列中的资源不会被过度使用，并确保系统在高负载情况下的稳定性</p>
<p>2.窗口机制：当生产者将消息发送到消息队列的时候，消息队列会给每个生产和分配一个发送窗口，当消费者确认之后把对应的消息从窗口里面删除</p>
<p>3.缓冲区：消息队列把消息往缓冲区里丢，消费者从缓冲区里去取</p>
<p>4.速率限制：这个一般是在客户端实现的，可以实现生产者在每秒、每分钟生产多少条消息</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h3><p>常见的消息队列都有确认机制（ACK机制），当消费者消费数据之后会给消息队列中间件发送一个确认消息，消息队列收到之后就会把这条消息从队列中删除。</p>
<p>当出现网络传输等故障，ACK没有传送到消息队列，导致消息队列不知道消费者已经消费过该消息了，再次将消息分发给其他的消费者</p>
<p>解决：</p>
<p>1.看场景，如果场景不需要幂等，那么可以不管，比如这条消息拿去插入数据库，重复插入主键相同的数据是会自动出错的，再比如做redis的set操作，也不需要管，多次set之后仍然是幂等的</p>
<p>2.准备第三方介质做消费记录，比如加个redis，给消息分配一个全局id，只要消费过该消息就将&lt;id,message&gt;写入redis。消费者消费之前先去redis中查有没有消费记录即可</p>
<h3 id="如何保证消息的可靠性传输"><a href="#如何保证消息的可靠性传输" class="headerlink" title="如何保证消息的可靠性传输"></a>如何保证消息的可靠性传输</h3><p>消息队列丢数据主要有三个可能</p>
<p>1.生产者丢数据</p>
<p>2.消息队列组件丢数据</p>
<p>3.消费者丢数据</p>
<p>生产者：可以采用transaction机制，开启事务来发送消息，如果发送失败就回滚。但是生产中用的不多，因为会导致吞吐量的下降，一般都是用confirm机制，如果生产者成功把消息发送给队列，队列会回一个ack，否则回一个nack</p>
<p>消息队列：可以开启持久化，而且一般是集群部署的，有master和slave节点，一般都是同步复制，只有主节点和从节点都写入成功才返回ack给生产者</p>
<p>消费者：取消自动确认，自动确认后消息队列收到ACK会立马把消息从队列中删掉，而是手动确认（即处理后才回ACK）。</p>
<h2 id="消息队列需要考虑的问题"><a href="#消息队列需要考虑的问题" class="headerlink" title="消息队列需要考虑的问题"></a>消息队列需要考虑的问题</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>消息队列肯定不是单机的，这样可用性和健壮性都非常差，所以项目中使用的消息队列都得集群或者分布式</p>
<h3 id="数据问题"><a href="#数据问题" class="headerlink" title="数据问题"></a>数据问题</h3><p>消息丢失：当消费者拿了数据还没使用的时候，服务就挂掉了，就会导致消息的丢失，一般会使用ACK应答机制，当消费者拿到消息发送确认ACK信号，消息队列才会把对应的消息删掉</p>
<p>消息堆积：消息堆积分为客户端堆积和服务端堆积<br>一般都会设置告警规则来通知开发者消息堆积的问题</p>
<p>如果是客户端消息堆积，那可以考虑扩大消费线程或者节点来解决， 针对于某些特殊场景，如果消息堆积已经影响到业务，并且堆积的消息可以跳过不消费，那么可以重置消费消息位置为最新位置开始消费，快速恢复业务。</p>
<p>如果是服务端消息堆积，考虑服务端宕机的情况，快速恢复之后重新可用</p>
<h3 id="消费者取数据"><a href="#消费者取数据" class="headerlink" title="消费者取数据"></a>消费者取数据</h3><p>两种方法</p>
<p>1.push 消息队列有新消息的时候主动叫消费者去拿，实时性强。如果消费者故障，服务端堆积消息。</p>
<p>2.pull 消费者不断的轮询消息队列，看看有没有新数据，如果有就消费，实时性弱。</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670576619633-e8cfd841-4823-44df-b3dd-eecd0052c3eb.png"></p>
<h2 id="消息队列的传输模式"><a href="#消息队列的传输模式" class="headerlink" title="消息队列的传输模式"></a>消息队列的传输模式</h2><h3 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h3><p>用于消息生产者和消息消费者之间点到点的通信，消息生产者将消息发送到某个特定的消费者<br>特点：<br>1.每个消息只有一个消费者<br>2.发送者和接收者都没有时间依赖<br>3.接受者确认消息接受和处理成功</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670575350774-76cb25c0-2bae-4ac7-baae-ecb911767458.png"></p>
<h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p>发布订阅模型支持向一个特定的消息主题产生消息，在这种模型下，发布和订阅者彼此不知道对方的存在，多个消费者可以获得消息，在发布者和订阅者之间存在<strong>时间依赖性</strong>，<strong>发布者publish</strong>需要建立一个<strong>订阅subscription</strong>，以便消费者能够订阅。订阅者必须<strong>保持持续的活动状态</strong>并<strong>接受消息</strong></p>
<p>主题、订阅、消费者（组）之间的关系为 M：N：O</p>
<p>在这种情况下，订阅者未连接时，发布的消息将<strong>在订阅者重新连接的时候重新发布</strong><br>特点：<br>1.每个消息可以有多个订阅者<br>2.客户端只有订阅之后才能收到消息<br>3.持久订阅和非持久订阅</p>
<p>持久订阅：订阅关系建立之后，消息就不会消失，不管订阅者是否在线<br>非持久订阅：订阅者为了接受消息，必须一直在线，当只有一个订阅者的时候等于点对点模式</p>
<h3 id="pub-sub-vs-queue"><a href="#pub-sub-vs-queue" class="headerlink" title="pub-sub vs queue"></a>pub-sub vs queue</h3><p>发布订阅和队列模式是消息队列中的两种不同的消息模式</p>
<p>发布-订阅模式：发布者将消息发送到特定的主题（topic）上，订阅者可以选择订阅感兴趣的主题，从而接受与该主题相关的消息。在该模式中，消息被广播给所有订阅者，每个订阅者可以独立处理消息，订阅者之间不会相互干扰。发布-订阅模式通常用于广播消息或者通知</p>
<p>队列模式：消息发送到队列中，然后一个或者多个消费者从队列中收取并处理消息。在该模式中，每条消息只能被一个消费者接收和处理。如果有多个消费者，消息将被平均分配给它们。队列模式通常用于实现任务分配或者负载均衡等场景</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670575824095-d0f958e8-2464-46ad-9afd-0faf74cd101b.png"></p>
<h2 id="市面上消息队列对比"><a href="#市面上消息队列对比" class="headerlink" title="市面上消息队列对比"></a>市面上消息队列对比</h2><p>记住两个最常见的MQ的对比就可以，硬盘MQ代表是Kafka 内存MQ代表是RabbitMQ</p>
<p>Kafka的优点是客户端支持多语言、使用pull模式，支持消息批量操作，支持replica机制，Zookeeper自动选举leader恢复能力，数据可靠，有容错容灾的能力，单机吞吐量为10W级，延迟毫秒，数据基于硬盘层面存储，多Client支持有序，不支持事务，但是可以通过LOW LEVEL API的方式保证消息只支持消费一次</p>
<p>RabbitMQ的优点是客户端支持多语言，多协议支持，不支持消息批量操作，有pull和push两种模式，使用的主从模式master&#x2F;slave，master提供服务，slave做备份，数据可靠（因为有备份），单机吞吐量为万级别，消息延迟为微秒级，内存级别，可以主动开启持久化，支持集群和负载均衡，不保证多Client消息有序</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670576658702-ebe9380a-41e5-4206-9f90-ce09c6af384d.png"></p>
<h3 id="pulsar-kafka-rabbitmq-nsq的异同"><a href="#pulsar-kafka-rabbitmq-nsq的异同" class="headerlink" title="pulsar kafka rabbitmq nsq的异同"></a>pulsar kafka rabbitmq nsq的异同</h3><p>1.pulsar 和 kafka基于发布订阅模式，而rabbitmq 和 nsq基于的是队列模式</p>
<p>2.pulsar和kafka都采用了持久化机制，以支持高吞吐量和高可靠性，而rabbitmq和nsq则将数据存储在内存中，以支持更低的延迟和更高的吞吐量</p>
<p>3.pulsar和kafka都支持 多租户和多数据中心部署，可以轻松地在多个数据中心或者云平台上进行扩展，而rabbitmq和nsq则更加适合单个数据中心的部署</p>
<p>4.pulsar和kafka都具有出色的可伸缩性和高可用性，处理数据单位是百万级别的；而rabbitmq和nsq则更加适合小规模的应用程序，具有更低的延迟和更高的性能</p>
<p>5.pulsar和kafka都提供了消息流的处理程序，使用户可以对消息进行实时分析和处理</p>
<p>总的来说：pulsar和kafka更适合处理大量消息和数据流，rabbitmq和nsq则更适合小规模应用程序，具有更低的延迟和更高的性能</p>
<h1 id="Pulsar底层实现"><a href="#Pulsar底层实现" class="headerlink" title="Pulsar底层实现"></a>Pulsar底层实现</h1><p>Pulsar是Apache基金会的顶级项目，是<strong>云原生的分布式消息队列</strong>，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据恢复机制，具有强一致性、高吞吐、低时延及高可扩展性等流数据存储特性</p>
<ul>
<li>云原生MQ</li>
<li>单个Pulsar实例原生支持多集群，可跨机房完成消息复制</li>
<li>支持超过一百万个topic</li>
<li>支持多语言客户端</li>
<li>主题多种订阅模式（独占、共享和故障转移）</li>
<li>通过Book Keeper来实现持久化存储，保证消息传递</li>
<li>分层式存储，可在数据陈旧时将数据从热存储卸载到冷存储中</li>
</ul>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Messages有很多的部分组成， 下面是几个值得注意的</p>
<ul>
<li>value&#x2F;payload 消息的数据</li>
<li>properties 可选的属性，是一个key-&gt;value的键值对</li>
<li>producer name 生产者名称</li>
<li>publish time 发布时间戳</li>
<li>sequence id 在topic中 每个msg属于一个有序的队列 sequence id是它在序列中的次序</li>
</ul>
<p>Pulsar和其他的MQ一样，会对消息的大小做出限制</p>
<p>这个限制通过broker.conf中的maxMessageSize 决定</p>
<p>不设置的话，默认为5MB</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者是关联到topic的程序，它发布消息到Pulsar的broker上</p>
<p><strong>发送模式</strong></p>
<ul>
<li>异步发送：生产者发送消息之后会等待broker的确认，如果没有收到确认则认为是发送失败</li>
<li>同步发送：会把消息放在阻塞队列中，然后立马返回，然后这个阻塞队列会往broker中发消息</li>
</ul>
<p><strong>主题访问模式</strong></p>
<ul>
<li>Shared（共享）  多个生产者可以发布一个主题，这是默认设置</li>
<li>Exclusive（独占） 一个主题只能由一个生产者发布，如果已经有生产者链接，其他生产者试图发布该主题将立即得到错误。如果”老”的生产者与broker发生网络分区，”老”生产者将被驱逐，”新”生产者将被选为下一个唯一的生产者</li>
<li>WaitForExclusive（独占等待） 如果已经有一个生产者连接，生产者的创建是未决的，直到生产者获得独占访问。成功成为排他性的生产者被视为领导者，因此，如果想实现leader选举方案，可以使用这种模式</li>
</ul>
<p><strong>压缩、批处理与分块</strong><br>压缩：我们可以主动压缩生产者在传输期间发布的消息，Pulsar目前支持以下类型的压缩</p>
<ul>
<li>LZ4</li>
<li>ZLIB</li>
<li>ZSTD</li>
<li>SNAPPY</li>
</ul>
<p>批处理：如果批处理开启，producer将会积累一批消息，然后通过一次请求发送出去。批处理的大小取决于最大的消息数量及最大的延迟发布</p>
<p>分块：分块和批处理不能同时启用，要启用分块，必须提前禁用批处理。Chunking只支持持久化的主题</p>
<p>一个producer与一个订阅consumer的分块消息<br>当生产者向主题发送一批大的分块消息和普通的非分块消息时。将M1切成分块M1-C1、M1-C2、M1-C3。这个broker在其管理的ledger里面保存所有的三个块消息，然后以相同的顺序分发给消费者（独占&#x2F;灾备）。消费者将在内存缓存所有的块消息，直到收到所有的消息快。将这些消息合并成为原始的消息M1，发送给处理进程<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682219039171-07775a32-cf8b-4b8f-87ab-d77646e3db76.png"></p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费者通过订阅关联到主题，然后接受消息的程序</p>
<p><strong>接收模式</strong></p>
<p>消息可以通过同步或者异步的方式从broker接受</p>
<p>同步：同步接收将会阻塞，直到消息可用</p>
<p>异步：异步接收立刻返回future值，一旦新消息可用，它将即可完成</p>
<p><strong>监听</strong></p>
<p>客户端类库提供了它们对于consumer的监听实现，在这个接口中，一旦接受到新的消息，received方法将被调用</p>
<p><strong>确认</strong></p>
<p>消费者成功处理消息之后需要发送确认（ack）给broker，以让broker丢掉这条消息（否则将一直存储）。消息的确认可以逐个进行，也可以累积到一起。累计确认的时候，消费者只需要确认最后一条它收到的消息，所有之前的消息都认为被成功消费。累积确认不能用于shared模式，因为shared订阅为同一个订阅引入了多个消费者</p>
<p><strong>主题</strong></p>
<p>和其他的MQ一样，Pulsar中的topic是带有名称的通道，用来从producer到consumer传输消息，topic的名称是符合良好结构的URL</p>
<p><code>&#123;persistent|non-persistent&#125;://tenant/namespace/topic</code></p>
<ul>
<li>peisistent|non-persistent 定义了topic的类型，Pulsar支持两种不同的topic：持久化和非持久化，默认是持久化类型，也就是会保存到硬盘上的类型</li>
<li>tenant 实例中topic的租户，tenant是Pulsar多租户的基本要素，可以被跨集群的传播</li>
<li>namespace topic的管理单元，与topic组的管理机制相关。大多数的topic配置在namespace层面生效，每个tenant可以有多个namespace</li>
<li>topic 主题的最后组成部分</li>
</ul>
<p><strong>Partitioned topics 分区主题</strong></p>
<p>普通的主题只由单个broker提供服务，这限制了主题的最大吞吐量，分区主题是由多个broker处理的一种特殊类型的主题，因此允许更高的吞吐量<br>分区主题实际上实现为N个主题，N是分区的数量。当消息发布到分区主题的时候，每个消息都被路由到几个Broker中的一个。分区在broker之间的分布由Pulsar自动的进行处理<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682220786986-bcdaace6-1ac7-48f7-b874-208796a3b695.png"><br>如上图，Topic有五个分区，划分在3个broker上，因为分区比broker多，前两个broker分别处理两个分区，而第三个broker只处理一个分区（Pulsar自动处理分区的分布）<br>此主题的消息将广播给两个消费者，路由模式决定将每个消息发布到哪个分区，而订阅模式决定将哪些消息发送到哪个消费者</p>
<p><strong>路由模式</strong></p>
<ul>
<li>RoundRobinPartition message无key则轮询，有key则hash指定分区（默认模式）</li>
<li>SinglePartition message 无key 则producer将会随机选择一个分区，将所有的消息都发送给该分区。如果message有key，那么会hash指定分区</li>
<li>CustomParition 使用自定义消息路由实现</li>
</ul>
<p><strong>顺序保证</strong></p>
<p>消息的顺序与路由模式和消息的key有关</p>
<ul>
<li>Per-key-partition （按key分区） 具有相同key的所有消息将被顺序放置在同一个分区中</li>
<li>Per-producer （按照Producer） 来自同一生产者的所有消息都是有序的</li>
</ul>
<p><strong>哈希方案</strong></p>
<p>HashingScheme是一个enum，表示在选择要为特定消息使用的分区时可用的标准哈希函数集</p>
<p>有两种类型的标准哈希函数可用：JavaStringHash和Murmur3_32Hash，生产者的默认哈希函数是Java，但是当生产者的客户端是多语言的时候，Java是没用的</p>
<p><strong>持久&#x2F;非持久化主题</strong></p>
<p>默认情况下,Pulsar会保存所有没确认的消息到Book Keeper中，持久Topic消息会在broker重启或者consumer出问题的时候保存下来</p>
<p>Pulsar也支持非持久化Topic 这些Topic的消息只存在于内存中，不会存储到磁盘</p>
<p>因为Broker不会对消息进行持久化存储，当Producer将消息发送给Broker时，Broker可以立即将ack返回给Producer，所以非持久化的消息传递会比持久化的更快。相对的，当Broker因为一些原因宕机、重启后，非持久化的Topic消息都会消失，订阅者将无法收到这些消息。</p>
<p><strong>Dead letter topic 死信主题</strong></p>
<p>死信主题允许你在用户无法成功消费某些消息时使用新消息。在这种机制中，无法使用的消息存储在单独的主题中，成为死信主题。</p>
<p>死信主题依赖于消息的重新投递，由于确认超时或者否认确认，消息将被重新发送。如果要对消息使用否定确认，请确保在确认超时之前对齐进行否定确认。</p>
<p><strong>Retry letter topic 重试主题</strong></p>
<p>对于许多在线业务系统，由于业务逻辑处理中出现异常，消息会被重复消费。</p>
<p>若要配置重新消费失败消息的延迟时间，可以配置生产者将消息发送到业务主题和重试主题，并在消费者上启用自动重试。当在消费者上启用自动重试的时候，如果消息没有被消费，那么就会存储到重试主题中，在指定的延迟时间后，消费者会主动接受来自重试主题的失败消息</p>
<p><strong>订阅模式</strong></p>
<p>Pulsar支持exclusive （独占） failover（灾备） shared（共享） 和 key_shared（Key共享）四种消息订阅模式，示意图如下<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231688042-eeae1153-5dd6-4257-ab60-8b8514176129.png"></p>
<p><strong>独占模式</strong><br>默认的消息订阅模式。只能有一个消费者消费消息<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231855780-0822f566-06df-4dd8-8bdd-3c1d7284dfa1.png"></p>
<p><strong>灾备模式</strong><br>灾备模式下，一个topic也是只有单个consumer消费一个订阅关系的消息，但是在这个模式下，每个消费者会被排序，当前面的消费者无法连接上broker后，消息会由下一个消费者进行消费<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231915296-3eed9904-91c2-43b4-b850-2b53441c8fe4.png"><br><strong>共享模式</strong><br>共享模式下，消息可被多个consumer同时消费，无法保证消费的顺序，消息通过roundrobin的方式投递到每一个消费者<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231969316-adf66ecb-d07a-49d5-aff9-33594197eefa.png"><br><strong>key共享模式</strong><br>按照key对消息进行投递，相同的key的消息会被投递到同一个consumer上，消费示意图如下<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682232008012-741758f7-8650-4ae5-a9c9-63bcdb815600.png"></p>
<p><strong>消息保留与过期</strong><br>默认策略</p>
<ul>
<li>立即删除所有被消费者确认过的消息</li>
<li>以backlog的形式，持久化保存所有未被确认的消息</li>
</ul>
<p>两个特性</p>
<ul>
<li>消息保留可以让你保存consumer确认过的消息</li>
<li>消息过期可以让你给未被确认的消息设置ttl</li>
</ul>
<p>消息保留和过期是针对namesapce层面进行设置和管理的</p>
<p><strong>消息去重</strong></p>
<p>实现消息去重的一种方式是确保消息只生产一次，即生产者幂等，这种方式的缺点在于把消息去重的工作交给应用来做。<br>在pulsar中，broker支持配置开启消息去重，用户不需要主动在代码中保证Producer只生产一次，启动之后即使消息被多次发送到topic上，也只会被持久化到磁盘一次</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682240083542-ca650a22-889b-4906-be94-014ecf18debe.png"></p>
<p>原理：Producer对每一个发送的消息，都会采用递增的方式生成一个唯一的sequence ID，这个消息会放在message的元数据中传递给broker。</p>
<p>同时，broker也会维护一个pendingmessage队列，当broker返回发送成功ack之后，producer会将pendingmessage队列中的sequence id删除，标识producer任务这个消息生产成功。</p>
<p>broker会记录针对每个producer接受到的最大sequence id和已经处理完的最大sequence id</p>
<p>当broker开启消息去重之后，Broker会针对每个消息请求进行是否去重的判断，如果消息重复，则直接返回ack，不走后续存储的流程</p>
<p><strong>延时消息</strong></p>
<p>延时消息功能允许Consumer能够在消息发送到topic之后，过一段时间之后才能消费到这条消息。在这种集中中，消息在发布到broker之后，会被存储在book keeper中，当到消息特定的延迟时间时，消息就会传递给consumer</p>
<p>broker不会在存储的时候做特殊处理，而是会把设置了延迟时间的消息加入到DelayedDeliveryTracker中，当到了指定的发送时间时，Tracker才会把这条消息推送给消费者</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243085046-f38a72f7-331c-432c-b990-e8de4b438bc4.png"><br>原理：</p>
<p>在Pulsar中有两种方式实现延迟消息，分别为deliverAfter和deliverAt</p>
<p>deliverAfter可以指定在多长时间之后进行消费</p>
<p>deliverAt可以指定具体的延迟消费时间戳</p>
<p>DelayedDeliveryTracker会记录所有需要延迟投递的消息的index，index由timestamp、 ledger id 、和entry id三部分组成，其中ledger id 和 entry id用来定位该消息</p>
<p>timestamp除了记录需要投递的时间，还用于延迟优先级队列排序。tracker会根据延迟时间对消息进行排序<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243400607-7ce2e51a-9fc5-48bd-a1be-dfa226eb2fd7.png"></p>
<p><strong>多租户模式</strong></p>
<p>Pulsar的云原生架构天然支持多租户，每个租户下还支持多Namespace，非常适合做共享大集群，方便维护。此外Pulsar天然支持租户之间的逻辑隔离，防止互相干扰，还能实现大集群资源的充分利用</p>
<ul>
<li>Tenant（租户）和 Namespace是Pulsar支持多租户的两个核心概念</li>
<li>在租户级别，Pulsar为特定的租户预留合适的存储空间、应用授权和认证机制</li>
<li>在namespace级别，Pulsar有一系列的配置策略（policy），包括存储配额、流控、消息过期策略等等</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243577968-08304a97-3d76-453a-85a1-10a8ab01388e.png"></p>
<p><strong>统一消息模型</strong></p>
<p>Pulsar做了队列模型和流模型的统一，在topic级别只需要保存一份数据，同一份数据可多次消费。以流式、队列等方式计算不同的订阅模型，大大的提升了灵活度</p>
<p>同时Pulsar通过事务采用Exactly-Once刚好一次的语义，在进行消息传输过程中，可以确保消息不重不丢<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682244903659-cac62393-1696-488c-bf90-160904556ea4.png"></p>
<p><strong>分片流</strong></p>
<p>Pulsar将无界的数据看作是分片的流，分片分散存储在分层存储（tiered storage）、BookKeeper集群和Broker节点上，而对外提供一个统一的、无界数据的视图</p>
<p>不需要用户显示迁移数据，对用户无感知，减少存储成本并保持近似无限的存储<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682301934196-2cc57808-2996-478a-a2af-458ebb95ce7e.png"></p>
<p>跨地域复制</p>
<p>Pulsar中的跨地域复制是将Pulsar中持久化的消息在多个集群之间备份<br>在Pulsar2.4.0中新增了复制订阅模式，在某个集群失效情况下，该功能可以在其他集群恢复消费者的消费状态，从而达到热备模式下的消息服务高可用<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682302140012-861fac45-f4a9-40a3-a11a-e843e0093230.png"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>单个Pulsar集群由以下三部分组成</p>
<ul>
<li>一个或者多个broker 用于负责处理和负载均衡producer发出的消息 并将这些消息分派给consumer。Broker 和 Pulsar配置存储交互来处理相应的任务，并将消息存储在BookKeeper实例中（bookies）；Broker底层依赖的是Zookeeper集群来处理特定的任务</li>
<li>包含一个或者多个bookie的BookKeeper负责消息的持久化存储</li>
<li>一个ZooKeeper集群用来处理多个Pulsar集群之间的协调任务</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682307910434-a21873d5-4aea-4273-a704-33f2b20b5c06.png"></p>
<p>Pulsar分离出Broker和Bookie两层架构，Broker为无状态的服务，用于发布和消费消息，而BookKeeper专注于存储，Pulsar存储是分片的，这种架构可以避免扩容时受到限制，实现数据的独立拓展和快速恢复</p>
<p><strong>Brokers</strong><br>Pulsar的broker是一个无状态的组件，主要负责运行另外的两个组件</p>
<ul>
<li>一个HTTP服务器（service discovery） 它暴露了REST系统管理接口以及在生产者和消费者之间进行Topic查找的API</li>
<li>一个调度分发器（Dispatcher） 它是一个异步的TCP服务器 通过自定义二进制协议应用与所有相关的数据传输</li>
</ul>
<p>出于性能考虑，消息通常从Managed Ledger缓存中分派出去，除非积压超过缓存大小。如果积压的消息对于缓存来说太大了，则Broker开始从BookKeeper中读取Entries</p>
<p>为了支持全局Topic异地复制，Broker会控制Replicators追踪本地发布的条目</p>
<p><strong>ZooKeeper元数据存储</strong></p>
<p>Pulsar使用ZooKeeper进行元数据存储、集群配置和协调</p>
<ul>
<li>配置存储Quorum存储了租户、命名空间、和其他需要全局一致的配置项</li>
<li>每个集群有自己独立的本地ZooKeeper保存集群内部的配置，例如broker负责哪几个主题及所有权归属元数据、broker负载报告ledger元数据等等</li>
</ul>
<p><strong>BookKeeper持久化存储</strong></p>
<p>Apache Pulsar为应用程序提供有保障的信息传递，如果消息成功到达broker，就认为其预期达到了目的地</p>
<p>为了提供这种保证，未确认送达的消息需要持久化直到它们被确认送达。这种消息传递模式通常成为持久消息传递，在Pulsar内部，没分新消息都被保存并同步N份</p>
<p>BookKeeper是一个分布式的预写日志（WAL）系统，有如下几个特性</p>
<ul>
<li>使得Pulsar能够利用独立的日志，称为ledgers，随着时间的推移可以为topic创建多个ledgers</li>
<li>保证多系统挂掉时的ledgers的读取一致性</li>
<li>提供不同Boookies之间均匀的IO分布的特性</li>
<li>容量和吞吐量都具有水平伸缩性，能够通过增加bookies立即增加容量到集群中</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682317442354-57387d85-94bc-47b5-8615-f2bcb012be42.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">分布式系统常见设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-28 19:01:56 / 修改时间：20:21:39" itemprop="dateCreated datePublished" datetime="2023-05-28T19:01:56+08:00">2023-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="分布式核心要素"><a href="#分布式核心要素" class="headerlink" title="分布式核心要素"></a>分布式核心要素</h2><p>通常来说设计分布式系统的时候最需要考虑的核心要素有五个<img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1683861835454-74e0183d-3ca1-4b94-8706-da6de1c125b7.png"></p>
<ul>
<li>Capacity 容量（能力） 指的是分布式系统里的CPU 内存 硬盘 网络 文件描述符 socket连接数等等硬性的指标</li>
<li>Perfomant 性能 指的是IOPS TPS QPS Latency Jitter之类的性能指标要求，性能受限于容量，性能同时又影响了可靠性以及可用性</li>
<li>Availablility 可用性 指的是产品或者服务在随机事件内调用时处于可服务状态的概率 也就是正常运行的时间&#x2F;总时间 之前说的异地多活也是为了保证可用性而出现的</li>
<li>Reliability 可靠性 一般是不出故障的概率 通常企业级产品是5个9打底的 可以简单的和可用性划上约等号</li>
<li>Scalability 可伸缩性 指的是处理集群能否动态缩扩容  使得处理能力越来越多和越来越少的某种能力 系统的可伸缩性决定了该系统能不能伸缩</li>
</ul>
<p>一个分布式系统通常会面临以下几个个难题：<strong>故障传播性、业务拆分与聚合、以及分布式事务</strong></p>
<p>为了解决故障传播性的难题，我们可以采用”隔板” “熔断” “降级” “限流” “容错”以及”资源管控”等方式</p>
<h2 id="微服务服务治理几大模式"><a href="#微服务服务治理几大模式" class="headerlink" title="微服务服务治理几大模式"></a>微服务服务治理几大模式</h2><h3 id="隔板模式"><a href="#隔板模式" class="headerlink" title="隔板模式"></a>隔板模式</h3><p>场景：<br>在分布式系统中通常将进程容器化 以进行资源隔离，然后在同一个进程中的所有业务都共享线程池，对外提供服务，但是这就导致了会经常遇到这样的问题：</p>
<ol>
<li>业务A负载较高，抢占了线程池里的大部分线程资源，从而导致其他业务的服务质量下降</li>
<li>同一个进程内新加一个业务，这个业务会抢占其他业务的资源，可能会造成系统的不稳定，比如业务性能抖动</li>
<li>难以调试，多个业务共享一个线程池，当出现故障的时候很难通过简单的日志判断是哪个业务出了问题</li>
</ol>
<p><strong>隔板模式：在分布式系统里进行资源的隔离，资源隔离通常按照业务粒度分为进程级别和线程级别</strong></p>
<p>进程隔离：通常使用的是容器化进行隔离，比如通过docker实现业务进程之间的资源隔离，底层就是通过namespace实现的操作系统级别的隔离，比如隔离进程、网络、通信等等。cgroup实现的硬件层面的隔离，比如CPU、内存等等。具体实现笔者之前的博客有提到</p>
<p>线程隔离：指给每个跑在进程里的业务按照业务类型创建一个线程池，从而实现线程级别粒度的资源隔离</p>
<p>优势：</p>
<ul>
<li>提高业务可靠性，减少业务受其他业务影响的程度，当一个业务耗尽自身资源后也不会影响到其他业务的服务质量</li>
<li>降低新加入的业务给系统带来的风险，减少新加业务导致其他业务可能出现的性能抖动</li>
<li>利于调试，通过线程池可以很方便的定位是哪个服务出了故障，并且可以通过监控线程池的请求失败次数、超时次数、拒绝请求次数等可以实时反应当前的业务质量</li>
</ul>
<p>劣势：</p>
<p>粒度更细，很容易就能想到劣势是引入了额外的开销，具体开销的点如下</p>
<ol>
<li>对象分配 创建多个线程对象</li>
<li>并发 可能会有一些竞态问题 为了避免竞态问题 则必须进行并发控制</li>
<li>线程的切换开销 操作系统层面的开销</li>
</ol>
<p>这些开销对于整个系统或者业务来说，一般开销不会特别大，在一些要求不苛刻的场景可以忽略</p>
<p><strong>微服务限流三大件：熔断、降级、限流</strong></p>
<h3 id="熔断模式"><a href="#熔断模式" class="headerlink" title="熔断模式"></a>熔断模式</h3><p>场景：</p>
<p>1.系统负载突然过高，比如突发的访问量、过多的请求以及IO压力过载都可能会造成某个节点故障，比如节点A，然后节点A挂了，又把负载传给节点B，节点B负载过高之后又挂了，这样一连串的挂过去就会把请求从单点故障转化成为系统级别的级联故障</p>
<p>2.我们希望在一个服务出现故障的时候，能够在一段时间内恢复，在请求被拒绝一段时间后再自动的去探测服务的可服务性</p>
<p>熔断模式:也称为断路器模式，当系统里的响应时间或者异常比率或者单位异常数超过某个阈值的时候，比如超时次数或者重试次数超过某个阈值，就会触发熔断，接着所有的调用都快速失败，从而保证下游系统的负载安全。</p>
<p>在断开一段时间之后，熔断器又试着让部分请求负载通过，如果这些请求成功，那么断路器就恢复正常，如果继续失败，那么就关闭服务，立刻返回失败，接着继续这个过程直到重试的次数超过一定的阈值，从而触发更加严重的”降级模式”<br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1683863302221-44d7f526-afa7-44d0-9e61-1a71b3036685.png"><br>具体过程如下</p>
<ul>
<li>熔断器开始处于闭合状态，如果达到触发条件，那么熔断器就会打开</li>
<li>接着熔断器处于打开状态，所有走到这个路径里的请求会走快速失败通道，从而避免负载下行，给下游的服务造成压力，过一个时间周期之后会自动切换到半打开状态</li>
<li>半打开状态：认为之前的错误可能已经被修复了，因此允许通过部分请求试着看看能不能处理成功，如果这些请求处理成功，那么就认为之前导致失败的错误已经被修复，此事熔断器就切换到闭合状态，并且将计数器重置。如果这些试着发送的请求还是失败，则认为之前的问题没有解决，熔断器切回到打开模式，然后开始重置计数器给系统一定的时间来修复错误</li>
<li>接着重复以上过程，直到半打开状态重复的次数达到一定的阈值发现错误还没被修复，从而触发”降级”状态</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="降级模式"><a href="#降级模式" class="headerlink" title="降级模式"></a>降级模式</h3><p>场景：</p>
<p>1.某些时候系统会遇到负载过高的问题，当系统外来的或者内部的负载过高，超过预先定义的阈值，为了保证更加重要的业务的服务质量，希望将一些非核心的业务降低服务质量，从而释放一些额外的资源给紧急业务使用。<br>比如一个分布式系统里的读、写、数据校验、空间回收都比较消耗资源，在业务高峰期为了保证读和写的服务治理，可以把数据校验的服务通过限流或者减少线程数之类的方式，使得该服务能够调用的资源配额减少，从而释放部分资源给读和写使用，保证读写的服务质量。</p>
<p>同样，在读和写业务不繁忙的时候，降低业务的资源配额，从而释放资源给空间回收使用。通过这种方式动态调整局部业务的服务质量从而保证关键业务的服务治理，提升用户体验。</p>
<p>2.在云服务中”可用性”是一个很重要的指标，所以我们希望分布式的系统尽可能稳定，不管出现怎么样的故障，都能过保持基本的可用性</p>
<p><strong>降级模式</strong>：</p>
<p>可以从故障处理和系统服务质量两个角度理解降级模式</p>
<p>从故障处理角度来说，服务降级就是这一功能或者服务直接不可用。</p>
<p>而在动态调整系统整体的服务质量的时候，降级是降低某些当前非重要或者非核心业务的资源，从而释放部分资源给重要的或紧急的业务使用</p>
<p>故障处理:是比熔断更加严重的故障处理方式，最后拿来兜底用的。</p>
<p>比如某个功能出故障，”熔断”是还有希望将这个功能救活。而”降级”是发现救了几次没活之后，直接砍掉这个服务，保证服务整体不出问题</p>
<p>系统服务质量：分为读功能降级、写功能降级、级联组件降级，还有自动降级或者人工降级。比如在云服务里，为了保证高可用性，在出现系统级的故障后，可以把写功能降级，就是这个服务状态变为只能读、只能查询而不能写。</p>
<p>因此在设计的比较好的云服务里，按时间的纬度来度量可用性已经没有了太大的意义，因为不管怎样服务都是可用的，系统都是活着的，起码部分服务可用，因此在云服务里更合理的新的衡量可用性的指标是请求失败比率，即哪些服务不能对外提供能力，占比具体为多少</p>
<p><strong>降级设计思路</strong></p>
<p>触发策略</p>
<ul>
<li>超时降级：在超时重试的次数达到一个阈值后就触发降级</li>
<li>失败比率重试：当某个服务的失败比率达到一定比率后开始降级</li>
<li>系统故障降级：比如网络故障，硬盘故障，电源故障，服务器故障，数据中心故障等等</li>
<li>限流降级：某些访问量太大的场景会触发限流，当达到限流的阈值后，请求也会被降级</li>
<li>重要业务救急：比如为了保证读或者查询的功能，降低写、数据校验的资源配额</li>
</ul>
<p>降级处理</p>
<ul>
<li>资源配额调度，调度不紧急的业务支援紧急的重要的业务</li>
<li>抛出异常，直接抛出异常，打印出错误日志，然后就不管了，请求会丢失，这在需要保证幂等性的请求里不太合适</li>
<li>直接返回，直接返回拒绝服务，这里请求也会丢失，这在需要保证幂等性的请求里不太合适</li>
<li>调用回退方法，调用出现服务降级时对应的业务处理逻辑，不同场景降级的逻辑不一样，比如可以把请求挂在等待队列里继续重试之类，这里需要根据业务场景合理设计回退方法</li>
</ul>
<p>服务降级策略</p>
<p>可以把降级的等级分为几个层次，比如PO P1 P2 P3等等，等级越高表示问题越严重</p>
<p>1.重要业务救急降级可以定义为P0级，只是调度次要的资源去救急，不会出现故障</p>
<p>2.限流降级可以定义为P1 ，只是为了保证服务质量，而且如果不限流可能会出现系统负载过高从而出现故障</p>
<p>3.超时&#x2F;失败比率降级以及失败比率可以定义为P2 出现小范围故障 而不蔓延不传播</p>
<p>4.系统故障级别可以定义为P3级别 此事可以只保证最低资源的读请求服务</p>
<p><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684126379204-895914b1-588c-4da6-9a9e-32cf62ea07a4.png"><br>通常来说，分布式系统中每个服务的配置信息会保存在一个配置中心里，这个配置中心里可以有有每个服务的开关信息以及一些重要的资源配置信息。通过动态调整服务的配置信息，比如降级触发策略、降级处理措施、降级分级策略等来实现服务降级功能。</p>
<p>分布式配置中心：管理各个服务的各种配置信息，包括但不限于以下内容</p>
<ol>
<li>应用程序的基本配置参数，如数据库连接信息、日志级别、缓存配置等等</li>
<li>服务之间的调用配置，如远程服务的地址、超时设置、负载均衡策略等等</li>
<li>业务规则的配置，如业务策略、规则、权限等等</li>
<li>动态特性的配置，如开关、AB测试等等</li>
<li>系统的降级策略配置，如降级的规则，降级处理的方式等等</li>
</ol>
<p>具体的实现可以如下，在配置中心定义一个降级策略的配置项，然后在系统中读取该配置项并根据其值进行对应的降级处理。</p>
<p>参照上文，可以定义一个<code>DegradeStrategy</code>配置项，值为NULL P0 P1 P2 P3几个常量中的一个，在程序代码中读取加载该配置，分为以下几种情况进行请求的处理</p>
<ul>
<li>NULL 不进行降级处理</li>
<li>P0 走业务备用逻辑</li>
<li>P2 采用模拟的数据 或者缓存的数据进行响应</li>
<li>P3 直接返回错误</li>
</ul>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>动机:</p>
<p>可靠性：每个系统都有自己的容量限制，也就是说能够处理的业务请求能力是有限的，如果不控制这些输入的请求数，突发输入过多的请求量会造成过度的资源竞争从而引发系统故障降低系统的可靠性</p>
<p>可用性：限流有利于控制系统资源的消耗速率，有利于过载保护保证业务资源不被耗尽</p>
<p>流量监管：对输入的请求流量进行细粒度的控制，通过监管输入的请求量速率对超出的部分进行惩罚，比如直接丢弃，使得进入系统的请求量被限制在一个系统所能承受的合理的范围之内，流量监管比较适合对延时要求较高的业务</p>
<p>流量整形：控制最大输出请求速率，以确保请求量符合系统容量配置的最大传输速率规定。请求的流量被整形进行平滑处理，以使它符合下游服务的速率需求，流量整形比较适合可靠性要求较高的业务</p>
<p>流这个词在不同上下文的含义是不一样的</p>
<ul>
<li>网络限流：带宽、流量</li>
<li>IO限流：TPS QPS</li>
<li>并发限流：并发请求数</li>
<li>线程限流：线程数</li>
</ul>
<p>限流处理策略</p>
<ul>
<li>直接拒绝：当请求量超过阈值之后，新的请求就会被直接拒绝，方式为直接返回或者抛出异常。这种方式比较适合对分布式系统的负载容量已知的情况下，比如通过全链路压测已经确定了准确的系统处理能力以及系统容量</li>
<li>冷启：当分布式系统长期处于低负载的情况下，请求量突发的时候，会把请求负载很快拉到很高的水准，这样可能瞬间就把系统击垮。通过”冷启”的方式，让输入的请求量缓慢增加，慢慢增加到阈值附近，对应的是令牌桶算法</li>
<li>匀速排队：系统流量均匀，对应漏桶算法</li>
</ul>
<h3 id="纵向限流"><a href="#纵向限流" class="headerlink" title="纵向限流"></a>纵向限流</h3><p>两窗算法+两桶算法（固定窗口、滑动窗口）+（令牌桶、漏桶）<br>按照工作原理又可以划分为 保险丝模式和变压器模式</p>
<p><strong>保险丝与两窗算法</strong></p>
<p>保险丝：<br>电路中的保险丝主要是起电流过载保护作用，当电路中的电流过载的时候，保险丝自身就会烧坏从而切断电流，保护后续电路的安全运行。</p>
<p>这与限流算法中的窗口算法原理类似，在拒绝请求之后，需要重新设置计数，因此我们定义它们为限流保险丝模式</p>
<p><strong>固定窗口：</strong><br>按照时间线划分成一个个固定大小的时间窗口，并且每个窗口都有一个计数器来统计这一时间窗口内的访问次数，如果访问的次数超过了一个预先定义的阈值，则拒绝接下来的请求。直到下一个时间窗口，开始重新计数，当计数器又超过则继续拒绝，再在下一个时间窗口重新设置计数器继续计数，依次类推……<br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684144150603-cb27b827-a2f7-4495-93bf-d7815189462e.png"><br>优点： 实现简单 一个计数器就可以实现</p>
<p>缺点有边界场景和跨窗口场景两个点，前者导致流量不均，可能有时候无法处理某些请求；后者导致流量可能超过阈值而带来风险</p>
<p><strong>边界场景：</strong></p>
<p>在第一个[0,5]的时间窗口内，第一秒就把计数器打到超过500，则后续的四秒将无法服务，得等到下一个[5,10]的时间窗口内计数器才被重置为0，才可以对外提供服务</p>
<p><strong>跨窗口场景：</strong></p>
<p>当第一个时间窗口的[4,5]的计数器为300，没有超过阈值，然后第二个时间窗口的[5,6]计数器为320，也没超过阈值，但是在[4,6]的时间窗口内计数为620 超过阈值，可能带来风险</p>
<p><strong>滑动窗口：</strong></p>
<p>也类似于固定窗口的计数器，不过将窗口按照时间线做了进一步的划分，每次往后移动一个细分单元，再每次都对一个小窗口进行计数统计实现流量控制。比如刚刚上图，把窗口的大小从5S缩小到1S，且会自动按照时间线进行移动</p>
<p>能很好的规避掉跨窗口场景 但是对边界场景还是会不太平滑 不过也比固定窗口好很多了</p>
<p><strong>变压器与两桶算法</strong></p>
<p>变压器指的是将电路中某一等级的电压或电流转换成另外一种同频率的电压或电流的设备，有利于稳流稳压，在计算机中对应的是两桶算法，即漏桶和令牌桶</p>
<p><strong>漏桶</strong></p>
<p><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1684230256857-0cf2d503-19cf-4f57-a00d-853f19f902db.png"><br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684230535467-baa831aa-ae44-48a6-bb69-6ed34a2ec20f.png"><br>漏桶算法工作步骤</p>
<ul>
<li>请求被随意的输入，有突发较多的请求量也有较小的请求量，这些请求进入系统之后不是立马被处理，而是放在一个桶中</li>
<li>当桶了缓冲的请求超过设置的水位时，输入的请求被拒绝进入，直接丢失</li>
<li>桶以恒定的结果将输入的请求输出</li>
</ul>
<p>优点：<br>有利于流量的削峰填谷，且输出总是按照恒定的速率输出，因此有利于流量整形，平滑了突发的请求量</p>
<p>缺点：</p>
<p>1.无法接收突发流量 如果有超过桶设置水位的突发流量会被抛弃 这在幂等性的场景中明显是不适用的 比如支付场景 可能导致支付请求的丢失</p>
<p>2.因为漏桶总是按照恒定速率输出请求（也不是每时每刻都以该速率输出 当某时刻小于到达的请求量设置的输出值的时候 则会比设置值小），这是在假设后续的服务能够承接这个速率的前提之下的，如果无法保证这些输出的请求稳定的在一个固定的时间内处理完，可能会导致后续的服务进行资源抢用，而导致引发更大的级联故障</p>
<p><strong>令牌桶</strong></p>
<p><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684231028939-08b1d426-7b13-466c-b809-eaf439728067.png"><br>工作步骤</p>
<ul>
<li>这个桶每段时间会生成N个令牌</li>
<li>桶子的最大令牌数量有限制</li>
<li>如果有请求到来，则必须先在桶子里面拿令牌，然后进行请求的处理，之后从这个桶子里把令牌删掉</li>
<li>如果桶子里面没令牌，当前请求无法通过，之后重试</li>
</ul>
<p>优点：</p>
<ul>
<li>当桶子里的令牌满了，是丢令牌而不是丢请求，这样可以在幂等性请求的场景使用</li>
<li>可以支持突发的流量</li>
</ul>
<p>缺点：<br>对输出的请求速率没有做限制，有可能会打崩整个系统</p>
<p>算法实践：</p>
<ul>
<li>两窗算法实现比较简单，性能好，但是超出限流阈值之后会直接拒绝请求，适用于非幂等的请求场景</li>
<li>漏桶算法，平滑控制输出的请求速率，但是超出水位的请求会被丢弃，适用于非幂等的请求场景</li>
<li>令牌算法，可以支持突发的请求量，不控制输出的请求速率；超出阈值之后只会丢失令牌但不丢失请求，可以结合在幂等性请求的场景使用</li>
</ul>
<h3 id="横向限流"><a href="#横向限流" class="headerlink" title="横向限流"></a>横向限流</h3><p>纵向限流解决的是某一个服务，一条链路的流量过高的问题，但是并没有解决这几个服务路径之间流量是否均匀分配的问题<br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684237185330-434942f9-556c-4408-a033-1e07b42e87ad.png"><br>横向限流的作用</p>
<ul>
<li>解决限流不均匀问题，尽可能让每个服务之间的流量是均匀的</li>
<li>更细粒度的用户限流问题 限制每个用户（租户）可以进入系统的请求个数，纵向限流只能限制整体的进入网关的请求数，因此需要一个计数中心用于登记每个用户的请求数，从而进行更细粒度的流量控制，控制每个用户的请求数</li>
</ul>
<p>通常是通过一个类似配置中心的方式实现横向限流<br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684310906242-ab5ee73d-8424-4a72-bcdf-c1664abfbf01.png"></p>
<ul>
<li>可以将集群限流服务中心实现在一个网关实例里，与网关一起提供服务，好处是不需要再独立部署一个限流实例，缺点是如果网关挂掉，那么限流服务会一起挂掉，而且无法对网关层面进行横向限流，只实现了各个网关底下的服务的横向限流</li>
<li>也可以独立拉起一个集群限流服务中心实例，用于提供全局限流计数服务，好处是与业务解耦，缺点是在集群内增加了一个额外的服务实例，增加了系统复杂度</li>
</ul>
<p>常见的横向限流算法有计数算法以及时间标签算法</p>
<p><strong>计数算法</strong><br><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684311722641-3c848e47-7c31-4a90-b315-4005325ddf33.png"><br>拉起一个独立的分布式配置中心，在里面实现限流算法，比如两窗、两桶算法用于全局计数，而且保证这个计数是全局唯一的，不管集群规模多大，保证每个服务所使用的计数器和计时器都是唯一的，服务拿到这个计数ID之后再进行限流调度</p>
<p>CP模式：采用独立的限流中心，每个用户进入系统的请求都需要去远程的限流服务中心取一个计数返回，多了一个远程读取限流计数值的过程，会比较影响请求的性能<br>AP模式：本地维护一个限流技术的缓存，起一个独立线程维护，每隔一段时间本地限流缓存和远程进行同步，这种方式牺牲了限流的可靠性，但是保证了请求的性能</p>
<p><strong>时间标签算法</strong></p>
<p>计数算法只是实现了限制用户的请求量的最大值，并不能提供最小值保证，于是基于时间标签的算法被提出</p>
<p>例如在云服务中，用户1和用户2付费不一样，因此提供的最大限流上线是不一样的，但是如果采用计数算法的话并不能保证付费多的用户就一定能得到更高的服务质量保证。因此需要一个可以预留资源的算法</p>
<p><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1_1684312481795-d0a192f0-5fc1-4b3f-bf0f-d14be97ff061.png"><br>思路为：先保证最低的预留值，再根据权重划分剩下的资源，并且保证不要超过最大值。</p>
<p>例如在云服务中，用户1和用户2付费不一样，因此提供的最大限流上线是不一样的，但是如果采用计数算法的话并不能保证付费多的用户就一定能得到更高的服务质量保证。因此需要一个可以预留资源的算法</p>
<p><img src="/2023/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1/1684312481795-d0a192f0-5fc1-4b3f-bf0f-d14be97ff061.png"><br>思路为：先保证最低的预留值，再根据权重划分剩下的资源，并且保证不要超过最大值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">分布式理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-10 22:48:44 / 修改时间：22:51:20" itemprop="dateCreated datePublished" datetime="2023-05-10T22:48:44+08:00">2023-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP是分布式系统方向中的一个非常重要的理论，可以粗略的将它看成是分布式系统的起点，CAP分别代表的是分布式系统中的三种性质，分别是Consistency（可用性）、Availability（一致性）、Partition tolerance（网络分区容忍性），它们的第一个字母分别是C A P，于是这个理论被称为CAP理论</p>
<p>理论上来说，CAP三者同时最多满足两者，但是并不是必须满足两个，许多系统最多只能同时满足0、1个</p>
<p><strong>为什么CAP最多只能满足两个呢?</strong></p>
<p>我们可以以电商系统的两个集群来当做例子</p>
<p>C: 追求的是数据一致性 当有一个请求来了之后 它会等待网络隔离的情况结束之后 向另一个机器进行数据的同步</p>
<p>A: 追求的是可用性 也就是尽可能提供有效服务 当一个请求来了之后 它会立即返回 哪怕数据是陈旧的 也得优先提供服务，其他分区的节点返回的结果（数据）可能是不一样</p>
<p>注意：这里的AP不可同时满足指的是当整个分布式系统中出现网络隔离的时候，我们不能既想着保证数据的实时强一致性，又去追求服务的可用性。</p>
<p>但是当没有网络隔离的时候，其实这两个性质是可以同时满足的，因为『同步数据』和『返回结果』这两个操作都是在同一个网络中，只有先后关系，不会因为某个操作导致另一个操作的『死等』</p>
<p>在分布式系统中，P是会必然发生的，造成P的原因可能是网络隔离，也可能是节点宕机。我们无法保证分布式系统每一时刻都不出现网络隔离，如果不满足P的特性，一旦发生分区错误，那么分布式系统就无法工作，这显然违背了分布式的理念，连最基本的分布式系统条件都没有满足</p>
<p>典型的CP和AP的产品</p>
<p>CP：Zookeeper 当系统在发生分区故障之后 客户端的所有请求都会被卡死或者超时 但是系统总会返回一致的数据</p>
<p>AP：Eureka 分区发生故障之后 客户端依然可以访问系统 但是获取的数据有的是新数据 有的是老数据</p>
<p>当然  CAP这几个特性不是BOOL类型的，而是一个范围类型，完全是看系统具体需要什么样的要求。</p>
<p>比如分区容错，有的系统一台机器出错，系统会认为不影响业务的话，认为分区不存在。只有多台机器都出问题了，系统受到严重影响才认为出现分区</p>
<h2 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h2><p>PACELC理论是对CAP理论的扩展，在维基百科上的定义是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</span><br></pre></td></tr></table></figure>



<p>如果有分区（P），那么系统就必须在可用性（A）和一致性（C）之间取得平衡，否则（E），当系统运行在无分区的情况下，系统需要在延迟（L）和一致性（C）之间取得平衡</p>
<p>它相比于CAP，多引入了一个延迟Latency的概念，在出现分区错误的时候，取前半部分PAC，理论和CAP的内容一致。没有出现分区错误的时候取LC，也就是Latency与Consistency</p>
<p>当前分布式系统指导理论更替代CAP理论，理由如下</p>
<ul>
<li>PACELC更能满足实际操作中分布式系统的工作场景，是更好的工程实现策略</li>
<li>当P存在的场景下，需要在A C之间做取舍，但是实际上分布式系统大部分时间里P是不存在的，那么在L和C之间做取舍是一个更好的选择</li>
<li>PACELC可以在latency与consistency之间获得平衡</li>
</ul>
<p>要保证系统的高可用，那么就得采用冗余的思想，我的其他博文有提到4个9的异地多活策略，也是采用的数据冗余思想，而一旦涉及到了复制数据，在分布式中就一定会在Consistency和Latency之间做一个取舍</p>
<p><img src="/2023/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1.png" alt="img"></p>
<p>举个例子</p>
<p>在强一致性的场景下，需要三个从节点都落盘数据，才能给客户端返回OK，这个时候当master向slave同步数据的时候，超过20ms触发超时了，整个系统还是会不断的重试这个过程，这显然造成了系统的可用性比较低</p>
<p>所以我们一般都会在数据一致性和请求时延之间做一个balance </p>
<p>当同步超过五次之后，认为这个节点故障，选择直接返回，可以消除写时的长尾抖动，同时给节点打上故障标签，进行后续的处理</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>base理论是Basically Avaliable(基本可用)、Soft State（软状态）、Eventually Consistent（最终一致性）三个短语的缩写，核心思想如下</p>
<p>即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</p>
<p>BA：基本可用指的是当系统出现了不可预知的故障，系统依旧可用，不过可用度也许会降低，比如响应时间上出现损失，功能上只能满足基本功能等等</p>
<p>S：基于原子性而言的话，当要求多个节点数据一致时，我们认为这是一种『硬』状态，而允许系统中的数据存在中间状态，并认为其不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据时延</p>
<p>E：最终一致性，系统不可能一直都处于一个软状态中，必须有个时间期限。在期限过后，应该保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于时延、负载、方案等等</p>
<p>在工程实践中，有这么几种最终一致性的实现策略，通常都是多种策略混合实现</p>
<ul>
<li>因果一致性：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。与此同时，与节点A无因果关系的节点C的数据访问没有这样的限制</li>
<li>读已知所写：节点A更新一个数据之后，自身总是能访问到更新过的最新值，而不会访问旧值</li>
<li>会话一致性：将对系统数据的访问过程框定在了一个会话当中，系统能保证同一个有效的会话中实现客户端在一个会话中读取到该数据项永远是最新值</li>
<li>单调读一致性：如果一个节点从系统中读取出一个数据项的某个值之后，那么系统对于该节点后续的任何数据访问都不该返回更旧的值</li>
<li>单调写一致性：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</li>
</ul>
<h2 id="NWR多数派理论"><a href="#NWR多数派理论" class="headerlink" title="NWR多数派理论"></a>NWR多数派理论</h2><p>NWR多数派理论指的是在多数副本的一致性模型中，只有大多数副本确认了某个操作，才认为这个操作已经完成。这个理论是分布式系统中一种常见的一致性模型，被广泛应用于保证数据的一致性和可靠性，以及系统的可用性。</p>
<p>NWR中N代表的是副本数量，W代表写入的副本数量，R则为读取的副本数量。在多数的一致性模型中，一般要求W+R&gt;N，以保证读写操作的一致性。在写入操作的时候，只有W个副本被成功写入才返回成功，而在读取操作时，只有R个副本成功返回相同的数据才返回成功。这样，只要大多数副本成功确认了操作，就可以认为这个操作已经完成。</p>
<p>NWR在现有组件的应用还是很广泛的，比如Raft选主判断逻辑为投票数量&gt;&#x3D;n&#x2F;2则成功选主，比如Redis的哨兵机制，有哨兵标记下线则为主观下线，&gt;&#x3D;n&#x2F;2标记下线则为客观下线。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">流媒体技术初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-09 08:06:36 / 修改时间：08:12:38" itemprop="dateCreated datePublished" datetime="2023-05-09T08:06:36+08:00">2023-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="什么是视频资源"><a href="#什么是视频资源" class="headerlink" title="什么是视频资源"></a>什么是视频资源</h2><p>所谓视频资源，在播放和底层存储的时候其实就是一张一张图，30帧为一秒三十张图，60帧为一秒60张图等。一连串的图片按照一定帧率播放出来，刚开始的时候没有声音，所以音频信息就需要在各个帧进行精确设置，播放才能够音画同步。</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流媒体：</p>
<p>计算机科技在历经了文件（File）、页面（Web）时代之后，今天来到了以流（Streams）为单位的时代，而这个流的最典型的应用就是“流媒体”技术，它指的是在网络上采用流式传输技术来发布音频、视频以及其他多媒体文件。</p>
<p>所谓的流式传输就是将音频、视频多媒体文件经过一定的算法，编码压缩成一个个很小的压缩包，流媒体服务器通过特定网络协议进行连续、实时的传送，用户端接受到压缩包后由播放软件实时解压缩实现播放的过程。而所谓的流媒体则特指一切采用这种流式传输的媒体文件。</p>
<p>今天我们通过互联网看视频、直播、盒子看电视算如此方便，背后就有着流媒体系统的支撑。</p>
<p>在对于音视频的传输分发上，我们会经常听到HTTP渐进式、HTTP流、文件下载、实时流式传输等等专业术语，下表总结了不同传输方式的特点</p>
<p><img src="/2023/05/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%88%9D%E8%AF%86/1.png" alt="image.png"></p>
<p>需要完成一个支撑高体验大规模的流媒体系统，需要考虑的技术层面有</p>
<ol>
<li><p>云计算基础服务相关技术：基于云架构的计算、网络、存储、CDN等底层基础服务已经变成了必须。硬件虚拟化、网络虚拟化能够最大程度保障音视频播放的稳定性；同时CDN内容分发网络能够有效应对高并发和徒增流量的需求，对流媒体传输的所有环节进行针对性优化，大幅度降低延时，对象存储满足了流媒体数据的大规模存储要求</p>
</li>
<li><p>音视频相关技术：音视频的编解码、4K、VR等音视频核心技术能力</p>
</li>
<li><p>场景化需求：秀场娱乐直播的实时录制，实时水印，实时鉴黄；连麦，版权保护等等</p>
</li>
</ol>
<h2 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h2><p>Youtube是如何存储海量音视频数据的？</p>
<p>Youtube是仅次于谷歌的第二大热门网站，在19年5月，每分钟会有500小时的视频内容上传到该平台</p>
<p>架构</p>
<p><img src="/2023/05/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%88%9D%E8%AF%86/2.png" alt="image.png"></p>
<p>Youtube的后端微服务是由Python Java 和Go 写的，而前端是使用JS写的，主要的数据库是由Vitess支持的MySQL，另外使用Memcache实现了缓存，并使用Zookeeper进行节点的协调</p>
<p>流行的视频通过CDN来提供，而一般的、较少播放的视频则从数据库中获取</p>
<p>视频压缩：能够使用其他编码器一半的带宽来编码视频</p>
<p>视频流：使用基于HTTP协议的动态自适应流，可以按照不同的速率提供给观众，客户端通过观看者的互联网速度自动适应视频渲染，从而尽可能少的减少缓冲时间</p>
<p>Vitess的诞生</p>
<p>随着网站越来越大，请求量越来越多，不得不对数据库进行水平拓展</p>
<h3 id="主-从副本"><a href="#主-从副本" class="headerlink" title="主-从副本"></a>主-从副本</h3><p>副本会添加到数据库实例中，读取请求会被路由到主数据库和副本上，其中主节点可写又可读，从节点只可读。</p>
<p>但是这种场景中，有可能会从副本中读取到陈旧的数据，如果在主节点将信息更新到副本之前，一个请求读取了副本的数据，那么观看者就会得到陈旧的数据。但是一般没什么大问题，因为在一段时间的运行后，不同节点的数据会答到最终一致</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>当QPS继续增大，就该对数据库进行分片了，分片并不是一个简单的过程，它大大的增加了系统的复杂性</p>
<p>数据库分片之后，数据被分散到多台机器上，这增加了系统写入的吞吐量，不再是只有一个主节点能承担写的任务，同时，每台机器都创建了单独的副本，以实现冗余和吞吐</p>
<h3 id="灾难管理"><a href="#灾难管理" class="headerlink" title="灾难管理"></a>灾难管理</h3><p>为了防止突然掉电、火灾等情况，需要对数据进行冗余，将用户数据备份到世界不同地理区域的数据中心。丢失用户数据和服务不可用算不允许的。同时拥有多个数据中心也有助于Youtube减少系统延迟，因为用户请求会被路由到最近的数据中心</p>
<h2 id="Vitess"><a href="#Vitess" class="headerlink" title="Vitess"></a>Vitess</h2><p>是一个运行在MySQL之上的数据库集群方案，能够使MySQL进行水平拓展。它具有内置的分片特性，能够让开发人员拓展数据库，而不必再应用中添加任何的分片逻辑。类似于nosql的做法</p>
<p><img src="/2023/05/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E5%88%9D%E8%AF%86/3.png" alt="image.png"></p>
<p>vitess会自动处理故障转移与备份，除了youtube，vitess还被业界的其他知名厂商使用，如github等</p>
<p>当你需要acid事务和强一致性的支持，同时又希望像NoSQL一样快速拓展关系型数据库的时候，Vitess就会大显身手，通过基于go编程提供的连接池，Vitess能够以很低的成本管理大量连接</p>
<p>部署到云中：vitess是云原生的，并且容量是逐步添加到数据库中的。它可以作为一个K8S感知的云原生分布式数据库运行</p>
<h2 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h2><p>视频会存储在谷歌数据中心的硬盘里，由GFS和BigTbale管理， GFS是谷歌开发的一个分布式文件系统，用于管理分布式环境中的大规模数据，而BigTable是建立在GFS上的低延迟分布式数据存储系统，用于处理分布在千万台机器上的PB级别的数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/08/%E9%80%86%E5%90%91%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/08/%E9%80%86%E5%90%91%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">逆向初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-08 00:40:25 / 修改时间：00:59:51" itemprop="dateCreated datePublished" datetime="2023-05-08T00:40:25+08:00">2023-05-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h2><p>基本围绕着输入输出系统（Basic Input&#x2F;Onput System BIOS）展开 </p>
<p>1.开始供电</p>
<p>2.Power On Self Test 检测关键设备是否存在，能否正常运行。如果系统BIOS在这个过程中发现了一些致命错误，比如内存出错或者没有内存，那就会直接控制喇叭来报告错误</p>
<p>3.BIOS选择启动盘 F12可进入选择页面，比如双系统就要这个阶段选择启动的是哪个操作系统</p>
<h2 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h2><p>1.读取硬盘的前512个字节，确定操作系统在磁盘中的位置</p>
<p>2.将操作系统载入内核中</p>
<h2 id="程序的生成和运行"><a href="#程序的生成和运行" class="headerlink" title="程序的生成和运行"></a>程序的生成和运行</h2><p>Java程序：将源代码通过编译器编译成.class类型文件（字节码），这种文件只能通过JVM识别。</p>
<p>运行的时候JVM从.class文件中读一行解释执行一行。Java为了实现跨平台，不同的操作系统对应不同的JVM，也就是说Java前半部分是编译，后半部分是解析，是一种混合型程序</p>
<h2 id="一个C程序的编写到运行过程"><a href="#一个C程序的编写到运行过程" class="headerlink" title="一个C程序的编写到运行过程"></a>一个C程序的编写到运行过程</h2><ol>
<li><p>首先使用编辑器编辑程序源文件（.c .cpp)</p>
</li>
<li><p>源程序经过编译器被编译为等价的汇编代码，再经过汇编器产生与目标平台CPU一致的目标代码，也就是机器码</p>
</li>
<li><p>尽管目标代码的指令已经可以被目标CPU执行了，但是可能还包含没有解析的名称和地址引用，因此需要连接器把目标代码文件和其他的一些库文件及资源文件连接起来，产生可执行的二进制exe文件</p>
</li>
<li><p>当执行.exe文件的时候，windows操作系统会解读链接器记录再可执行程序中的格式信息，然后将代码和数据“放置”在内存中，成为可以运行的内存映像，然后生成一个进程开始运行</p>
</li>
</ol>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>编译器（汇编器）所作的工作主要是翻译工作</p>
<ol>
<li><p>预处理，正式编译之前，通过文件中的预处理指令来修改源文件的内容，包括宏定义指令、条件编译指令、头文件包含指令和特殊符号替换指令等等</p>
</li>
<li><p>编译和优化，通过词法分析、语法分析、语义分析，将其翻译成等价汇编代码，并对其进行优化处理</p>
</li>
<li><p>目标代码生成，将中间代码生成符合当前机器CPU的机器码</p>
</li>
</ol>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>1.宏定义指令： #define，这是最常见的用法，可以定义符号常量，函数，重命名等</p>
<p>2.条件编译指令：#if #ifndef #ifdef #elif 等等，主要进行编译时有选择的一些代码，比如#ifdef 如果宏已经定义，则编译下面代码</p>
<p>3.头文件包含指令：#inlcude 是一种最为常见的预处理，主要是作为文件的引用组合源程序正文</p>
<p>4.特殊符号处理：可以识别一些特殊的符号，预编译程序对于在源程序中出现的这些串将用合适的值进行替换</p>
<h2 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h2><p>链接器的基本功能是：将编译器产生的多个目标文件合成为一个可以在目标平台下运行的文件，这里说的目标平台指的是程序的运行环境，CPU和操作系统等</p>
<p>链接器按照工作模式分为静态链接和动态链接两类</p>
<p>1.静态链接 链接器将函数的代码从其所在地（目标文件或者静态链接库）复制到最终的可执行程序中，整个过程在程序生成的时候完成，静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码，静态链接则是将相关代码复制到源代码相关位置，参与程序的生成。也就是去静态链接库（文件库）中找代码，复制到最终的可执行程序中 </p>
<p>2.动态链接 动态链接库在编译链接的时候只提供符号表和其他少量信息，用于保证所有符号引用都有定义，保证编译顺利通过。程序执行的时候动态链接库的全部内容将被映射到内存中，根据可执行程序中的信息找到相应的函数地址并调用执行。也就是去动态链接库中全部内容会被映射到内存中，程序通过一些符号表和其他信息找到对应的内容，并进行调用。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>逆向就是在不能轻易获得必要的生产信息下，直接对成品的分析入手，推导出产品的设计原理，主要分为硬件和软件两大部分</p>
<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>将一个目标代码变换为易读形式的过程，一般是在调试器或者工具中加载程序，然后一边运行程序一边对程序的行为进行观察和分析，这些调试器或者调试工作包括：IDE，著名工具OllyDbg等等</p>
<p>缺点：</p>
<p>- 严重依赖输入</p>
<p>- 可能因为环境原因，无法运行目标程序</p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>不执行代码，而是通过反汇编、反编译等工具，将程序的二进制代码翻译成汇编语言，之后再进行分析。常用工具有IDA Pro，C32Asm等等</p>
<p>缺点</p>
<p>- 程序加壳之后无法反汇编</p>
<p>- 代码混淆甚至于被加密处理</p>
<h3 id="软件逆向的一般过程"><a href="#软件逆向的一般过程" class="headerlink" title="软件逆向的一般过程"></a>软件逆向的一般过程</h3><ol>
<li><p>文件装载进行与目标文件相关的一些初步分析，包括文件格式解析、文件信息搜集和文件性质判定，分析出文件执行入口地址，初步分析文件的数据段和代码段以及文件运行所以来的其他文件信息  </p>
</li>
<li><p>指令解码指令解析，将指令机器码影视各位成为汇编语言</p>
</li>
<li><p>语义映射通过直接代码实现或者工具实现</p>
</li>
<li><p>相关图构造</p>
</li>
<li><p>过程分析</p>
</li>
<li><p>类型分析</p>
</li>
<li><p>结果输出结果输出时逆向分析的最终阶段</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">141k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:08</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
