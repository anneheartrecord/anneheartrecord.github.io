<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">实习求职总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-24 11:08:23 / 修改时间：11:14:10" itemprop="dateCreated datePublished" datetime="2023-02-24T11:08:23+08:00">2023-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前言：其实我是比较喜欢用文字、博客来记录自己的生活，记录自己的一些想法和感悟的，但是之前我一直觉得博客嘛，就应该发一些技术相关的东西，看了很多同龄人的博客我才发现，其实博客可以发的东西有很多很多，不一定要仅限于技术，于是就有了这篇文章。</p>
<p>还记得去年这个时候我还没有开始准备实习，那段时间应该是在完成工作室的考核，现在回头看看其实已经走出去很远了。</p>
<p>下面简单说一下我找实习的几个阶段吧。</p>
<h1 id="stage-one"><a href="#stage-one" class="headerlink" title="stage one"></a>stage one</h1><p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后打算和我的爱人去主城区耍的，然后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，我印象很深的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。</p>
<p>之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。</p>
<p>第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在编程上被认可了，然后就打车去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。</p>
<p>之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装，之后的任务就是写一个分布式消息队列。</p>
<p>差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。</p>
<p>除了工程上的收获之外，我还认识了很多很厉害的大佬，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，在大四的时候就能写出很多很多东西了，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来思考的方面特别多。而且他知识的广度也很大，前端后端嵌入式都会，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐，就不一一说了，食铁兽的氛围是真的挺好的，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。</p>
<h1 id="stage-two"><a href="#stage-two" class="headerlink" title="stage two"></a>stage two</h1><p>差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，差不多准备了两个礼拜之后就开始投递简历了，尴尬的事情来了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是一面挂，拿了一个小厂的offer但是不太想去。</p>
<h1 id="stage-three"><a href="#stage-three" class="headerlink" title="stage three"></a>stage three</h1><p>没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功。做完了就差不多七月底了，八月主要是在陪我的爱人，当时自己也生病了，除了复习八股之外还学了一些gRPC，做了一个简单的分布式系统来巩固知识。九月回校，这时候八股和算法都算比较巩固了，开始了新一轮的投递，两个礼拜下来面了五六家吧，也没有大厂愿意给面试机会，最后拿到了两个offer，分别是通明智云和daocloud，其实更想去daocloud，面试官说做的是容器方向，还能带薪做开源，狠狠的心动了，不过daocloud的给的薪资属实是有点少，算了一下得贴钱实习，于是去了通明智云，在通明智云的实习期间也很舒服，我的leader很信任我直接让我和客户对接，为期三个月的实习确实有真的在做东西学东西，也从同事前辈们身上学到了很多东西，总之是一段很有意义的实习经历。</p>
<h1 id="stage-four"><a href="#stage-four" class="headerlink" title="stage four"></a>stage four</h1><p>差不多十二月的时候，当时考虑到通明这边的实习期快到了，于是开启了新一轮的投递，可能是因为在盘hc，同样的也没有大厂面试机会，一轮面下来也拿了几个小厂的offer，而且待遇也不是很好，做的东西也不太感兴趣，唯一感兴趣的可能是默安科技的云原生开发，但是突如其来的我的爱人与我分手了，当时就不太想去实习了，想回家修养一阵子，于是把offer给拒了，在流程中的面试也给推了。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/1.png" alt="image-20230224111242791"></p>
<h1 id="stage-five"><a href="#stage-five" class="headerlink" title="stage five"></a>stage five</h1><p>年后市场开始复苏了，从一月底开始投递，一共投的也就那么几家吧，最后拿到了百度中台和莉莉丝运维的offer，最后打算去百度。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/2.png" alt="image-20230224111357693"></p>
<h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>从大一确定毕业就业开始，我就很想去大厂实习，但是拿到大厂offer之后也没有很开心，是真的没有波澜，很平淡，和我当时通过食铁兽面试，拿到通明智云的offer一样，非常平淡。也许这就是人生吧，很多事情不要太去追求结果，这样在结果不如意的时候真的会很痛苦，结果如意了也不见得开心，多关注过程，那些奋斗的日子回过头看是真的挺美好的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 14:54:48 / 修改时间：14:57:12" itemprop="dateCreated datePublished" datetime="2023-02-22T14:54:48+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h3 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h3><p>模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，<strong>设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案</strong></p>
<h3 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h3><p><strong>Gang of Four提出了软件设计模式</strong><br>Gof提出的设计模式有23个，包括</p>
<ul>
<li>创建型模式：如何创建对象</li>
<li>结构型模式：如何实现类或者对象的组合</li>
<li>行为型模式：类或者对象怎么交互以及怎样分配职责</li>
</ul>
<p>“简单工厂模式”不属于23种<br>设计模式：GOF的23种+简单工厂模式<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/16.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/17.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" alt="image.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计原则是设计模式的核心思想，一共有七种</p>
<ul>
<li>单一职责原则： 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个</li>
<li><strong>开闭原则</strong>：类的改动<strong>是通过增加代码</strong>进行的，而不是修改源代码</li>
<li>里氏代换原则：任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能</li>
<li><strong>依赖倒转原则</strong>：依赖于抽象（接口），不要依赖具体的实现（类），也就是<strong>针对接口</strong>编程</li>
<li>接口隔离原则：不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去</li>
<li>合成复用原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合</li>
<li><strong>迪米特法则</strong>：<strong>一个对象应当对其他对象尽可能少的了解</strong>，从而降低各个对象之间的耦合，提高系统的可维护性，例如在一个程序中，各个模块相互调用时，通常会提供一个同一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变的时候，不会影响其他模块的使用（黑盒原理）</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>类的职责是单一的，对外只提供一种功能，而引起类变化的原因也应该只有一个<br>在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂<br><strong>一个类对外只提供一种功能</strong><br><strong>实例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 以下代码不遵循单一职责原则，一个类实现了多个功能</span><br><span class="line">// 即一个clothes结构体实现了“工作装扮”和“逛街装扮”两个方法</span><br><span class="line">type Clothes struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (c *Clothes) Style() &#123;</span><br><span class="line">//	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (c *Clothes) Style2() &#123;</span><br><span class="line">//	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	c := Clothes&#123;&#125;</span><br><span class="line">//	c.Style()</span><br><span class="line">//	c.Style2()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 单一职责原则</span><br><span class="line">// 每一个类（结构体）负责一个功能或者一个逻辑</span><br><span class="line"></span><br><span class="line">type ClothesShop struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClothesWork struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesWork) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesShop) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := ClothesWork&#123;&#125;</span><br><span class="line">	c.Style()</span><br><span class="line">	c1 := ClothesShop&#123;&#125;</span><br><span class="line">	c1.Style()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则的核心思想就是当我们添加一个新功能的时候，不是通过修改代码，而是通过增添代码来实现的。<br>如果我们使用接口<code>interface</code>就可以进行一层抽象，然后提供一个抽象的方法供业务进行实现。<br><strong>增加功能的时候去增加代码而不是修改代码</strong><br><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码是平铺式设计 每当添加一个业务就需要增加方法 会导致Banker类越来越臃肿</span><br><span class="line">// 不符合开闭原则  每当有新的功能出现就要对类添加对应功能的代码</span><br><span class="line">// 当Banker业务越多再修改Banker的业务或者添加新业务的时候 出现问题的问题也会越来越大</span><br><span class="line">// 耦合度太高 Banker的职责也不够单一 代码的维护成本与业务的复杂程度成正比</span><br><span class="line"></span><br><span class="line">//type Banker struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Save() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 存款业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Transfer() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 转账业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Pay() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 支付业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 新增的Deal服务</span><br><span class="line">//func (b *Banker) Deal() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 交易业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">// banker := &amp;Banker&#123;&#125;</span><br><span class="line">// banker.Save()</span><br><span class="line">// banker.Transfer()</span><br><span class="line">// banker.Pay()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 开闭原则</span><br><span class="line">// 在Go中的描述就是通过接口实现多态，每个类去实现接口</span><br><span class="line">// 这样的话就能实现一个结果：类的改动是通过增加代码进行的，而不是修改源代码</span><br><span class="line"></span><br><span class="line">type AbstractBanker interface &#123;</span><br><span class="line">   Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SaveBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SaveBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了存款&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加转账功能</span><br><span class="line"></span><br><span class="line">type TransferBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tb *TransferBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了转账&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以基于抽象层进行业务封装-针对interface接口进行封装</span><br><span class="line"></span><br><span class="line">func BankBusiness(banker AbstractBanker) &#123;</span><br><span class="line">   banker.Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sb := SaveBanker&#123;&#125;</span><br><span class="line">   sb.Business()</span><br><span class="line">   tb := TransferBanker&#123;&#125;</span><br><span class="line">   tb.Business()</span><br><span class="line">   BankBusiness(&amp;sb)</span><br><span class="line">   BankBusiness(&amp;tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>在设计一个系统的时候我们可以将模块分成三个层次，抽象层、实现层、业务逻辑层。我们首先将抽象层的模块和接口定义出来，然后通过interface接口的设计依照抽象层依次实现每个实现层的模块，在我们写实现层代码的时候，实际上只需要参考对应的抽象层，实现每个模块。而业务逻辑层也是通过抽象层暴露出来的接口进行实现的，可以使用的方法就是抽象层暴露出来的方法<br><strong>模块与模块之间依赖抽象而不是具体实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码耦合度很高，不满足依赖倒转原则</span><br><span class="line">// 如果要满足张三开宝马，李四开奔驰，就需要重新添加代码</span><br><span class="line">// 如果司机人数为m，汽车数量为n，那么需要编写的方法为m*n</span><br><span class="line"></span><br><span class="line">//type Benz struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Benz) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;Benz is running&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type BMW struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *BMW) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;BMW is runnning&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Zhang3 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (z *Zhang3) DriveBenz(benz *Benz) &#123;</span><br><span class="line">//	benz.Run()</span><br><span class="line">//	fmt.Println(&quot;Zhang3 is driving Benz&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Li4 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (l *Li4) DriveBMW(bmw *BMW) &#123;</span><br><span class="line">//	bmw.Run()</span><br><span class="line">//	fmt.Println(&quot;Li4 is driving BMW&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	benz := &amp;Benz&#123;&#125;</span><br><span class="line">//	zhang3 := Zhang3&#123;&#125;</span><br><span class="line">//	zhang3.DriveBenz(benz)</span><br><span class="line">//	bmw := &amp;BMW&#123;&#125;</span><br><span class="line">//	li4 := Li4&#123;&#125;</span><br><span class="line">//	li4.DriveBMW(bmw)</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Car interface &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Driver interface &#123;</span><br><span class="line">	Driver(car Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">// 每个车子都实现Run方法</span><br><span class="line">// 每个司机都实现Drive方法</span><br><span class="line">// 这样需要实现的方法为m+n </span><br><span class="line">// 而且实现层只依赖于抽象层</span><br><span class="line">type Benz struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Benz) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;Benz is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BMW struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *BMW) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;BMW is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Zhang3 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (z3 *Zhang3) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Li4 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l4 *Li4) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;li4 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var benz Car = new(Benz)</span><br><span class="line">	z := new(Zhang3)</span><br><span class="line">	z.Drive(benz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。<br><strong>使用组合来实现父类方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cat) Eat() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫吃饭&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用继承来实现 添加一个睡觉的方法</span><br><span class="line"></span><br><span class="line">type CatB struct &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CatB) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用组合来添加可睡觉的方法</span><br><span class="line"> </span><br><span class="line">type CatC struct &#123;</span><br><span class="line">	C *Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cc *CatC) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	c := &amp;Cat&#123;&#125;</span><br><span class="line">	c.Eat()</span><br><span class="line">	cb := &amp;CatB&#123;&#125;</span><br><span class="line">	cb.Eat()</span><br><span class="line">	cb.Sleep()</span><br><span class="line">	cc := &amp;CatC&#123;&#125;</span><br><span class="line">	cc.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>依赖第三方进行解耦</strong></p>
<h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p>接口的意义就是实现多态的思想，我们可以根据interface类型来设计API接口，那么这种API接口的适应能力不仅能够适应当下所实现的全部模块，也适应未来实现的模块来进行调用。<code>**调用未来**</code>也许是接口最大的意义所在，良好的架构师可以针对interface进行设计一套框架，在未来的许多年后仍然可以适用</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" alt="image.png"><br>思想就是可以通过添加一层<strong>工厂模块</strong>，来做到业务逻辑层和基础模块层之间的耦合，避免业务逻辑层对基础模块层的直接依赖。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式并不属于GoF的23种设计模式，它是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：</p>
<ul>
<li>工厂：简单工厂模式的核心，它负责创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需要的产品对象</li>
<li>抽象产品：简单工厂模式所创建的所有对象的分类，它负责描述实例所公有的公共接口</li>
<li>具体产品：简单工厂模式所创建的具体实例对象</li>
</ul>
<p>设计模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Fruit interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type Apple struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Apple) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Banana struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Banana) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pear struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pear) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂模块</span><br><span class="line"></span><br><span class="line">type Factory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Factory) CreateFruit(kind string) Fruit &#123;</span><br><span class="line">	var fruit Fruit</span><br><span class="line">	if kind == &quot;apple&quot; &#123;</span><br><span class="line">		fruit = new(Apple)</span><br><span class="line">	&#125; else if kind == &quot;banana&quot; &#123;</span><br><span class="line">		fruit = new(Banana)</span><br><span class="line">	&#125; else if kind == &quot;pear&quot; &#123;</span><br><span class="line">		fruit = new(Pear)</span><br><span class="line">	&#125;</span><br><span class="line">	return fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	factory := new(Factory)</span><br><span class="line">	apple := factory.CreateFruit(&quot;apple&quot;)</span><br><span class="line">	apple.Show()</span><br><span class="line">	banana := factory.CreateFruit(&quot;banana&quot;)</span><br><span class="line">	banana.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>实现了对象创建和使用的分离</li>
<li>不需要记住具体类名，记住参数就可以，减少使用者记忆量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对工厂职责过重，一旦不能工作，系统会受到影响</li>
<li>增加系统中类的个数，复杂度和理解度增加</li>
<li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的逻辑太复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>抽象工厂：工厂的核心，任何工厂类都必须实现这个接口</li>
<li>工厂：具体工厂是抽象工厂的一个实现，负责实例化产品对象</li>
<li>抽象产品：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品：工厂方法模式所创建的具体实例对象</li>
</ul>
<p>简单工厂+开闭原则&#x3D;工厂<br>模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type fruit interface &#123;</span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂类（抽象的接口）</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateFruit() fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基础模块层</span><br><span class="line"></span><br><span class="line">type apple struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *apple) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type banana struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *banana) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type pear struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *pear) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AppleFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *AppleFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(apple)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BananaFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *BananaFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(banana)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PearFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *PearFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(pear)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line">func main() &#123;</span><br><span class="line">	//需求1 需要一个具体的苹果对象</span><br><span class="line">	//需要一个具体的苹果工厂</span><br><span class="line">	var a AbstractFactory</span><br><span class="line">	a = new(AppleFactory)</span><br><span class="line">	//生产一个具体的水果</span><br><span class="line">	var apple fruit</span><br><span class="line">	apple = a.CreateFruit()</span><br><span class="line">	apple.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>不需要记住具体类名，甚至连具体参数都不用记忆</li>
<li>实现了对象创建和使用的分离</li>
<li>系统的可拓展性也变得非常好，不需要修改接口和原类</li>
<li>对于新产品的创建，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加系统中的类的个数，复杂度和理解度增加</li>
<li>增加了系统的抽象性</li>
</ul>
<p><strong>适用场景</strong></p>
<ol>
<li>客户端不知道它所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定创建哪个对象</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。因此，可以将一些相关的产品组成一个“产品族”，从而由同一个工厂来统一生产。</p>
<ul>
<li>抽象工厂：它声明了一组用于创建一组产品的方法，每一个方法对应一种产品</li>
<li>具体工厂：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某在产品等级结构中</li>
<li>抽象产品：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li>
<li>具体产品：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li>
</ul>
<p>模式例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type AbstractApple interface &#123;</span><br><span class="line">	ShowApple()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractBanana interface &#123;</span><br><span class="line">	ShowBanana()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractPear interface &#123;</span><br><span class="line">	ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的工厂</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateApple() AbstractApple</span><br><span class="line">	CreateBanana() AbstractBanana</span><br><span class="line">	CreatePear() AbstractPear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type ChinaApple struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaBanana struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaPear struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ca *ChinaApple) ShowApple() &#123;</span><br><span class="line">	fmt.Println(&quot;china apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cb *ChinaBanana) ShowBanana() &#123;</span><br><span class="line">	fmt.Println(&quot;china banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cp *ChinaPear) ShowPear() &#123;</span><br><span class="line">	fmt.Println(&quot;china pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateApple() AbstractApple &#123;</span><br><span class="line">	var apple AbstractApple</span><br><span class="line">	apple = new(ChinaApple)</span><br><span class="line">	return apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;</span><br><span class="line">	var b AbstractBanana</span><br><span class="line">	b = new(ChinaBanana)</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreatePear() AbstractPear &#123;</span><br><span class="line">	var p AbstractPear</span><br><span class="line">	p = new(ChinaPear)</span><br><span class="line">	return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 需要中国的水果</span><br><span class="line">	//1. 创建中国工厂</span><br><span class="line">	var cF AbstractFactory</span><br><span class="line">	cF = new(ChinaFactory)</span><br><span class="line">	var cApple AbstractApple</span><br><span class="line">	cApple = cF.CreateApple()</span><br><span class="line">	cApple.ShowApple()</span><br><span class="line">	var cBanana AbstractBanana</span><br><span class="line">	cBanana = cF.CreateBanana()</span><br><span class="line">	cBanana.ShowBanana()</span><br><span class="line">	var cPear AbstractPear</span><br><span class="line">	cPear = cF.CreatePear()</span><br><span class="line">	cPear.ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>用于工厂方法模式的优点</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li>
</ol>
<p>缺点</p>
<ol>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了”开闭原则“</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族，可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>产品等级结构稳定。设计完成之后，不会像系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<h3 id="三种工厂的区别"><a href="#三种工厂的区别" class="headerlink" title="三种工厂的区别"></a>三种工厂的区别</h3><ul>
<li>简单工厂：一个工厂负责创建所有产品，违反开闭原则，添加新产品需要修改工厂逻辑，工厂会变得越来越复杂</li>
<li>工厂：一个工厂创建一个产品，系统的可扩展性非常好，无需修改接口和类，但是系统中类的个数变多，复杂度和理解度增加</li>
<li>抽象工厂：一个工厂创建一系列（同一个产品族）的产品，增加新的产品族很方便，无需修改已有系统，符合开闭原则，增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，违背了开闭原则，相当于在工厂方法的模式下进行了折中，如果产品结构等级稳定，那么就相当于完全遵循开闭</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。<br>要解决的问题是：保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。<br>类图：<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//三个要点</span><br><span class="line">// 某个类只能有一个实例</span><br><span class="line">// 它必须自行创建这个实例</span><br><span class="line">// 必须自行向整个系统提供这个实例</span><br><span class="line"></span><br><span class="line">// 总结：一个类永远只能有一个对象，这个对象还能被系统的其他模块使用</span><br><span class="line"></span><br><span class="line">//1. 因为这个类必须保证私有化 所以首字母要小写</span><br><span class="line">type singelton struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 2.指针只能指向这个唯一对象，但是这个指针不能改变方向，也必须小写</span><br><span class="line">var instance *singelton = new(singelton)</span><br><span class="line"></span><br><span class="line">// 3.对外提供一个方法来获取到这个对象 把instance的写权限去掉 只暴露读权限</span><br><span class="line"></span><br><span class="line">func GetInstance() *singelton &#123;</span><br><span class="line">	return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *singelton) DoSomeThing() &#123;</span><br><span class="line">	fmt.Println(&quot;Do something&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := GetInstance()</span><br><span class="line">	s.DoSomeThing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 懒汉式的单例模式:只有被第一次访问的时候 才给instance赋值 平常为nil</span><br><span class="line">// 但是懒汉式可能有并发问题： 同时有两个Getinstance同一时刻首次调用 那么就会出现两个instance 可以加锁解决</span><br><span class="line">// 锁的粒度太大了 可以通过一个uint的标记 使用atomic.LoadUnit函数判断 不用每次访问都加锁</span><br><span class="line">// 或者直接使用sync.Once进行new 这是对atomic.LoadUint的封装</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>单例模式提供了对唯一实例的受控访问</li>
<li>节约系统资源，由于在系统内存中只存在一个对象</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩展性差，单利模式中没有抽象层</li>
<li>单例类的职责过重</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统只需要一个实例对象，比如系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li>
<li>客户调用类的单个实力只允许使用一个公共访问点，除了该节点之外，不能通过其他途径访问该实例</li>
</ol>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Proxy模式又叫代理模式，可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。<br>所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类进行交互</p>
<ul>
<li>抽象主题：真实主题与代理主题的共同接口</li>
<li>真实主题：定义了代理角色所代表的真实对象</li>
<li>代理主题角色：含有对真实主题角色的引用，代理角色通常在客户端调用给真实主题对象之前或者之后执行某些操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct &#123;</span><br><span class="line">	Kind string</span><br><span class="line">	Fact bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line">type Shopping interface&#123;</span><br><span class="line">	Buy(goods *Goods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">type KoreaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ks *KoreaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go korea buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AmericaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AmericaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go america buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AfricaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AfricaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go africa buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 海外代理</span><br><span class="line"></span><br><span class="line">type OverSeasProxy struct &#123;</span><br><span class="line">	shopping Shopping</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) Buy(good *Goods) &#123;</span><br><span class="line">	//1.辨别真伪</span><br><span class="line">	if op.distinguish(good) == true &#123;</span><br><span class="line">		op.shopping.Buy(good)</span><br><span class="line">		op.check(good)</span><br><span class="line">	&#125;</span><br><span class="line">	//2.调用具体需要被代理的Buy方法</span><br><span class="line">	//3.海关安检</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辨别真伪</span><br><span class="line">func (op *OverSeasProxy) distinguish(goods *Goods) bool &#123;</span><br><span class="line">	fmt.Println(&quot;对&quot;, goods.Kind, &quot;进行了辨别真伪&quot;)</span><br><span class="line">	if goods.Fact == false &#123;</span><br><span class="line">		fmt.Println(&quot;发现假货&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return goods.Fact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) check(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;通过海关&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewProxy(s Shopping) Shopping &#123;</span><br><span class="line">	return &amp;OverSeasProxy&#123;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g1 := Goods&#123;</span><br><span class="line">		Kind: &quot;韩国面膜&quot;,</span><br><span class="line">		Fact: true,</span><br><span class="line">	&#125;</span><br><span class="line">	g2 := Goods&#123;</span><br><span class="line">		Kind: &quot;苹果&quot;,</span><br><span class="line">		Fact: false,</span><br><span class="line">	&#125;</span><br><span class="line">	var k Shopping = new(KoreaShopping)</span><br><span class="line">	var p Shopping</span><br><span class="line">	p = NewProxy(k)</span><br><span class="line">	p.Buy(&amp;g1)</span><br><span class="line">	var a Shopping = new(AmericaShopping)</span><br><span class="line">	p = NewProxy(a)</span><br><span class="line">	p.Buy(&amp;g2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.能够协调调用者和被调用者，在一定程度上降低了系统的耦合度<br>2.客户端可以针对抽象主题角色进行编程，符合开闭原则，系统具有姣好的灵活性和可拓展性<br>缺点：<br>1.实现较为复杂<br><strong>适用场景</strong><br>为其他对象提供一种代理以控制对这个对象的访问</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式（Decorator）用来动态地给一个对象增加一些额外的职责，比生成子类实现更加灵活<br>装饰模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用模式的时候，我们常常在一个代理类中创建一个对象的实例。并且当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<ul>
<li>抽象构件：是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方法处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件：它是抽象构建类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">type Phone interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的装饰器，装饰器的基础类</span><br><span class="line"></span><br><span class="line">type Decorator struct &#123;</span><br><span class="line">	phone Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Decorator) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的构件</span><br><span class="line"></span><br><span class="line">type Huawei struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (hw *Huawei) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a huawei phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Xiaomi struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (xm *Xiaomi) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a xiaomi phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MoDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md *MoDecorator) Show() &#123;</span><br><span class="line">	md.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a mo phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMoDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;MoDecorator&#123;Decorator&#123;</span><br><span class="line">		p,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KeDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kd *KeDecorator) Show() &#123;</span><br><span class="line">	kd.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a ke phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewKeDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;KeDecorator&#123;Decorator&#123;p&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var hw Phone</span><br><span class="line">	hw = new(Huawei)</span><br><span class="line">	hw.Show()</span><br><span class="line">	var mo Phone</span><br><span class="line">	mo = NewMoDecorator(hw)</span><br><span class="line">	mo.Show()</span><br><span class="line">	var ke Phone</span><br><span class="line">	ke = NewKeDecorator(hw)</span><br><span class="line">	ke.Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰</li>
<li>具体构建类与具体装饰类可以独立变化，符合开闭</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活激动的解决方案，同时意味着排错也比较困难</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式</li>
</ol>
<h3 id="装饰与代理的区别"><a href="#装饰与代理的区别" class="headerlink" title="装饰与代理的区别"></a>装饰与代理的区别</h3><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<ul>
<li>目标抽象类：定义客户所需接口，可以是具体类也可以是抽象接口</li>
<li>适配器类：可以调用另一个接口，作为一个转换器，让目标抽象类和适配者类进行适配</li>
<li>适配者类：被适配的角色，定义了一个已经存在的接口，这个接口需要适配</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type V5 interface &#123;</span><br><span class="line">	Use5V()</span><br><span class="line">&#125;</span><br><span class="line">type V220 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type phone struct &#123;</span><br><span class="line">	v V5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *V220) Use220V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用220V的电压 &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adapter struct &#123;</span><br><span class="line">	v220 *V220</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Adapter) Use5V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用适配器，以220V的电压充电&quot;)</span><br><span class="line">	a.v220.Use220V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPhone(v V5) *phone &#123;</span><br><span class="line">	return &amp;phone&#123;v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAdapter(v220 *V220) *Adapter &#123;</span><br><span class="line">	return &amp;Adapter&#123;v220&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *phone) Charge() &#123;</span><br><span class="line">	fmt.Println(&quot;Phone 进行了充电&quot;)</span><br><span class="line">	p.v.Use5V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	phone := NewPhone(NewAdapter(&amp;V220&#123;&#125;))</span><br><span class="line">	phone.Charge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都很好，可以很方便地更换适配器，符合开闭原则</li>
</ol>
<p>缺点：<br>适配器中置换适配者类的某些方法比较麻烦<br><strong>适应场景</strong><br>1.系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码<br>2.想创建一个可以重复使用的类，用来与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式(Facade)，为一组具有类型功能的类群，比如类库，子系统等等，提供一个一致的简单的界面</p>
<ul>
<li>外观角色：为调用方，定义简单的调用接口</li>
<li>子系统角色：功能提供方，指提供功能的类群</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">type SubSystemA struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemB struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemC struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemD struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sa *SubSystemA) MethodA() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SubSystemB) MethodB() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method b&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sc *SubSystemC) MethodC() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method c&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sd *SubSystemD) MethodD() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method d&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类</span><br><span class="line">type Facade struct &#123;</span><br><span class="line">	a *SubSystemA</span><br><span class="line">	b *SubSystemB</span><br><span class="line">	c *SubSystemC</span><br><span class="line">	d *SubSystemD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodOne() &#123;</span><br><span class="line">	f.a.MethodA()</span><br><span class="line">	f.b.MethodB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodTwo() &#123;</span><br><span class="line">	f.c.MethodC()</span><br><span class="line">	f.d.MethodD()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f := Facade&#123;&#125;</span><br><span class="line">	f.MethodOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。<br>2.它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可<br>3.一个子系统的修改对其他子系统没有任何影响<br>缺点;<br>1.不能很好的限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性<br>2.如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则<br><strong>适用场景</strong></p>
<ol>
<li>复杂系统需要简单入口使用</li>
<li>客户端程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系</li>
</ol>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>抽象类：在抽象类中定义了一系列基本操作，可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或者实现这些步骤</li>
<li>具体子类：是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类 做饮料</span><br><span class="line"></span><br><span class="line">type Beverage interface &#123;</span><br><span class="line">	BoilWater()</span><br><span class="line">	Brew()</span><br><span class="line">	PourInCup()</span><br><span class="line">	AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装一套流程模板</span><br><span class="line">type template struct &#123;</span><br><span class="line">	b Beverage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *template) MakeBeverage() &#123;</span><br><span class="line">	if t == nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	t.b.BoilWater()</span><br><span class="line">	t.b.Brew()</span><br><span class="line">	t.b.PourInCup()</span><br><span class="line">	t.b.AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MakeCoffee struct &#123;</span><br><span class="line">	template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) BoilWater() &#123;</span><br><span class="line">	fmt.Println(&quot;boil the water&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) Brew() &#123;</span><br><span class="line">	fmt.Println(&quot;use boiled water to brew&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) PourInCup() &#123;</span><br><span class="line">	fmt.Println(&quot;pour the coffee to the cup&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) AddThings() &#123;</span><br><span class="line">	fmt.Println(&quot;add sugar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMakeCoffee() *MakeCoffee &#123;</span><br><span class="line">	m := new(MakeCoffee)</span><br><span class="line">	m.b = m</span><br><span class="line">	return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	makeCoffee := NewMakeCoffee()</span><br><span class="line">	makeCoffee.MakeBeverage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时不会改变算法中步骤的执行顺序<br>2.模板方法是一种代码复用技术，他提取了类库中的公共行为，将公共行为放在父类中<br>3.可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行<br>4.不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则<br>缺点：<br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。<br><strong>适用场景</strong><br>1.具有同一的操作步骤或操作过程<br>2.具有不同的操作细节<br>3.存在多个具有同样操作步骤的应用场景，但某些具体的操作系统却各不相同<br>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个子类和操作步骤解耦合</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>讲一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式。命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不比知道如何完成请求。</p>
<ul>
<li>抽象命令类：一个抽象类或者接口，通过这些方法可以调用请求接收者的相关操作</li>
<li>具体命令类：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中</li>
<li>调用者：请求发送者，通过命令对象来执行请求</li>
<li>接收者：接收者执行与请求相关的操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">type Doctor struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatEye() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat eye&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatMouth() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat mouth&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Command interface &#123;</span><br><span class="line">	Treat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatEye struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatEye) Treat() &#123;</span><br><span class="line">	cmd.d.treatEye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatMouth struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatMouth) Treat() &#123;</span><br><span class="line">	cmd.d.treatMouth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Nurse struct &#123;</span><br><span class="line">	CmdList []Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Nurse) Notify() &#123;</span><br><span class="line">	if len(n.CmdList) == 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	for _, cmd := range n.CmdList &#123;</span><br><span class="line">		cmd.Treat()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	doctor := new(Doctor)</span><br><span class="line">	cmdEye := CommandTreatEye&#123;doctor&#125;</span><br><span class="line">	cmdMouth := CommandTreatMouth&#123;doctor&#125;</span><br><span class="line">	nurse := new(Nurse)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdEye)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdMouth)</span><br><span class="line">	nurse.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.降低系统的耦合度<br>2.新的命令很容易添加到系统中，满足开闭原则<br>3.可以比较容易地设计一个命令队列或者宏命令<br>缺点：<br>使用命令模式可能会导致某些系统有过多的具体命令类，因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用<br><strong>适用场景</strong><br>1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无需知道接收者的存在，也许无知道接收者是谁<br>2.系统需要在不同的时间指定请求、将请求排队和执行请求<br>3.系统需要将一组操作组合在一起形成宏命令</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>环境类：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略，在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类：它为所支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或者具体类，也可以是接口</li>
<li>具体策略类：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类，使用一种具体的算法实现某个业务处理</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/14.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type WeaponStrategy interface &#123;</span><br><span class="line">	UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AK47 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ak *AK47) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用AK47战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Knife struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (k *Knife) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用匕首战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Hero struct &#123;</span><br><span class="line">	strategy WeaponStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) SetWeaponStrategy(s WeaponStrategy) &#123;</span><br><span class="line">	h.strategy = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) Fight() &#123;</span><br><span class="line">	h.strategy.UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	hero := Hero&#123;&#125;</span><br><span class="line">	hero.SetWeaponStrategy(new(AK47))</span><br><span class="line">	hero.Fight()</span><br><span class="line">	hero.SetWeaponStrategy(new(Knife))</span><br><span class="line">	hero.Fight()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为<br>2.使用策略模式可以避免多重条件选择语句<br>3.策略模式提供了一种算法的复用机制<br>缺点：<br>1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类<br>2.策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类<br><strong>适用场景</strong><br>准备一组算法，并将每一个算法封装起来，使得它们可以互换</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出翻译。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<ul>
<li>抽象主题：被观察的对象</li>
<li>具体主题：被观察者的具体实现</li>
<li>观察者：接口或者抽象类</li>
<li>具体观察者：观察者的具体实现</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/15.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">type Listener interface &#123;</span><br><span class="line">	OnTeacherComing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Notifier interface &#123;</span><br><span class="line">	AddListener(l Listener)</span><br><span class="line">	RemoveListener(l Listener)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhang3 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhang3) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhao4 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhao4) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhao4 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuWang5 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuWang5) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;wang5 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClassMonitor struct &#123;</span><br><span class="line">	listenerList []Listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) AddListener(l Listener) &#123;</span><br><span class="line">	m.listenerList = append(m.listenerList, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) RemoveListener(l Listener) &#123;</span><br><span class="line">	for index, li := range m.listenerList &#123;</span><br><span class="line">		if li == l &#123;</span><br><span class="line">			m.listenerList = append(m.listenerList[:index], m.listenerList[index+1:]...)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) Notify() &#123;</span><br><span class="line">	for _, listener := range m.listenerList &#123;</span><br><span class="line">		listener.OnTeacherComing()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := &amp;StuZhang3&#123;</span><br><span class="line">		Badthing: &quot;抄作业&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := &amp;StuZhao4&#123;</span><br><span class="line">		Badthing: &quot;玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s3 := &amp;StuWang5&#123;</span><br><span class="line">		Badthing: &quot;看别人玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	classMonitor := new(ClassMonitor)</span><br><span class="line">	classMonitor.AddListener(s1)</span><br><span class="line">	classMonitor.AddListener(s2)</span><br><span class="line">	classMonitor.AddListener(s3)</span><br><span class="line">	classMonitor.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>观察者模式可以实现表现层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>观察者模式在观察目标和观察者之间建立了一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，不需要了解其具体的观察者</li>
<li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li>观察者模式满足开闭原则</li>
</ol>
<p>缺点</p>
<ol>
<li>如果一个观察者对象有很多直接和间接的观察者，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间存在循环依赖，系统可能会发生崩溃</li>
<li>观察者模式没有响应的机制让观察者知道所观察到的对象是怎样发生变化的</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这两个方面封装在独立的对象中使得它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致一个或者多个其他对象也发生改变</li>
<li>需要在系统中创建一个触发链路，A对象的行为影响B，B对象的行为影响C</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/toms%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/toms%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">toms初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:43 / 修改时间：22:19:45" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:43+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="toms初识"><a href="#toms初识" class="headerlink" title="toms初识"></a>toms初识</h1><p>tmos一个特征和功能的集和，为了满足当今市场而出现的一个代理、高性能的一系列操作系统和固件，他们都在big-ip硬件设备上或BIG-IP虚拟版中运行</p>
<p>基于包设计和基于代理（全权代理）设计的区别<br>- 基于包：这些网络设备都是网络数据流中间的节点，并不是数据交互流的终点或起点，并且这些设备只需要满足部分协议而不是整个协议栈，比如一个位于第三层（IP）的设备，可能只需要会读写IP地址TCP地址即可，至于第二层第一层的协议将与其无关。现在这些设备越来越智能了，可以修改tcp数据流，甚至能修改tcp数据包的头部（seq ack）字段，而这些是通过一个状态跟踪引擎来实现的这些设备可以识别出哪些是单独的http请求（第一次的）这些基于包设计的设备是比后者快的，而且也没有那么复杂，最根本的原因就是它们只需要理解一部分协议</p>
<p>- 基于代理： 全权代理和基于包的设计刚好是相反的，它需要理解整个网络传输的协议栈，同时他们也是协议的发起者和接收者，而一个代理服务器和客户端之间的通信与一个代理服务器和后段服务器之间的通信是不同的（反向代理、正向代理）<br>二者之间的矛盾基于代理的设计比基于包的设计更加智能，但是目前来说基于代理的设计性能更强。当流量激增的时候，基于包管理的性能也会被限制，所以在企业进行选型的时候，二者都可以被考虑</p>
<p>什么是tmos<br>- 模块的集和 每个模块提供一部分功能 比如arp ip tcp各自有各自的模块，每个模块都是自称一体的，这样将可以减少系统的复杂性，类似于搭积木一样，当需要增加对某个协议的支持时，我再去构建这么一个单独的模块<br>- 自主&amp;独立的 tmos具有自己的CPU 内存 和外围设备的接口，当一个基于tmos的设备受到数据包的时候，这些线路的子管理系统是完全在tmos中独立的，linux是不参与这个过程的，也就是说tmos并不与linux操作系统发生耦合，linux只用来管理程序<br>- 实施操作系统 （非抢占式的操作系统） 对于tmos这样高性能、大流量的操作系统来说，抢占式的os会浪费掉cpu的部分性能（高优先级插队），tmos的设计是每个组件执行必要的操作，然后把cpu让出去给下一个组件运行。这样将消除了中断、上下文切换等cpu开销，并且让程序有序运行<br>- 基于软件与硬件 它可以从软件和硬件两方面来解决问题，如果是难度比较高的，可能优先走的就是软件，如果是资源密集的，那么优先丢给硬件执行<br>- 事件驱动 因为tmos是模块化并且实时的，也就意味着它能够在任何时间内切换任务，也能够在短时间内改变性能来满足当前的需求<br>- 状态检测 tmos的内核是基于高速代理的，<br>- 动态数据包筛选 tmos能够筛选数据包，它有一个重要优势就是全权代理隐藏了后端服务的网络对战，f5的iRules允许动态控制应用程序流量，可以重定向，动态过滤，或者阻止流量等等<br>以上：tmos三一个功能强大、适应性强的解决反感，模块化与字包含、实时、事件驱动的操作系统相结合，为tmos提供了前所未有的功能<br>tmos体系中的特殊模块<br>tcp express 基于包管理的设计无法提供这个功能，tcp express包括了 延迟和选择性确认、显示拥塞统治、快重传，拥塞避免等等算法，tmos基本上把tcp能优化的地方全部进行了优化，这才能实现显著的加速</p>
<p>tmm（多线程进程）:流量管理微内核处理big-ip系统上的所有负载均衡流量，在tmos中作为额u一个实时用户进程运行，cpu和内存资源在big-ip配置中明确配置</p>
<p>影响tmm使用cpu资源的因素</p>
<p>每个处理器的内核</p>
<p>每个核心的超线程数</p>
<p>big-ip版本</p>
<p> big-ip系统许可的模块</p>
<p>单cpu </p>
<p>单核的cpu使用率<br>在big-ip 11.5.0之前，每个cpu内核被分配一个单独的tmm实例，每个内核处理数据平面任务（tmm特定）和控制平面任务（非tmm特定） 。从big-ip11.5.0开始，数据平面任务和控制平面任务都采用英特尔超线程技术在CPU的系统上使用单独的逻辑内核，偶数编号给TMM，奇数编号给其他进程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/Map%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Map详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:30 / 修改时间：22:15:37" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:30+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Map详解"><a href="#Map详解" class="headerlink" title="Map详解"></a>Map详解</h1><h3 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h3><p>基本上每种计算机语言里面都会内置一个map类型，map是一个由一组key,value组成的数据类型，并且同一个key只会出现一次。同时map支持增删改查四种操作，map的主要实现方式有两种，分别是哈希查找表(hash table)和搜索树(search tree)</p>
<p>哈希表：使用一个哈希函数将key分配到不同的bucket(桶，可以理解成数组中的索引)，开销主要是在哈希函数的计算和数组的常数访问时间，很多场景下，我们可以简单的把哈希表的时间复杂度看成O(1)。哈希表通常还会有一个碰撞的问题，所谓的哈希碰撞就是多个key被哈希函数分配到了同一个bucket。一般有两种解决方法：链表法和开放地址法。链表法是将一个bucket实现程一个链表，落在同一个bucket中的key会插入这个链表。而开发地址法则是在发生碰撞之后，通过一定的规律，在空着的bucket里面挑选，用来放置新的key </p>
<p>搜索树：一般使用自平衡二叉树，比如AVL树和红黑树</p>
<p>二者的区别是，自平衡搜索树的时间复杂度最低为O(logN)，而哈希表的最差情况是O(N)，哈希表平均查找效率是O(1)。 还有一个区别是，遍历自平衡搜索树，返回的key是有序的，而哈希表则是乱序的</p>
<h3 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h3><p>Go中的Map使用的是哈希表，并且使用链表的方式解决哈希冲突</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	<span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line">	<span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B就是buckets数组的长度对数，也就是buckets数组长度为2^B，buckets里面存放着key-value对，buckets也是一个指针，类似于slice中指向数组的指针。</p>
<p>buckets指向的是下面这个东西</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后就变成了</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其中bmap就是我们所说的哈希桶，每个桶里面最多装下8个key-value对，这些key之所以会落入同一个桶中，是因为他们经过哈希计算之后，得到的结果是一类的(哈希结果得到的后八位相同)，之后会根据key计算出来的hash值的高8位来决定key到底落入桶内的那个位置(哪个槽)</p>
<p><img src="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/1.png"></p>
<p>其中每个bmap的key1…key8是存放在一起的，value1….value8是存放在一起的，这样的目的是为了节省因为内存对齐造成的空间浪费。</p>
<p>每个bucket设计成最多只能存放8个key-value对，如果有第九个key-value落入当前的bucket，则需要再构建一个bucket,然后通过overflow指针连接起来。</p>
<p><strong>创建map</strong></p>
<p>底层调用的是makemap函数，主要做的工作就是初始化hamp结构体的各种字段，比如计算B的大小，设置哈西种子hash0等等</p>
<p><strong>哈希函数</strong></p>
<p>map的一个关键点在于哈希函数的选择，在程序启动时会检测cpu是否支持aes，如果支持则使用aes hash，否则使用memhash。hash函数有加密型和非加密型，加密型的一般用于加密数据、数字摘要等，典型代表就是md5 sha1 sha256 aes256这种，非加密型的就是查找，而map就是使用的查找hash函数</p>
<p><strong>key定位过程</strong></p>
<p>key经过哈希计算后得到哈希值，共64bit，计算它落到那个桶的时候，会用到最后B个bit位，最后B个bit位的值，就是落入桶的序号、当两个不同的key落在同一个桶中，也就是发生了哈希冲突，解决手段是链表法，从前往后找到第一个空位，这样，在查找某个key的时候先找到对应的桶，然后再去遍历bucket里的key。</p>
<p>在槽内的查找过程：使用高八位的bit值，高八位的值就是槽位，如果在bucket中没找到，并且overflow不为空，还要继续去overflow bucket中查找，直到找到或是所有的key槽位都遍历完</p>
<p>综上，这是一个双重循环的过程，外层循环查找所有bucket和overflow bucket，内层循环遍历单个bucket的所有槽位</p>
<p><strong>get</strong></p>
<p>Go中读取map有两种语法，带comma和不带comma，当要查询的key不在map里，带comma的用法会返回一个bool型变量提示key是否在map中，而不带comma的语法则会返回一个对应类型的零值</p>
<p><strong>遍历</strong></p>
<p>本来map的遍历过程比较简单：遍历所有的bucket以及它后面挂的overflow bucket(第一层遍历)，然后挨个遍历bucket中的所有cell(槽)，每个bucket包含8个cell，从有key的cell中取出key value </p>
<p>但是现实并没有这么简单，因为扩容并不是一个原子的操作，每次最多只搬运两个bucket，所以如果触发了扩容操作，那么很长时间内，map状态都是处于一种中间态，有些bucket已经搬迁到新家，有些bucket还呆在老地方</p>
<p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老bucket的过程</p>
<p>具体是遍历老的bucket，然后再遍历老的bucket裂变到新的bucket里的元素</p>
<p><strong>赋值</strong></p>
<p>调用的是mapassign函数，语法和插入key的过程一样，只不过前者的key在map在不存在，后者存在</p>
<p>具体过程</p>
<p>1.检查map标志位flgas,如果为1则说明其他协程在执行写操作，导致程序panic</p>
<p>2.如果map正在扩容，那么当key定位到了某个bucket后，需要确保这个bucket对应的老bucket完成了迁移，即老bucket的key都要迁移到新的bucket中之后，才能在新的bucket中进行插入或者更新的操作</p>
<p><strong>删除</strong></p>
<p>调用的是底层的mapdelete函数</p>
<p>1.检查标志位flags，如果发现标志位为1，说明其他协程在执行写操作，直接panic </p>
<p>2.计算key的哈希，找到落入的bucket，如果正在扩容中，直接完成一次扩容</p>
<p>3.同样是两层循环，找到key的具体位置，然后删掉</p>
<p><strong>扩容</strong></p>
<p>使用哈希表的目的是快速找到目标key，随着map中添加的key越来越多,key发生碰撞的概率也越来越大，当bucket中的8个cell倍塞满的时候，效率就是最低的，最理想的情况是一个bucket只装一个key，这样就能达到o1的效率，当然这样空间消耗太多了</p>
<p>触发扩容的条件</p>
<p>1.装载因子超过阈值6.5</p>
<p>2.overflow的bucket数量过多，当B&lt;15如果overflow的数量大于2^B,当B&gt;&#x3D;15，如果overflow的数量大于2^15(装载因子比较小，map的插入和查找效率也很低，但是bucket的数量很多)</p>
<p>两种扩容方式</p>
<p>1.元素太多，bucket太少，将B+1，让bucket的数量翻倍</p>
<p>2.元素不多，但overflow bucket很多，说明很多bucket都没满，开辟一个新的bucket空间，将老bucket中的元素移动到移动到新的bucket，是的一个bucket中的key排列更加紧密</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Slice详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-03 22:10:39 / 修改时间：23:01:35" itemprop="dateCreated datePublished" datetime="2022-11-03T22:10:39+08:00">2022-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Slice详解"><a href="#Slice详解" class="headerlink" title="Slice详解"></a>Slice详解</h1><h3 id="slice和数组的区别"><a href="#slice和数组的区别" class="headerlink" title="slice和数组的区别"></a>slice和数组的区别</h3><p>众所周知，go是一门强类型的语言，什么是强类型呢？就是对类型要求非常严格(在运算时)，所以go中的float不能和int进行运算，甚至int和int64也不能进行运算。</p>
<p>数组是指长度固定的数据集合，比如 [3] int 指的就是长度为3的int类型集合，它和[4] int是两个完全不同的类型，所以不能作比较，比较也是一种运算。</p>
<p>而slice则是动态数组，长度不固定，可以动态扩容，slice的类型和长度没有关系，所以不同的slice可以进行比较(但这个操作通常没有意义)</p>
<h3 id="slice本质"><a href="#slice本质" class="headerlink" title="slice本质"></a>slice本质</h3><p>slice其实就是一个结构体，里面有着对数组的封装，还有len和cap两个字段来描述数组的长度和容量</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 元素指针 指向的其实是一个底层的数组</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要判断slice是否为空，要使用</p>
<p><code>len(slice)==0</code></p>
<p>而不能使用</p>
<p><code>slice==nil</code></p>
<p>因为slice&#x3D;0判断的是数组内是否有元素，如果没有元素则为空，而slice&#x3D;&#x3D;nil判断的是一整个结构体是否为Nil 如果我们用var 的方式声明，不会给slice分配内存，那么slice确实&#x3D;nil。但如果我们使用make的方式进行声明，那么就会给slice分配内存，所以slice就!&#x3D;nil了</p>
<p>同理的 要判断两个slice是否相同，不能简单的通过slice1&#x3D;&#x3D;slice2进行判断，而是要循环切片进行判断</p>
<h3 id="slice传参"><a href="#slice传参" class="headerlink" title="slice传参"></a>slice传参</h3><p>在我们把slice作为参数传递出去的时候，传的是<strong>值</strong>，这也就是为什么我们在被调函数中对数组进行append，在主调函数中看不到这个变化。但是如果直接通过下标的方式对slice进行修改，那么是可以反映到主调函数中的(因为下标修改是直接对底层的数组进行修改)</p>
<p>准确的来说，go中所有的参数传递，都是值传递，并没有引用传递，那有的同学可能就疑惑了，我传递map的话不是在被调函数中的改变可以反映到主调函数中吗？</p>
<p>因为进行函数调用的时候，slice类型会调用runtime.makeslice函数，这个函数的返回值类型是值，而map类型会调用runtime.makemap函数，这个函数的返回值类型是一个指针</p>
<h3 id="slice的扩容过程"><a href="#slice的扩容过程" class="headerlink" title="slice的扩容过程"></a>slice的扩容过程</h3><p>网上流传的版本是:当slice容量小于1024的时候，每次扩容翻倍，在1024长度之后，每次扩容1.25倍，而在1.18版本之后变为了，当容量小于256的时候，扩容为两倍，超过256，newcap&#x3D;oldcap+(oldcap+3*256) &#x2F;4</p>
<p>这个说法不对，或者说只对了一半</p>
<p>go 1.9.5源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//内存对齐 </span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>go 1.18源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.18 src/runtime/slice.go:178</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//内存对齐</span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只看前半部分，那么网上的各种文章说的是对的，现实是，后半部分还对newcap做了一个内存对齐，这个和内存分配策略有关，进行内存对齐之后，新slice的容量&gt;&#x3D;未进行内存对齐之前的cap</p>
<h3 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h3><p>首先new和make都是Go内置的用来分配内存的函数，区别是make用来给slice map channel等引用类型分配内存，返回值是一个值类型，而new用来给数组、结构体值类型来分配内存，后者返回值是一个指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Go-web%E4%B8%8EContent-Type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Go-web%E4%B8%8EContent-Type/" class="post-title-link" itemprop="url">Go web与Content-Type</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-03 22:07:05 / 修改时间：23:01:41" itemprop="dateCreated datePublished" datetime="2022-11-03T22:07:05+08:00">2022-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-web与Content-Type"><a href="#Go-web与Content-Type" class="headerlink" title="Go web与Content-Type"></a>Go web与Content-Type</h1><p>首先要对http的工作方式有一定的了解，这里默认大家都会。这里只是随手写了点东西记录一下Content-Type的类型和内容。</p>
<h3 id="http请求与响应"><a href="#http请求与响应" class="headerlink" title="http请求与响应"></a>http请求与响应</h3><p>http request的具体组成</p>
<ul>
<li>请求行：请求类型+url+协议版本</li>
<li>请求头:Host(表明请求目的地 主机域名) User-Agent(客户端的信息 由浏览器定义) Content-Type Content-Length等等</li>
<li>空行</li>
<li>请求体：实体数据</li>
</ul>
<p>http response的具体组成</p>
<ul>
<li>状态行：由协议版本号、状态码和状态消息组成</li>
<li>响应头： 客户端可以使用的一些信息 比如Date Content-Type Connection(是否为长链接) 等等</li>
<li>空行</li>
<li>响应体：实体数据</li>
</ul>
<h3 id="net-x2F-http"><a href="#net-x2F-http" class="headerlink" title="net&#x2F;http"></a>net&#x2F;http</h3><p>这个库里面主要是与http相关的一些API，可以分为客户端和服务端两个部分</p>
<ul>
<li>服务端相关：server serverMux Handler&#x2F;HandlerFunc</li>
<li>客户端相关: client response header request cookie</li>
</ul>
<p>具体过程如下</p>
<p><img src="/2022/11/03/Go-web%E4%B8%8EContent-Type/1.png"></p>
<p>首先服务端创建Listen Socket监听指定的端口，等待客户端请求到来，之后Listen socket接受客户端的请求，得到Client Socket，通过这个socket和客户端进行通信；每次处理客户端的请求时，首先从Client Socket读取HTTP协议头，如果是POST可能还要读取数据，然后交给相应的Handler处理，处理完毕之后准备好客户端需要的数据，通过Client Socket写回给客户端。</p>
<p>ListenAndServe函数的具体流程</p>
<ul>
<li>监听某个端口  如果有新连接进来 创建一个goroutine处理新的连接 </li>
<li>在goroutine中 将请求和响应分别封装为http.Request和http.ResponseWriter对象，将这两个对象作为参数传递给server.Handler的serveHTTP,这个server.handler就是listenandserve函数的参数(http.servemux)</li>
<li>查找http.Request对象的url(在servemux中的map中进行) 然后执行</li>
<li>监听之后内部有一个for循环不断接受请求，每个请求创建一个conn,最后创建一个goroutine</li>
</ul>
<h3 id="Content-Type初识"><a href="#Content-Type初识" class="headerlink" title="Content-Type初识"></a>Content-Type初识</h3><p>Content-Type 是http的首部字段，用于说明请求或者返回的消息body是以何种方式进行编码，在request header和response header里都存在，网页通过这个类型定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。</p>
<p>常见的媒体格式类型如下</p>
<ul>
<li>text&#x2F;html html格式</li>
<li>text&#x2F;plain 纯文本格式</li>
<li>text&#x2F;xml xml格式</li>
<li>text&#x2F;gif gif图片格式</li>
<li>text&#x2F;jpeg jpg图片格式</li>
<li>text&#x2F;png png图片格式</li>
</ul>
<p>以application开头的媒体格式类型</p>
<ul>
<li>application&#x2F;xhtml+xml XHTML格式</li>
<li>application&#x2F;xml XML格式</li>
<li>application&#x2F;atom+xml Atom XML聚合格式</li>
<li>application&#x2F;json JSON数据格式</li>
<li>application&#x2F;pdf pdf格式</li>
<li>application&#x2F;msword Word文档格式</li>
<li>application&#x2F;octet-stream 二进制数据流格式</li>
<li>application&#x2F;x-www-form-unlencoded 表单默认的提交数据格式(被编码为key&#x2F;value的格式)</li>
</ul>
<p>另一种常见的媒体格式的上传文件之时使用的</p>
<ul>
<li>multipart&#x2F;form-data 需要在表单中进行文件上传时，就需要使用到这个格式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Go编译相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-31 22:52:56" itemprop="dateCreated datePublished" datetime="2022-10-31T22:52:56+08:00">2022-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-15 22:14:25" itemprop="dateModified" datetime="2022-11-15T22:14:25+08:00">2022-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go编译相关"><a href="#Go编译相关" class="headerlink" title="Go编译相关"></a>Go编译相关</h1><h2 id="Go的一些环境变量"><a href="#Go的一些环境变量" class="headerlink" title="Go的一些环境变量"></a>Go的一些环境变量</h2><p>在我们安装Go语言的时候，都要设置一些环境变量，最重要的就是GOROOT和GOPATH，那么他们分别代表的是什么呢？</p>
<p>下图是所有的Go环境变量</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/1.jpg"></p>
<p>随便挑几个</p>
<ul>
<li><p>GOROOT是GO的安装路径，有一些关于操作系统方面的支持和编译器、链接器等等</p>
</li>
<li><p>GOPATH是一个工作空间，目的是提供一个寻找.go源码的路径，可以设置多个目录，GO官方要求需要包含三个文件夹，src存放源文件，pkg存放编译后的库文件，后缀为.a，bin则存放可执行文件。</p>
</li>
<li><p>GOOS是Go当前所在的操作系统</p>
</li>
<li><p>GOARCH是Go所在的计算机架构</p>
</li>
<li><p>GO111MODULE表示是否开启Gomod</p>
</li>
<li><p>GOPROXY表示代理，direct表示是否直接走代理</p>
</li>
<li><p>CGO表示是否开启CGO</p>
</li>
</ul>
<p>在交叉编译的时候就要使用到GOOS和GOARCH，交叉编译指的是：编译的平台和代码最终运行的平台不一样，我们都知道，不同机器的机器码是不一样的，不是说一个二进制文件，在所有机器上都可以执行的。</p>
<p>比如这么一个场景：你的开发环境是Win10，但是服务器是Centos7，这时候你想要让代码在服务器上运行，可以有这么两种解决方案</p>
<ol>
<li>把整个工程文件传到服务器上，在服务器上进行编译和运行，但这显然不方便，因为你还要在服务器上安装Go</li>
<li>在开发环境进行编译，编译出的二进制文件能够在服务器上运行</li>
</ol>
<p>显然第二种解决方案更加简单</p>
<p>那么该怎么做呢？</p>
<ol>
<li>修改GOOS和GOARCH为对应的平台与计算机架构，在Go1.13之后修改环境变量要用到go env -w  </li>
<li>GOOS&#x3D;linux GOARCH&#x3D;amd64 go build &#x2F;&#x2F;分别指定对应的平台和机器的位数</li>
</ol>
<p>当然，在实际开发中一般环境都是和服务器相同的(操作系统和机器位数)，这样就不会有类似的问题。</p>
<h2 id="Go代码编译链接过程"><a href="#Go代码编译链接过程" class="headerlink" title="Go代码编译链接过程"></a>Go代码编译链接过程</h2><p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/2.png"></p>
<p>从上图可以看出来，一份Go代码需要先经过编译器的编译称为汇编程序，再通过汇编器成为二进制可执行程序，再经过链接器的链接，最后才成为了一份二进制可执行文件。</p>
<p>具体过程：go build其实就是编译和链接的过程，编译是指对源文件进行词法分析、语法分析、语义分析、优化，最后生成汇编代码文件，以.s作为文件的后缀。之后，汇编器会将汇编代码转变成机器可以执行的指令，每一条汇编语句都与一条机器指令对应。编译是一个很智能的过程，里面还包含了优化的部分，而汇编则是比较机械的部分，将汇编语句转换成机器指令。</p>
<p>编译过程</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/3.png"></p>
<p>主要过程就是：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化</p>
<p>词法分析（扫描）：将源代码字符序列转换为标记(token)序列的过程 进行这个步骤的程序叫做词法分析器，也叫作扫描器(scanner)，一般以函数的方式存在，.go文件被输入到scanner，它使用一种类似于有限状态机的算法，将源代码的字符系列分割成一系列的token。token分为这几种：关键字、标识符、字面量、特殊符号等等</p>
<p>Go语言scanner的具体逻辑就是通过next函数，获取下一个未被解析的字符，并且跳过之后的空格，回车，换行，tab这些字符，进入一个大的switch-case语句，匹配不同的情况。</p>
<p>语法分析：上一步生成的token序列，需要经过进一步的处理，生成一颗以表达式为结点的语法树（把符号组成一个句子）</p>
<p>语义分析：检查常量、类型、函数声明等等，可以把这一步看成静态检查，如果有很明显的语法错误，就会报错。</p>
<p>中间代码生成：编译过程可以分为前端和后端，前端生成和平台无关的中间代码，而后端会针对不同的平台，生成不同的机器码，前面的词法分析、语法分析、语义分析都属于编译器前端，后面的阶段属于编译器后端。</p>
<p>目标代码生成与优化：不同机器的机器字长、寄存器都不一样，意味着在不同机器上跑的机器码是不一样的，最后一步的目的就是要生成能在不同CPU架构上运行的代码。目标代码优化器会对一些指令进行优化，提升程序的效率。</p>
<p>链接：将编译器生成的一个个目标文件链接成可执行文件，最后得到的文件是分成各种段的。</p>
<p>其实关于编译链接这部分的内容还有很多需要学习的，这里只是简单的说明了一下，具体可以参考《程序员自我修养》这本书</p>
<h2 id="Go编译相关命令"><a href="#Go编译相关命令" class="headerlink" title="Go编译相关命令"></a>Go编译相关命令</h2><p>Go语言的源码分为三类：命令源码、库源码、测试源码</p>
<p>命令源码：Go程序的入口，包含func main() 函数，且第一行用package main声明属于main包</p>
<p>库源码：主要是各种函数、各种接口，例如工具类的函数</p>
<p>测试源码：以_test.go为后缀，用于测试功能、性能等</p>
<p>与编译相关的Go命令主要有三个</p>
<ul>
<li>go build</li>
<li>go install</li>
<li>go run</li>
</ul>
<p>go build的一些参数</p>
<ul>
<li>-a 强制重新编译所有涉及到的包</li>
<li>-n 打印命令执行过程 不真正执行</li>
<li>-p n 打印命令执行的并行数 n默认为cpu核数</li>
<li>-race 检测并报告程序中的数据竞争问题</li>
<li>-v 打印命令执行中涉及到的代码包名称</li>
<li>-x 打印命令过程中涉及到的命令 并执行</li>
<li>-work 打印编译过程中的临时文件夹，编译完成后会被删除</li>
</ul>
<p>go build：编译过程会忽略掉测试源码 执行过程是递归寻找main.go所依赖的包，以及依赖的依赖，直至最低层的包，如果有循环依赖，则直接退出</p>
<p>go install ：编译并安装指定的代码包，相比于Go build，它多了一个“安装编译后的结果文件到指定目录”的步骤</p>
<p>go run ：先编译，再链接，再执行</p>
<h2 id="Go程序启动过程"><a href="#Go程序启动过程" class="headerlink" title="Go程序启动过程"></a>Go程序启动过程</h2><p>1.检查运行平台的CPU 设置好程序运行需要相关标志</p>
<p>2.TLS的初始化</p>
<p>3.runtime包进行变量和调度器的设置</p>
<p>4.创建新的goroutine绑定用户的main方法</p>
<p>5.开始进行goroutine的调度</p>
<p><img src="/2022/10/31/Go%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/4.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Go-defer%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/31/Go-defer%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Go defer详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-31 22:52:12 / 修改时间：22:56:57" itemprop="dateCreated datePublished" datetime="2022-10-31T22:52:12+08:00">2022-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-defer详解"><a href="#Go-defer详解" class="headerlink" title="Go defer详解"></a>Go defer详解</h1><h3 id="什么是defer"><a href="#什么是defer" class="headerlink" title="什么是defer"></a>什么是defer</h3><p>在进行编程的时候，经常需要在代码中申请一些资源，比如数据库连接，文件句柄等等，这些资源需要在用完之后进行释放，否则会造成内存泄漏（内存一直被占用而不被释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果），而Go就提供了一个defer关键字，可以实现延迟调用。defer可以让函数或者语句在当前函数执行完毕后执行（包括程序正常退出和panic导致的异常结束）</p>
<p>以下代码有什么问题？</p>
<p><code>r.mu.Lock()</code></p>
<p><code>rand.Intn(param)</code></p>
<p><code>r.mu.Unlock()</code></p>
<p>看起来这段代码是没有什么问题的，但这是建立在程序正常运行的基础上，如果rand.Intn出现了异常而造成了panic，就会出现r一直占用着锁而不释放的问题，所以即使是简单的释放资源的代码，使用defer也是很有必要的。</p>
<h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><p>defer的语句并不会马上执行，而是会进入一个栈，所以执行的顺序也会和栈一样，即先进后出，也就是说最先被定义的defer语句最后执行，这个原因是后面定义的函数可能对前面的资源有依赖，所以要先执行；否则如果前面先执行了，对某些资源进行释放，后面的函数就会出错。</p>
<p>在defer函数定义时，对外部变量的引用有两种方式，函数参数和闭包引用，前者在defer定义时就把值（广义的值，如果传的是引用类型，那么和定义的时候可能不一样）传给defer，并被存起来，而后者则会在defer真正调用的时候根据上下文确定值。</p>
<p>如果是闭包的话，则会和定义的时候不一样，看下面这个栗子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var t [3]struct&#123;&#125;</span><br><span class="line">   for i := range t &#123;</span><br><span class="line">      defer func() &#123;</span><br><span class="line">         fmt.Println(i) //defer 后面接的是闭包 在for 循环结束后的i的值为2</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   // 2</span><br><span class="line">   // 2</span><br><span class="line">   // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：在Go使用close()关闭某些资源的时候，最好提前判断调用主体是否为空，否则很可能会解引用一个空指针，从而造成panic的问题</p>
<h3 id="return与defer"><a href="#return与defer" class="headerlink" title="return与defer"></a>return与defer</h3><p>return并不是一条原子指令，return的执行顺序是这样的</p>
<p>1.返回值&#x3D;xxx</p>
<p>2.调用defer函数</p>
<p>3.ret指令</p>
<p>下面是两道defer经典题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func f1() int &#123;  //返回值没有取名</span><br><span class="line">   x := 5</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   return x       //1.返回值赋值 2.defer 3.执行RET返回  //开辟了一份空间 return语句先将5赋值给x defer修改了x的值 但是RET命令执行的对象还是那个‘5’</span><br><span class="line">&#125;</span><br><span class="line">func f2() (x int) &#123;  //返回值有名字</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++ //闭包</span><br><span class="line">   &#125;()</span><br><span class="line">   return 5  //修改的是x的值</span><br><span class="line">&#125;</span><br><span class="line">func f3() (y int) &#123;</span><br><span class="line">   x := 5</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      x++</span><br><span class="line">   &#125;()</span><br><span class="line">   return x   //y = x = 5  defer修改的是 x 真正返回的y还是5</span><br><span class="line">&#125;</span><br><span class="line">func f4() (x int) &#123;</span><br><span class="line">   defer func(x int) &#123;</span><br><span class="line">      x++   //改的是函数值的副本  //如果这里是 defer func(x *int) &#123; x ++ &#125;(x) </span><br><span class="line">   &#125;(x)     //那么结果就会变成6</span><br><span class="line">   return 5  </span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(f1())  //5</span><br><span class="line">   fmt.Println(f2())  //6</span><br><span class="line">   fmt.Println(f3())  //5</span><br><span class="line">   fmt.Println(f4())  //5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   x := 1</span><br><span class="line">   y := 2</span><br><span class="line">   defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">   x = 10</span><br><span class="line">   defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">   y = 20</span><br><span class="line">    //1.调用calc中的calc(&quot;A&quot;,x,y)  输出:&quot;A&quot;,1,2,3 因为函数调用时会确定每个参数的值</span><br><span class="line">    //2.defer calc(&quot;AA&quot;,x,3)</span><br><span class="line">    //3.调用第二个calc中的calc(&quot;B&quot;,x,y)  此时x y是20 输出:&quot;B&quot;,10,2,12</span><br><span class="line">    //4.defer calc(&quot;BB&quot;,x,12)</span><br><span class="line">    //5.先进后出 调用第二个calc 输出:&quot;BB&quot;,10,12,22</span><br><span class="line">    //6.调用第二个calc 输出:&quot;AA&quot; 1,3,4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包&#x3D;函数+引用环境 不推荐在生产环境中使用，就算你自己对闭包的使用很熟练，但是代码写出来是给人看的，不能苛求你的同事、测试对这部分也很熟悉，而且闭包很容易出现错误。</p>
<p>Go中的所有匿名函数都是闭包程序</p>
<h3 id="defer配合recover使用"><a href="#defer配合recover使用" class="headerlink" title="defer配合recover使用"></a>defer配合recover使用</h3><p>执行初始化的时候出问题，最好直接panic掉，避免上线之后出现更大的问题，有些时候，需要从异常中恢复，比如服务器的严重问题产生了panic，这个时候需要在程序崩溃之前做一些扫尾工作，比如关闭客户端的连接。并且一个panic不应该影响整个服务器的运行，这时候就需要defer 和 recovery进行配合 </p>
<p>defer配合recovery使用:recovery必须在defer的函数中 才是标准格式 </p>
<p>比如这种</p>
<p><code>func main() &#123;</code><br>    <code>defer f()</code><br>    <code>panic(404)</code><br><code>&#125;</code></p>
<p><code>func f() &#123;</code><br>    <code>if err := recover(); err != nil &#123;</code><br>        <code>fmt.Println(&quot;recover&quot;)</code><br>        <code>return</code><br>    <code>&#125;</code><br><code>&#125;</code></p>
<p>或者采用匿名函数</p>
<p><code>func main() &#123;     defer func() &#123;         if err := recover(); err != nil &#123;             fmt.Println(&quot;recover&quot;)             return         &#125;     &#125;()     panic(404) &#125;</code></p>
<p>但是注意，一定要在<strong>函数</strong>里，像这样是不行的</p>
<p><code>func main() &#123;     defer recover()     panic(404) &#125;//还是会panic</code></p>
<h3 id="defer链是如何被执行的"><a href="#defer链是如何被执行的" class="headerlink" title="defer链是如何被执行的"></a>defer链是如何被执行的</h3><p>前面我们说到过，一个函数中的defer语句是按照栈的顺序执行的，每一条defer语句都会创建一个_defer结构体，这些结构体以链表的形式挂载在G下（Goroutine)。</p>
<p>defer首先会调用deferporc函数，new一个_defer结构体，挂到G上，当然，调用new之前会从当前G绑定的P中的defer pool中取，如果没有的话则会去全局的defer pool中取，是在没有就新建一个，这是Go runtime的常规操作，也就是设置多级缓存，提高运行效率。 </p>
<p>之后按照顺序，处理一个个_defer结构体，即完成了defer链的执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/RSA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/RSA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">RSA详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-22 11:07:45 / 修改时间：11:11:34" itemprop="dateCreated datePublished" datetime="2022-10-22T11:07:45+08:00">2022-10-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RSA详解"><a href="#RSA详解" class="headerlink" title="RSA详解"></a>RSA详解</h1><h2 id="1-RSA思想"><a href="#1-RSA思想" class="headerlink" title="1.RSA思想"></a>1.RSA思想</h2><p>  RSA公开密钥密码体制是一种使用不同的加密密钥和解密密钥，由“已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p>
<p>  在这种体制中，加密秘钥（公钥）PK是公开信息，而解密密钥（私钥）SK是需要保密的，加密算法E和解密算法D也都是公开的，这样的话虽然SK是由PK决定的，但是不能通过PK计算出SK。</p>
<p>​	基于这种思想，在1978年出现了著名的RSA算法。</p>
<ol>
<li>通常是先生成一对RSA密钥</li>
<li>其中的一个是私钥，用户保存，另一个是公钥，可对外公开，甚至可以在网络服务器中注册</li>
<li>为了提高保密强度，密钥至少为500位，一般推荐1024位</li>
<li>为了减少计算量，传送信息的时候通常采用传统加密与公开密钥加密结合的方式</li>
</ol>
<p>算法原理：根据数论的理论，找两个大素数比较简单，对他们的乘积进行因式分解却很困难，因此可以将乘积公开作为加密秘钥</p>
<h2 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2.算法描述"></a>2.算法描述</h2><ol>
<li>任意选两个不同的大素数p和q计算乘积n&#x3D;pq，欧拉函数n&#x3D;p-1 * q-1 </li>
<li>任意选一个大整数e，满足 gcd (e,欧拉n)&#x3D;1，整数e用作加密钥</li>
<li>确定的解密要d 满足(de) mod 欧拉n &#x3D;1 很容易计算出d </li>
<li>公开n和e 保存d</li>
<li>将明文m(m&lt;n)加密成c 加密算法为 c&#x3D;m^e mod n </li>
<li>将密文c解密为明文m  解密算法为 m&#x3D;c^d mod n</li>
</ol>
<p>通俗易懂的解释：</p>
<p>1.第一步 随机选择两个不相同的质数 p 和 q  比如61和53，在实际应用中，这两个质数越大，就越难破解</p>
<p>2.第二步 计算p和q的乘积n  上面的栗子 n&#x3D;61*53&#x3D;3233</p>
<p>这个n就是密钥，写成二进制位110010100001，一共12位，那么这个密钥长度就是12位，在实际应用中,RSA密钥长度要到1024位，才具有足够的保密性</p>
<p>3.第三步，计算n的φ(n)</p>
<p>欧拉n&#x3D;p-1* q-1 上面的栗子为3120</p>
<p>4.第四步 随机选择一个整数e 条件为1&lt;e&lt;φ(n)，且e与欧拉n互质，实际应用中常用65537，我们这边随便选个17</p>
<p>5.计算e对于φ(n)的模反元素d </p>
<p>所谓模反元素就是指有一个整数d 可以让ed 被 φ(n) 除的余数为1</p>
<p>可以通过扩展欧几里得算法求解 </p>
<p>6.将n和e封装成公钥，n和d封装成私钥</p>
<p>可靠性：能不能在已知n和e的情况下，推出d，也就是能不能在已知公钥的情况下，推出私钥？</p>
<p>结论：不行，需要对大整数进行因式分解，这个过程很困难，目前被破解的最长RSA密钥为768位</p>
<p>7.加密过程：</p>
<p>通过公钥(n,e)对m进行加密，m必须为整数，且m必须小于n</p>
<p>加密过程</p>
<p>m ^ e ≡ c (mod n)</p>
<p>8.解密过程</p>
<p>c ^ d ≡ m (mod n)</p>
<h2 id="3-安全性描述"><a href="#3-安全性描述" class="headerlink" title="3.安全性描述"></a>3.安全性描述</h2><ul>
<li>保密强度随着密钥的长度增加而增强，但是密钥越长，加解密的时间也就夜场</li>
<li>RSA安全性依赖于大数分解</li>
<li>因为进行的都是大数计算，使得RSA的速度比DES慢上好几倍甚至好几十倍，因为AES这类算法通常厂商会在硬件方面进行优化，RSA一般只用于少量的数据加密，RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/22/%E5%B7%A5%E4%B8%9A%E7%95%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E5%B7%A5%E4%B8%9A%E7%95%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工业界的几种发布模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-22 11:07:35" itemprop="dateCreated datePublished" datetime="2022-10-22T11:07:35+08:00">2022-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-22 14:46:50" itemprop="dateModified" datetime="2023-02-22T14:46:50+08:00">2023-02-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="工业界的几种发布模式"><a href="#工业界的几种发布模式" class="headerlink" title="工业界的几种发布模式"></a>工业界的几种发布模式</h1><h2 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h2><ul>
<li>蓝绿发布的本质上是通过系统冗余来解决上线风险的问题，通常生产环境中配置两套完全一样的环境，一组是active的生产环境配置（绿色），一组是inactivate的准备环境配置（蓝色），两套系统都是功能完善的，并且正在运行的系统，只是系统版本和对外服务情况不同</li>
<li>最初始的状态下，没有任何系统，也没有蓝绿之分，然后第一套系统开发完成直接上线，只有一个系统，后来业务更新，要用新版本替换线上的旧版本，这时候就有两个系统，正在对外提供服务的是老系统为绿色，新部署的系统为蓝色</li>
</ul>
<p>为什么要有蓝色系统？因为蓝色其实是为了对新版本进行全方位的测试</p>
<ul>
<li>如果测试没出问题，可以通过负载均衡器&#x2F;反向代理&#x2F;路由指向蓝色环境，之后只要检测这个环境是否有故障，如果运行良好， 就可以删除v1.0使用的资源，为下一次蓝绿部署空出可用资源</li>
<li>如果测试有问题，直接修改指向，快速回滚到绿色环境</li>
</ul>
<p>优点：部署过程中，应用始终在线，并且新版本没有修改老版本的任何内容，在部署期间，老版本的转改不收影响，风险很小，并且理论上可以在任何时间回滚到老版本</p>
<p>缺点：需要两套环境，冗余的基础设施。而且对于设计数据表结构变更等不可逆转的升级，不太适合</p>
<h2 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h2><p>金丝雀发布就是灰度发布，这两个东西是同一类策略，策略就是只有一套系统，并且逐渐替换这套系统。</p>
<p>指的是增量发布的一种类型，在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”，测试新版本的性能和表现，以保证整体系统的稳定性。</p>
<p>发布过程</p>
<ul>
<li>从负载均衡列表里下掉</li>
<li>升级金丝雀应用</li>
<li>重新添加到负载均衡列表中</li>
<li>如果测试成功，升级其他的服务器，否则回滚</li>
</ul>
<p>通常会AB测试一起使用</p>
<h2 id="AB测试"><a href="#AB测试" class="headerlink" title="AB测试"></a>AB测试</h2><p>AB测试是效果测试，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分，核心目的是用来测试应用功能表现的方法。比如页面的样式、颜色不一样，最后通过分析各个服务的实际效果，选择效果最好的版本。</p>
<h2 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h2><p>所谓滚动发布一般是取出一个或者多个服务器停止服务，执行更新，并重新投入使用，周而复始，直到集群中的所有实例都更新成新版本，比如每次选出集群中的20%进行升级。比蓝绿部署更节省资源。</p>
<p>缺点：</p>
<ul>
<li>没有一个确定OK的环境</li>
<li>需要回滚的话很麻烦</li>
</ul>
<h2 id="红黑部署"><a href="#红黑部署" class="headerlink" title="红黑部署"></a>红黑部署</h2><p>这是Netfix采用的部署手段，主要基础设施在AWS上，它利用了AWS的特性，在部署新的版本的时候，通过AutoScaling Group 用包含新版本的AMI创建新的服务器，服务始终在线，同时采用不可变部署的方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">56k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">51 分钟</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
