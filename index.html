<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/" class="post-title-link" itemprop="url">我的本科前半生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-04 23:33:56 / 修改时间：23:43:32" itemprop="dateCreated datePublished" datetime="2023-03-04T23:33:56+08:00">2023-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一个很喜欢用文字记录生活与想法的人，但是由于文字功底太弱，这些文字大多都躺在我的备忘录和废纸篓里。<br>      昨天看到了一个我很尊敬的学长写的一篇博文，深有所感。于是想写一些东西，记录一下大学这两年的一些经历，感悟和想法。部分内容摘自<a target="_blank" rel="noopener" href="http://www.cbb777.fun/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">实习求职总结</a></p>
<h1 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h1><p>20年9月16日，我独自坐上了从景德镇到南昌的动车，在体验过人生的第一次地铁和第一次飞机之后，在晚上十一点抵达了重庆。当时订的酒店在机场附近有一个总店一个分店，很不幸，我订的是总店但是不小心跑到分店去了。当时下着淅淅沥沥的小雨，我背着我的电脑包和双肩包走在凌晨的大街上，忽然觉得有些冷，那晚我把QQ签名改成了“希望生活别把我揍的太惨”。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/1.png" alt="image.png"><br>        进入大学后，我并没有选择松懈。<strong>我觉得人就是这样，越长大要承受的东西只会越来越多，万万没有变轻松的道理，中学比小学难熬，大学比中学难熬，进了社会比在学校难熬。</strong>我选择了在报道的第二天就一头扎进了图书馆，并在一个礼拜内速通了《高等数学上》及《线性代数》的大部分内容。开学之后没多久就放国庆了，但是国庆我也没有闲着，在之后的几个礼拜我又陆陆续续的把《C语言程序设计》学完了，当时真的非常幼稚，一有问题就在群里问，一有看不懂的代码就直接打包让当时的C语言志愿者帮忙看，完全不知道这是一种多么不负责任的行为，现在想想真的是愧怍万分。<br>        当时其实完全没有思考过自己到底想在大学里面干什么事情，在毕业的时候成为什么样的人，只顾着努力学东西。我只是把高中的那一套东西复用在大学里了，打算成为班里面的尖子，然后争取保研，但是我真的需要一个硕士学位吗？<br>        <strong>这何尝不是一种懒惰呢？还没有确定明确的目标就慌不择路的随便选条路出发，现在回头看看只觉这是在用战术上的勤奋来掩盖战略上的懒惰罢了。</strong><br>        大概是十一月初，我大学生活最重要的一个转折点来了。我去参加了当时我们学院的优秀就业生宣讲，第一个宣讲人是胡仓学长，也是一个很厉害很厉害的学长，在听完他的经历之后我花了一下午仔细思考了之后的规划，最终决定不读研了，本科毕业直接就业。这个决定其实并没有得到家人和朋友的支持，但我并没有动摇我的想法，人生总得自己去体验嘛。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/2.png" alt="image.png"><br>        之后我就很少去上课了，因为我觉得那些课程真的很浪费时间，大部分课程都是通识课，对就业可以说是毫无帮助，开设的少部分专业课，老师只是在念年纪比我都大的PPT，一节课一个半小时，我想如果自学的话也许花不了二十分钟就能把一节课的内容给学完。<br>        大一也没有确定好方向，同时也缺乏学习的方法论，基本上ACM、CTF、安全、后端、前端，这些方向我都尝试过，当时很多开发环境我都装不上，经常是一个环境装好几个小时，最后还是不了了之；除此之外刷了一些算法题也并没有体现出来效果。这对一个刚接触技术的小白来说打击太大了。加上当时其实对写代码根本说不上有什么兴趣，我很快就慢慢对写代码这件事情丧失了动力，但我又决定了本科毕业就业，于是乎我开始选择逃避现实了，几乎每天都窝在寝室里，不去上课也不做正事，每天看看小说刷视频打游戏。<strong>一边因为迷茫而焦虑，同时又缺乏自驱力和行动力，无法走出自己的舒适圈，我想这是很多大学生的问题。</strong></p>
<h1 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h1><p><strong>我是一个很难因为自己而开心起来的人，我直到现在都没有找到真正能让我很开心的事情，我总觉得我存在的意义是为了周围的人，为了我的家人、伴侣和朋友。如果说取悦自己是一门课程的话，那我一定没有及格。</strong><br>        其实到现在我都不能理解为什么有人的开心能来的这么容易，我的好哥们会因为吃到好吃的而觉得开心，他可以为了吃专门跑出去一趟，我长这么大似乎都没有很喜欢很喜欢吃的东西，大部分食物都只是用来饱腹而已。<br>        这可能也和多巴胺能有关系，有的人就是很容易觉得幸福和满足，不需要出人头地，平平淡淡的生活已经能够让他们很开心很开心了。而有的人多巴胺能很强，对自己的现状很容易产生一种不满足的心理，这种人更容易取得一点成就，但是这一定就是好事吗？我并不觉得这种世俗意义上的成功和幸福感是有正相关性的。之前我一直希望我家的小孩能够好好读书，出人头地，大有作为；但现在我完全不这么想了，现在的小孩能活的开心的太少了，不需要有什么成就，开开心心的过一生就很好。<br>        <strong>如何经营好自己的生活、享受当下是我觉得我急需学习的一项技能。好消息是现在我已经迈出了第一步，我开始学画画、摄影、骑行、读书、分享自己的生活。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/3.png" alt="AB205C830C36C9F4AB42E05364A29BBA.jpg"><br>        就像中学一样，我是因为不想让家人过于担心我的成绩才开始努力学习，最终完成逆袭的。在大二开始之前的那个暑假我认识了当时的爱人，因为恋爱的原因，我觉得自己不能再继续颓废下去了，当时刚好极客勤奋蜂工作室开启了Go学员的培训，为了通过工作室的考核，我开始把大一学过的东西慢慢捡起来，然后每天把大量的时间丢在写代码，学技术上面。<strong>不知道是不是我的性格如此，不管是什么东西，只要我花了足够多的时间，我就会慢慢的不排斥这件事甚至喜欢上它。</strong>每做完一个嘉文学长设置的project我都会更热爱代码一分，每划掉每日to-do list中的一项我的成就感就会多一分，在成就感和满足感积累之中，我慢慢的开始喜欢上技术了。我想也许就是这样吧，在大学我也读过几本心理学的书籍，<strong>满足感、成就感、被需要感是做某些事情的最佳动力了，同时，一个最可怜的人也一定不是缺少财富、权利、地位，而一定是不被需要。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/4.png" alt="image.png"></p>
<p><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/5.png" alt="img"></p>
<p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，因为是第一次面试，我的印象真的非常深刻，问的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。<br>        之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在专业知识上被认可了，然后当天就去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。当天主要和峰哥、源哥聊的比较多，这也是我第一次了解创业相关的东西，比如融资是怎么一回事。<br>        之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装。<br>        差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，那边的环境是真的很好，呆着就容易让人心情愉悦，我慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/6.png" alt="56E6CD019183D099581FB095CF187A7C.jpg"><br>        源哥曾经说过这么一段话，我深以为然。<br>        “<strong>其实编程真的不是一件很难的事情，甚至是一个比较有意思的事情。只是大部分人还在学的阶段就放弃了，这个阶段他们只能抄别人的代码，自己写不出来东西，一旦自己能创造东西就能感受到编程的快乐了。</strong>”<br>        除了工程上的收获之外，我还认识了很多很厉害的大佬，基本上食铁兽成员的专业能力已经是我校一级梯队水准了，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来他思考的方面特别多。而且他知识的广度也很强，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐、洋哥，也都是很优秀的人，就不一一说了，食铁兽的氛围是真的挺好的，大家都是学生，没有那种领导的感觉，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。<br>        差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，也是我在校园最痛苦的一段时间，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，需要吃褪黑素才睡得着，不然脑子会一直处于活跃状态，明明身体很困，但是意识非常非常清晰。差不多准备了两个礼拜之后就开始投递简历了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，当时真的非常焦虑，觉得自己是不是要找不到工作了。最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是挂掉了，最后拿了一个小厂的offer但是不太想去。<br>    没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功，那段时间我对于linux和shell的熟悉程度也在直线上升。同时也和我校的研究生学长进行了交流和接触，更坚定了我不读研的想法。</p>
<p>“学长你学的什么方向啊？”<br>“开发吧，JAVA学了一半，没完全学完”<br>“那你发了paper吗？”<br>“还没有，还在写”<br>“打算毕业之后就业还是接着深造啊？”<br>“就业，读不下去了，读研都已经觉得很痛苦了。”<br>“读研究生有补贴吗？”<br>“一个月800”</p>
<h1 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h1><p>在大三入学后我又开始了新一轮的投递和面试，在开学的一周内拿了两家公司的offer，最后选择了去通明智云实习，这是一家搞负载均衡的公司，我们组负责开发负载均衡设备的纳管平台。<br>        那是第一次出远门实习，在此要感谢我的辅导员——林义钧老师，他是一位真正有师德，替学生考虑的老师，替我解决了学校里的很多麻烦，在大部分院都卡学生外出实习、完全不考虑当今就业市场学生可能毕业即失业、只顾学生就业率、升学率的情况下，林义钧老师仍然支持我实习，并替我解决了请假审批的问题。<br>        在通明智云我学到了很多东西，这是我第一次接触到生产级别的项目。我的leader韩哥是一个非常好的领导，并没有因为我是实习生就给我分配边角任务，而是真正有让我积极参与项目、融入到整个集体里面来，同时他也会让每个人不只负责一个模块，而是定期更换模块，让所有人对项目都有多方位的理解，也能真的学到技术。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/7.png" alt="689294415A37CFD7521DF177B8FA68A9.jpg"><br>        一开始主要负责部署相关的工作，负责和用户对接，能被leader信任，真的去做事情对我来说真的是一件挺有意义的事情。后面主要负责Prometheus相关的开发工作，但是没深入多久就和我当时的爱人分手了，后面整个人的状态其实都不太好，也没有多少产出，也确实是一件挺遗憾的事情。<br>        公司里还有来自北邮、北林的实习生，该说不说，长得都很帅。在之前我没觉得重邮本学历有多低，在实习之后发现好像确实有点低了。大家一起玩ranging loop、爬长城是真的挺开心的，长这么大第一次碰到除了LOL之外戳我的游戏，我之前一直以为自己不爱玩游戏呢。<br>        组里面的同事也很友好：说话很好笑很热心的美美、对技术很有追求的建国、像大哥哥一样很温暖的恩清、很腼腆的PM若培、喜欢玩摩托的士亮等等。还记得我理解不了需求、写不来mongo的查询语句、搞不懂prometheus实现原理、部署出问题的时候基本都是问的美美、建国和恩清，谢谢他们愿意花时间替我来擦屁股。总的来说大家都很好，氛围很温暖，下了班大家也会去地铁口那边一起吃饭，平常住在一栋楼里面交流也多。真的是一段很难忘也很有意义的经历，不仅仅是技术方面成长了，连带着待人接物、生活技能方面也学会了不少东西。<br>        现在我加入了百度APP业务中台部门，虽然呆的时间还不久，但是也能够感觉出来氛围挺好的，我的mentor宇哥和leader学明哥相处起来都给人一种很舒服的感觉，并且也是真的希望我能够学到东西，在我反应了我更想往Go方面去靠的时候，他们立马给我确定了之后的任务方向。百度给我的感觉是新人培养制度真的很不错，有很详细的培养方案，能够帮助实习生快速融入团队，同时整个部门的效率也非常高，不会在不该浪费时间的地方浪费时间，组里还有来自北大硕、北航硕的实习生，真的都是一群很优秀很优秀的人。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/8.png" alt="9CE5E3FDD31967D5D0140BB2F68751A9.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉自己真的很幸运，这么多年都没有碰到过坏人。从入学认识的室友、导员，到后面认识的学长学姐：胡仓学长、宋扬学长、彩嵘学长、文炀学长、嘉文学长，再到食铁兽认识的小伙伴：源哥、峰哥、婧姐、洋哥，再到通明智云的同事和leader，还有现在的mentor、同事和leader，大家都是很好很好的人，相处起来都非常舒服，感谢所有遇见。<br>        大三还没结束，要做的事情还有很多。回头看看其实比起刚入学那一会，我已经成长不少了，也学会了一些道理。也培养了一些比较好的习惯，比如我上大学前完全想不到我现在在假期也会学习、会定期阅读和运动、会主动走出舒适区去学一些我觉得我应该会的技能。</p>
<p>当然大学里也有一些不好的经历，甚至有些事情我到现在也没有想明白原因，不明白自己为什么要被这么对待。虽然不理解，但是也只能试着接受。</p>
<p>希望我能过好大学的最后一年零几个月的生活，收拾行囊，再度出发吧。也希望我能一直热爱编程，热爱我的事业。我几乎不在社交媒体上发编程相关的东西，一是觉得我还是个noob，需要学习的东西还有很多；二是不爱给自己打上程序员的这个tag，不想给自己设限。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">MySQL主键相关的一些思考及方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-02 23:10:48 / 修改时间：23:12:44" itemprop="dateCreated datePublished" datetime="2023-03-02T23:10:48+08:00">2023-03-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL创建表的时候可以不设置主键吗？"><a href="#MySQL创建表的时候可以不设置主键吗？" class="headerlink" title="MySQL创建表的时候可以不设置主键吗？"></a>MySQL创建表的时候可以不设置主键吗？</h3><p>MySQL创建表的时候是可以不主动设置主键的，但是表是一定需要一个主键的，MySQL会主动将第一个不为null的唯一索引设置为主键</p>
<h3 id="为什么MySQL推荐使用自增id作为主键？"><a href="#为什么MySQL推荐使用自增id作为主键？" class="headerlink" title="为什么MySQL推荐使用自增id作为主键？"></a>为什么MySQL推荐使用自增id作为主键？</h3><p>mysql官方推荐不要使用uuid或者不连续不重复的雪花作为主键，而是使用连续自增的主键id</p>
<p><strong>使用自增id的内部结构</strong></p>
<p>自增id的值是顺序的，所以innodb在索引B+树的叶子节点层面可以直接把每一条记录都存储在上一条记录的后面，当达到页面的最大填充因子的时候（页面容量已经满了）下一条记录就会写入新的页中，数据按照这种顺序的方式进行填充，主键页就会以近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费</p>
<p>新插入的行一定会在原有的最大数据行下一行，MySQL定位和寻址非常快，不会因为计算而做出额外的消耗，</p>
<p>并且能够减少页分裂和碎片的产生</p>
<p>页分裂：保证后一个数据页的所有行主键值比前一个数据页的主键值大，所以当ID不为自增的主键的时候，就会导致后一个页的所有行并不一定比前一个数据页的行的id大。这时就会触发页分裂的逻辑，对两个页之间的数据进行调整，甚至会涉及到多个数据页，导致性能降低</p>
<h3 id="使用自增id的缺点"><a href="#使用自增id的缺点" class="headerlink" title="使用自增id的缺点"></a>使用自增id的缺点</h3><ol>
<li>别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你业务的增长信息，从而分析出经营情况</li>
<li>对于高并发的负载，innodb在按照主键进行插入的时候会造成明显的锁争用，auto_increment锁机制会造成自增锁的争夺，有一定的性能损失</li>
</ol>
<h3 id="为什么分布式系统不用自增id，而是要用雪花算法生成id"><a href="#为什么分布式系统不用自增id，而是要用雪花算法生成id" class="headerlink" title="为什么分布式系统不用自增id，而是要用雪花算法生成id"></a>为什么分布式系统不用自增id，而是要用雪花算法生成id</h3><p>分布式id创建的业务需求</p>
<ol>
<li>全局唯一</li>
<li>趋势递增 innodb引擎的叶子结点是有序的双向链表，趋势递增可以增加性能，不会打乱树的结构</li>
<li>信息安全</li>
<li>最好包含时间戳</li>
</ol>
<p>为什么自增id不适合分布式系统？</p>
<p>当数据庞大的时候，在数据库分库分表之后，数据库自增id不能满足唯一id来表示数据；因为每个表都按照自己的节奏自增，会造成id冲突，从而无法满足需求</p>
<h3 id="使用auto-increment实现廉价的分布式唯一主键"><a href="#使用auto-increment实现廉价的分布式唯一主键" class="headerlink" title="使用auto_increment实现廉价的分布式唯一主键"></a>使用auto_increment实现廉价的分布式唯一主键</h3><p>flickr有类似的方案，构建是一个专用的数据库服务器，上面只有一个数据库，在数据库里面有用于32位id和64位id的id表，id是auto自增的，所有数据库生成id都会向这个服务器发请求，然后服务器分发id下去，也能达到一种分布式唯一主键的效果</p>
<p>类似于session-redis的思想，把所有的sessionid都存在redis里面，所有的服务器实例在比较cookie的时候就先去redis里面比较，这样就能避免因为负载均衡导致的cookie失效问题</p>
<p>当然这个廉价的做法显然是有很大问题的</p>
<ol>
<li>并发量很小，因为只有一台服务器</li>
<li>增加开销，并且整个请求流程变慢，因为需要向服务器发请求，并且是在硬盘层面进行操作的</li>
<li>flickr服务器成了整个系统的瓶颈和隐患，如果服务器宕机整个系统直接崩掉了</li>
</ol>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>是twitter开源的分布式id生成算法，结果是一个64位的longint类型，核心思想是用41位来作为时间戳，10位来作为机器的id,12位作为毫秒内的流水号（意味着每个节点可以在每毫秒生成4096个id），最后还有一个符号为永远为0 </p>
<p><strong>优点</strong></p>
<ul>
<li>完全在内存生成，高性能高可用</li>
<li>容量大，每秒可以生成几百万id</li>
<li>趋势递增，插入数据库索引树的时候，性能比较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>依赖系统时钟的一致性，如果某台机器的系统时钟回拨，有可能造成id冲突</li>
<li>多台机器的ID只能保证趋势增加，即每一台机器都能保证这台机器生成的ID是在增加的，但是多台机器并不一定绝对递增</li>
<li>41位时间戳只能保证69年无重复ID</li>
<li>因为是64位的ID，在传递给前端的时候需要用字符串的类型进行传递，因为js的number类型最大只支持53位</li>
</ul>
<h3 id="其他分布式ID方案"><a href="#其他分布式ID方案" class="headerlink" title="其他分布式ID方案"></a>其他分布式ID方案</h3><ul>
<li>UUID:JAVA自带的API，生成一个唯一性的字符串，不能保证有序递增</li>
<li>UidGenerator:百度开源的分布式ID生成器，基于雪花算法</li>
<li>Leaf:美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但是需要依赖关系数据库、Zookeeper等中间件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">中台是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 08:28:04 / 修改时间：08:28:51" itemprop="dateCreated datePublished" datetime="2023-03-01T08:28:04+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中台是一个非常宽泛的概念，可以是技术平台，比如框架、devops平台、容器云之类的，也可以是业务平台，像用户中心、订单中心、各种微服务集散。</p>
<h3 id="为什么需要中台？"><a href="#为什么需要中台？" class="headerlink" title="为什么需要中台？"></a>为什么需要中台？</h3><p>中台的产生可能是高层的战略设计，也可能是公司不断膨胀而暴露出来的种种问题需要被解决。</p>
<p>中台一开始诞生于16年阿里提出的“大中台，小前台”概念，中台的价值是以快速响应需求为依切，中台并不是一开始就有的，而是基于“前台+后台”的架构发展演变的</p>
<p>前台：系统的前端平台，是直接与终端用户进行交互的应用层，比如日常使用的app,h5（html5 通常用来写移动端的前端和web的前端）,pc端都是属于前台</p>
<p>后台：后台是指系统的后端平台，终端用户无法感知，提供后端服务</p>
<p>因为用户的需求是会高速变化的，而用户需求的变化决定了前台系统需要快速迭代响应用户需求，而前端的变化又需要后端的变化来进行支撑，这就对后台的快速应变提出了要求，而后台的核心目的并不是服务于前台，而是提升后端数据的安全及系统的管理效率</p>
<p>于是就产生了“前端为了用户需求，期望系统不断的快速迭代”与“后段为了数据安全与系统稳定，期望系统趋于稳定”的矛盾局面，为了解决这一矛盾，架构师们创造性的提出了“中台”这一概念，核心就是将后台的逻辑层进行拆离，形成前端（应用层）-中台（逻辑层）-后台（数据层）的产品架构，在这一架构下，当前端需求出现时，中台能够快速的进行响应，从而提升了研发效率，降低了创新成本</p>
<p>阿里中台战略最早从业务中台和数据中台建设开始，采用了双中台的建设模式，到后来发展出了移动中台，技术中台和研发中台等等。</p>
<p><img src="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/1677551872346-10e243df-5756-457d-ba84-cfa2585f525c.png" alt="img"></p>
<h3 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h3><p>一般是指支持企业线上核心业务的中台，承载了核心业务能力，实现企业级业务能力复用和各业务板块之间的联通和协同</p>
<h3 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h3><p>与业务中台相辅相成，共同支持前台一线业务，大部分数据来源于业务中台，经过数据建模和数据分析等操作之后，将加工后的数据返回业务中台为前台应用提供服务，或者直接以数据类应用的方式向前台应用提供api数据服务，一般包括数据采集、数据生成、数据治理、数据应用以及数据仓库或大数据等技术应用</p>
<h3 id="技术中台"><a href="#技术中台" class="headerlink" title="技术中台"></a>技术中台</h3><p>业务中台落地的时候需要很多的技术组建来支撑，这些不同技术领域的技术组建就组成了技术中台。比如一些业务关键技术的组件</p>
<ul>
<li>api网关</li>
<li>开发框架</li>
<li>微服务治理</li>
<li>分布式数据库</li>
<li>数据处理组件</li>
</ul>
<p> <strong>api网关</strong></p>
<p>前后端分离，通过网关实现前后端集成，api网关主要包括：鉴权、降级限流、流量分析、负载均衡、服务路由和访问日志等功能。api网关可以帮助用户方便地管理微服务api接口，实现安全的前后端分离，实现高效的系统集成和精细的服务监控</p>
<p><strong>开发框架</strong></p>
<p>开发框架主要包括前端开发和后端微服务开发框架，支持代码自动生成，本地调试和依赖管理等功能</p>
<p><strong>微服务治理</strong></p>
<p>服务治理是在为服务的运行过程中，针对微服务的运行状况采取的动态治理策略，如服务注册、发现、限流、 熔断和降级等等，以保障微服务能够持续稳定的运行</p>
<p>治理主要应用于微服务运行中的状态监控、微服务运行异常时的治理策略配置等场景，保障微服务在常见异常场景下的自恢复能力</p>
<p><strong>分布式数据库</strong></p>
<p>分布式数据库一般都具有较强的数据线性拓展能力，它们大多采用数据多副本机制实现数据库高可用，具有可拓展和低成本等技术优势，一般分为三类：交易型、分析型、交易分析混合型</p>
<ul>
<li>交易型：用于解决交易类业务的数据库计算能力，支持数据分库、分片、数据多副本，具有高可用的特性，提供统一的运维界面，具备高性能的交易型业务处理分析能力。</li>
<li>分析型：通过横向扩展能力和并行计算能力，提高数据整体计算能力和吞吐量，支持海量数据的分析</li>
<li>混合型：通过资源隔离、分时和数据多副本等技术手段，基于不同的数据存储、访问性能和容量等需求，使用不同的存储介质和分布式计算存储，同时满足业务交易和分析需求</li>
</ul>
<p><strong>数据处理组件</strong></p>
<p>为了提高应用性能和业务的承载能力，降低微服务的耦合度，实现分布式架构下的分布式事务等要求，技术中台还有很多数据处理相关的基础技术组件。如分布式缓存、搜索引擎、数据复制、消息中间件和分布式事务等技术组建</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生学习（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 12:45:05" itemprop="dateCreated datePublished" datetime="2023-02-26T12:45:05+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 22:43:12" itemprop="dateModified" datetime="2023-02-27T22:43:12+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC是一种现代化开源的RPC框架，由Google进行研发，能够运行于任何环境之中，最初由谷歌进行开发，它使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC中，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，帮助你更容易创建分布式应用程序和服务。gRPC是基于定义一个服务，制定一个可以远程调用的带有参数和返回类型的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用，在客户端，有一个stub提供和服务端相同的方法</p>
<p><img src="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/1676256947622-90dcc6f3-615b-4154-a261-5a45a2beedbc.png" alt="img"></p>
<h3 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h3><p>gRPC可以帮助我们一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，也就是说gRPC解决了<strong>不同语言以及环境间通信的复杂性</strong>。使用<code>protocol buffer</code>还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之，使用gRPC能够帮助我们更容易编写跨语言的分布式代码</p>
<p>IDL（Interface description Language） 是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成</p>
<h3 id="使用gRPC进行开发的步骤"><a href="#使用gRPC进行开发的步骤" class="headerlink" title="使用gRPC进行开发的步骤"></a>使用gRPC进行开发的步骤</h3><p><strong>1.编写.proto文件定义服务</strong></p>
<p>默认情况下gRPC使用<code>protocol buffers</code>作为接口定义语言（IDL）来描述服务接口和有效负载消息的结构</p>
<p>在gRPC中可以定义四种类型的服务方法 	</p>
<p>普通rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>服务器流式rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，知道没有更多的消息，gRPC保证在单个RPC调用的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>客户端流式rpc，其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应，同样，gRPC保证单个RPC调用中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LostsOfGreetings(stream HelloRequest) returns(HelloResponse);</span><br></pre></td></tr></table></figure>

<p>双向流式rpc，其中双方使用读写流发送一系列消息，这两个流独立运行，因此客户端和服务器可以按照自己指定的顺序读写；例如，服务器可以等待接受所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc StreamGreetings(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p><strong>2.生成指定语言的代码（客户端一份、服务端一份）</strong></p>
<p>在<code>.proto</code>文件中定义好服务之后，gRPC提供了生成客户端和服务端代码的protocol buffers编译器插件。</p>
<p>我们使用这些插件可以根据需要生成<code>Java Go C++ Python</code>等语言的代码，我们通常会在客户端调用这些API，并且在服务器端实现对应的API</p>
<ul>
<li>在服务器端，服务器实现服务声明的方法，并运行一个gRPC服务器来处理客户端发来的调用请求。gRPC底层会对传入的请求进行编码，执行被调用的服务方法，并对服务响应进行编码</li>
<li>在客户端，客户端有一个称为存根(stub)的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的<code>protocol buffers</code>消息类型中–gRPC在向服务器发送请求并返回服务器的<code>protocol buffers</code>响应之后进行处理</li>
</ul>
<p><strong>3.编写业务逻辑代码</strong></p>
<p>proto文件生成<code>pb.go</code>以及<code>grpc.pb.go</code>的命令</p>
<p>不指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>

<p>指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=xx --go_out=pb --go_opt=paths=source_relative --go-grpc_out=pb --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>



<h3 id="使用grpc实现一个简单的hello服务"><a href="#使用grpc实现一个简单的hello服务" class="headerlink" title="使用grpc实现一个简单的hello服务"></a>使用grpc实现一个简单的hello服务</h3><p><strong>Server</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer //当没有完全实现proto中的所有方法时依旧可以运行起来</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// gRPC通过.proto文件自动生成的SayHello方法  </span><br><span class="line">func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) &#123;</span><br><span class="line">	reply := &quot;hello&quot; + in.GetName()</span><br><span class="line">	return &amp;pb.HelloResponse&#123;Reply: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:8972&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to listen,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 注册服务</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	// 启动服务</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_server/pb&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//连接server 带加密连接</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:8972&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;grpc.Dial failed,err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	//创建客户端</span><br><span class="line">	c := proto.NewGreeterClient(conn)</span><br><span class="line">	//使用context进行控制，传入background和超时时间一秒钟</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	name := &quot;xiaocheng&quot;</span><br><span class="line">	resp, err := c.SayHello(ctx, &amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.SayHello failed, err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 拿到RPC响应</span><br><span class="line">	log.Printf(&quot;resp:%v&quot;, resp.GetReply())</span><br><span class="line">&#125;</span><br><span class="line">// 应该是同一份proto文件</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_client/proto&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块 必须与server端一致</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用grpc实现一个简单的add服务"><a href="#使用grpc实现一个简单的add服务" class="headerlink" title="使用grpc实现一个简单的add服务"></a>使用grpc实现一个简单的add服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedAddMethodServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *server) Add(ctx context.Context, in *pb.AddRequest) (*pb.AddResponse, error) &#123;</span><br><span class="line">	reply := in.GetArgs1() + in.GetArgs2()</span><br><span class="line">	return &amp;pb.AddResponse&#123;Number: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;net listen failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterAddMethodServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>proto文件应该在客户端和服务端都有一份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">option go_package=&quot;server/pb&quot;;</span><br><span class="line">package pb;</span><br><span class="line"></span><br><span class="line">service AddMethod &#123;</span><br><span class="line">   rpc Add(AddRequest) returns (AddResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddRequest &#123;</span><br><span class="line">  int32 args1 =1;</span><br><span class="line">  int32 args2 =2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddResponse &#123;</span><br><span class="line">  int32 number =1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:9999&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;grpc dail failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	c := pb.NewAddMethodClient(conn)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	var args1, args2 int32</span><br><span class="line">	args1 = 1</span><br><span class="line">	args2 = 2</span><br><span class="line">	resp, err := c.Add(ctx, &amp;pb.AddRequest&#123;Args1: args1, Args2: args2&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;c.Add failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(&quot;Add Response:&quot;, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protobuf语法"><a href="#protobuf语法" class="headerlink" title="protobuf语法"></a>protobuf语法</h3><p><strong>protobuf为什么体积小、解析快</strong></p>
<p>protobuf是google提出的数据交换格式，同一条消息数据，使用Protobuf序列化之后占用空间是json的1&#x2F;10，但是性能却是几十倍</p>
<p>原因</p>
<ul>
<li>编解码大多采用位运算，比JSON&#x2F;XML的字符匹配效率更高</li>
<li>pb定义了varint类型，使用变长编码压缩数值类型。值越小的数字，使用的字节数就越少</li>
<li>采用Tag-value类型，没有冗余字符</li>
</ul>
<p><strong>定义一个消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">	string query =1;</span><br><span class="line">	int32 page_number=2; </span><br><span class="line">&#125;</span><br><span class="line">//文件的第一行指定使用proto3语法，如果不这么写</span><br><span class="line">//pb的编译器默认使用proto2</span><br><span class="line"></span><br><span class="line">//SearchRequest定义了一个消息，使用了两个字段</span><br><span class="line">//每个字段需要定义类型 名字 和编号</span><br></pre></td></tr></table></figure>



<p><strong>字段编号</strong></p>
<p>消息定义中的每个字段都要有一个唯一的编号，这些编号用来在消息二进制格式中标识字段，<strong>在消息类型使用后就不能更改</strong>。在范围1到15中的字段需要一个字节进行编码，而16-2047的字段采用两个字节。所以应该为经常使用的消息元素保留数字1到15的编号，也要为将来可能添加的经常使用的元素留出一些编号</p>
<p><strong>指定字段规则</strong></p>
<p>消息字段可以是下列字段之一</p>
<ul>
<li>singular：格式正确的消息可以有这个字段的0个或者一个，默认使用singular字段</li>
<li>repeated：该字段可以在格式正确的消息中重复任意次数（包括0次），重复值的顺序将被保留</li>
<li>optional：该字段在传递的时候可选也可不选</li>
</ul>
<p><strong>保留字段</strong></p>
<p>如果你通过完全删除字段或者将其注释来<strong>更新消息类型，</strong>那么未来的用户在对该类型进行自己的更新的时候就可以重用字段号，如果其他人以后加载旧版本的相同<code>.proto</code>文件，这可能就会导致严重的问题，比如数据损坏、隐私漏洞等等。</p>
<p>解决方法是指定已经删除的字段的字段编号，如果将来有用户尝试使用这些字段标识符，protocol buffer编译器将发出提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">reserved 2,15,9 to 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>值类型</strong></p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java&#x2F;Kotlin Type[1]</th>
<th>Python Type[3]</th>
<th>Go Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint32代替。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>int64</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint64代替。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码。</td>
<td>uint64</td>
<td>long[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>sint32</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int32更有效地编码负数。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int64更有效地编码负数。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是四个字节。如果值经常大于228，则比 uint32更有效率。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8字节。如果值经常大于256，则比 uint64更有效率。</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是四个字节。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是八个字节。</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>字符串必须始终包含 UTF-8编码的或7位 ASCII 文本，且不能长于232。</td>
<td>string</td>
<td>String</td>
<td>str&#x2F;unicode[5]</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可以包含任何不超过232字节的任意字节序列。</td>
<td>string</td>
<td>ByteString</td>
<td>str (Python 2) bytes (Python 3)</td>
<td>[]byte</td>
<td>string</td>
</tr>
</tbody></table>
<p><strong>枚举</strong></p>
<p>在定义消息类型的时候，可能希望其中的一个字段只能是预定义的值列表中的一个值。下面是一个栗子，Conrpus字段的值只能是其中的一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">string query = 1;</span><br><span class="line">  int32 page_number = 2;</span><br><span class="line">  int32 result_per_page = 3;</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = 4;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>嵌套消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated Result results = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  string url = 1;</span><br><span class="line">  string title = 2;</span><br><span class="line">  repeated string snippets = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Any</strong></p>
<p>Any类型允许你将消息作为嵌入类型使用，使用Any类型需要导入<code>google/protobuf/any.proto</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">  repeated google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>oneof</strong></p>
<p>如果你有一条包含多个字段的消息，并且同时最多设置其中的一个字段，那么可以通过oneof来实现并节省内存，可以通过<code>case()</code>或者<code>WihchOneOf()</code>来检查one  of 中的哪个值被设置（如果有）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string name = 4;</span><br><span class="line">    SubMessage sub_message = 9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> SampleMessage message;</span><br><span class="line">  message.set_name(&quot;name&quot;);</span><br><span class="line">  CHECK(message.has_name());</span><br><span class="line">  message.mutable_sub_message();   // Will clear name field.</span><br><span class="line">  CHECK(!message.has_name());</span><br></pre></td></tr></table></figure>

<p><strong>Maps</strong></p>
<p>如果想创建一个关联映射作为数据定义的一部分，可以使用这个map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<h3 id="protobuf实战"><a href="#protobuf实战" class="headerlink" title="protobuf实战"></a>protobuf实战</h3><p><strong>oneof字段</strong></p>
<p>oneof中的值只能选择其中的一个  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message NoticeReaderRequest &#123;</span><br><span class="line">  string msg=1;</span><br><span class="line">  oneof notice_way&#123;</span><br><span class="line">    string email=2;</span><br><span class="line">    string phone=3;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的服务端代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func oneofDemo() &#123;</span><br><span class="line">	req := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is chengxisheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Email&#123;</span><br><span class="line">			Email: &quot;xxx&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	req2 := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is xishengcheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Phone&#123;</span><br><span class="line">			Phone: &quot;1008611&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req2.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithEmail(in *book.NoticeReaderRequest_Email) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by email:%v\n&quot;, in.Email)</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithPhone(in *book.NoticeReaderRequest_Phone) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by phone:%v\n&quot;, in.Phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里必须使用类型断言+switch case </span><br><span class="line">//来进行one of 字段的确认</span><br></pre></td></tr></table></figure>

<p><strong>wrapvalue类型</strong></p>
<p>首先让我们想一想Go中区分一个MySQL的int类型是默认值还是0值该怎么做？</p>
<p>其实就只有以下两种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">price sql.NullInt64</span><br><span class="line">price *int64</span><br><span class="line">//第一种方式是一个定义好的结构体 </span><br><span class="line">//里面有一个字段是 该结构体是否被赋值</span><br><span class="line">//第二种方式是直接用指针来做</span><br><span class="line">//对指针解引用，如果为0则赋值，如果为Nil则是默认值</span><br><span class="line">func wrapValueDemo() &#123;</span><br><span class="line">	// client</span><br><span class="line">	 book:=book.Book&#123;</span><br><span class="line">		 Title: &quot;learning go language&quot;,</span><br><span class="line">		 Price: &amp;wrapperspb.Int64Value&#123;Value: 600&#125;,</span><br><span class="line">		 Memo: &amp;wrapperspb.StringValue&#123;Value: &quot;学&quot;&#125;,</span><br><span class="line">	 &#125;</span><br><span class="line">	 // server </span><br><span class="line">	 if book.GetPrice()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetPrice().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">	 if book.GetMemo()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetMemo().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FieldMask类型</strong></p>
<p>当我们更新的时候，定义了很多字段，不可能全部进行全量更新Book的每个字段，因为通常操作只会更新1到2个字段。</p>
<p>当我们想知道更新操作涉及到的具体字段，就需要使用到filedmask类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // 操作人</span><br><span class="line">  string op =1;</span><br><span class="line">  // 要更新的书籍信息</span><br><span class="line">  Book book=2;</span><br><span class="line">  // 要更新的字段</span><br><span class="line">  google.protobuf.FieldMask update_mask=3;</span><br><span class="line">&#125;</span><br><span class="line">func fieldMaskDemo() &#123;</span><br><span class="line">	//client</span><br><span class="line">	paths := []string&#123;&quot;price&quot;&#125;</span><br><span class="line">	req := &amp;book.UpdateBookRequest&#123;</span><br><span class="line">		Op: &quot;chengxisheng&quot;,</span><br><span class="line">		Book: &amp;book.Book&#123;</span><br><span class="line">			Price: &amp;wrapperspb.Int64Value&#123;Value: 8800&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateMask: &amp;fieldmaskpb.FieldMask&#123;Paths: paths&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	mask, _ := fieldmask_utils.MaskFromProtoFieldMask(req.UpdateMask, generator.CamelCase)</span><br><span class="line">	var bookDst = make(map[string]interface&#123;&#125;)</span><br><span class="line">	fieldmask_utils.StructToMap(mask, book.UpdateBookRequest&#123;&#125;.Book, bookDst)</span><br><span class="line">	fmt.Printf(&quot;bookDst:%#v\n&quot;, bookDst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端流式RPC"><a href="#服务端流式RPC" class="headerlink" title="服务端流式RPC"></a>服务端流式RPC</h3><p>对应的proto（client和server）中添加一个流式方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>



<p>Server添加一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfReplies(in *pb.HelloRequest, stream pb.Greeter_LotsOfRepliesServer) error &#123;</span><br><span class="line">	words := []string&#123;</span><br><span class="line">		&quot;你好&quot;,</span><br><span class="line">		&quot;hello&quot;,</span><br><span class="line">		&quot;こんにちは&quot;,</span><br><span class="line">		&quot;안녕하세요&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	for _, word := range words &#123;</span><br><span class="line">		data := &amp;pb.HelloResponse&#123;</span><br><span class="line">			Reply: word + in.GetName(),</span><br><span class="line">		&#125;</span><br><span class="line">		// 使用Send方法发送多个数据 每当有一个data就send一次数据</span><br><span class="line">		if err := stream.Send(data); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端添加一个新的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func callLotsOfReplies(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	stream, err := c.LotsOfReplies(ctx, &amp;proto.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	for &#123;</span><br><span class="line">		//依次从流式响应中读取返回的响应数据</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;got reply: %q\n&quot;, res.GetReply())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端流式RPC"><a href="#客户端流式RPC" class="headerlink" title="客户端流式RPC"></a>客户端流式RPC</h3><p>在<code>hello.proto</code>中添加这么一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在server端添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfGreetings(stream pb.Greeter_LotsOfGreetingsServer) error &#123;</span><br><span class="line">   reply := &quot;你好:&quot;</span><br><span class="line">   for &#123;</span><br><span class="line">      //接受客户端发来的流式数据</span><br><span class="line">      res, err := stream.Recv()</span><br><span class="line">      if err == io.EOF &#123;</span><br><span class="line">         return stream.SendAndClose(&amp;pb.HelloResponse&#123;</span><br><span class="line">            Reply: reply,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         return err</span><br><span class="line">      &#125;</span><br><span class="line">      reply += res.GetName()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Client端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func runLotsOfGreeting(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	defer cancel()</span><br><span class="line">	// 客户端要流式的发送请求消息</span><br><span class="line">	stream, err := c.LotsOfGreetings(ctx)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.LotsOfGreetings failed,err:%v\n&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	names := []string&#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;</span><br><span class="line">	for _, name := range names &#123;</span><br><span class="line">		stream.Send(&amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">		time.Sleep(200 * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	//关闭流</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	log.Printf(&quot;res:%v\n&quot;, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向流式RPC"><a href="#双向流式RPC" class="headerlink" title="双向流式RPC"></a>双向流式RPC</h3><p>在proto中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在client中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在Server端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// magic 一段价值连城的“人工智能”代码</span><br><span class="line">func magic(s string) string &#123;</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吗&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吧&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;你&quot;, &quot;我&quot;)</span><br><span class="line"></span><br><span class="line">	s = strings.ReplaceAll(s, &quot;？&quot;, &quot;!&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;?&quot;, &quot;!&quot;)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MetaData元数据"><a href="#MetaData元数据" class="headerlink" title="MetaData元数据"></a>MetaData元数据</h3><p>metadata是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用的是键值对列表 的形式，其中键是string类型，值通常是[]string类型，但也可以是二进制数据。gRPC中的metadata类似于我们在HTTP headers中的键值对，元数据可以包含认真token、请求标识和监控标签等等</p>
<p>metadata中的键是大小写不敏感的，不能以grpc-开头，并且二进制的简明必须以-bin结尾，元数据对gRPC本身是不可见的，通常在应用程序代码或者中间件中处理元数据，我们不需要再.proto中指定元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MD map[string][]string</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-24 12:07:13 / 修改时间：12:08:30" itemprop="dateCreated datePublished" datetime="2023-02-24T12:07:13+08:00">2023-02-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h3><p>用架构历史</p>
<p>1.单体架构 堆机子 高耦合 一改动就需要重新部署 而且编译时间很长，不容易拓展，不支持多语言技术栈 </p>
<p>2.分层架构 典型的有MVC和MSC架构 当访问量逐渐增大，单体架构扛不住了，把单体项目进行垂直划分，耦合还是很大，项目之间的接口多为数据同步，比如不同项目之间的数据库同步。 架构简单，成本低开发周期短，经过垂直拆分之后原来的单体项目不至于太大，每一层可以用不同的技术，但还是不易拓展和维护 </p>
<p>3.SOA面向服务架构 ：当垂直架构的应用越来越多，就会出现多个应用都依赖的业务组件，比如数据库，而且各个应用交互越来越频繁，此时就需要把部分通用的组件拆分独立处理，于是SOA面向服务架构诞生了，它带来了模块化开发、分布式拓展部署和服务接口定义等概念</p>
<p>实时SOA需要建立企业服务总线，外部应用通过总线调用服务，有以下特征：可从企业外部访问、随时可用、标准化的服务接口等</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>已经具有微服务的影子了，将重复的功能抽离出来，提高开发效率</li>
<li>减少接口耦合</li>
</ul>
<p>SOA架构适用于大型软件服务企业对外提供服务的场景，并不适合一般的业务场景，其服务的定义、注册和调用都需要繁琐的配置，业务总线的吞吐量决定了整个系统的上限，因为整个系统都是通过总线进行任务分配的。并且业务总线也容易导致系统崩掉、影响性能。</p>
<p>4.微服务架构：</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt="img"></p>
<p>特点</p>
<p>1.服务层完全独立出来 并将服务层抽取为一个一个的微服务</p>
<p>2.微服务遵循单一原则</p>
<p>3.微服务之间采用RESTful等轻量协议通信</p>
<p>4.微服务一般用容器技术部署 运行在自己的独立进程中</p>
<p>微服务架构下服务的拆分粒度更细，有利于资源重复利用，提高开发效率，采用去中心化思想，更轻量级</p>
<p>缺点：如果服务实例过多，治理成本就会很大，不利于维护；服务之间相互依赖，可能形成复杂的依赖链条，往往单个服务异常，其他服务也会受到影响，出现服务雪崩效应。</p>
<p>微服务与SOA的区别：</p>
<p>微服务继承了SOA的众多优点和理念</p>
<p>SOA更适合与许多其他应用程序继承的大型复杂企业应用程序环境，小型的应用并不适合SOA，微服务则更适合于较小和良好的分割式web业务系统</p>
<p>微服务不再强调SOA架构中比较重要的ESB企业服务总线，而是通过轻量级通信机制相互沟通</p>
<p>SOA注重的是系统继承，而微服务关注的则是完全分离，SOA尝试采用中心化管理来确保各个应用能够协同运作，微服务则尝试部署新功能，快速有效地拓展开发团队，它着重于分散管理、代码再利用和自动化执行。</p>
<h3 id="微服务的优势和劣势"><a href="#微服务的优势和劣势" class="headerlink" title="微服务的优势和劣势"></a>微服务的优势和劣势</h3><p>微服务的优势</p>
<p>1.快：更注重CI&#x2F;CD 敏捷开发、持续交付</p>
<p>2.准：服务粒度小、服务质量精准可控</p>
<p>3.狠：适用于互联网时代、产品迭代周期更短</p>
<p>微服务的劣势</p>
<p>1.系统的复杂性</p>
<p>2.服务依赖管理</p>
<p>3.数据的一致性保障</p>
<p>4.测试更加艰难</p>
<p>5.对于DevOps等基础设施的高要求</p>
<h3 id="如何划分微服务界限"><a href="#如何划分微服务界限" class="headerlink" title="如何划分微服务界限"></a>如何划分微服务界限</h3><p>如何进行服务划分？</p>
<p>1.按照业务职能进行划分</p>
<p>由公司内部不同部门提供的只能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能</p>
<p>2.按照DDD的限界上下文划分</p>
<p>限界上下文是DDD中用来划分不同业务边界的元素</p>
<p>这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域</p>
<p>为了解决某种类型的业务问题，贴近领域只是，也就是业务</p>
<p>CQRS将系统中的操作划分为两类，即【命令】Command和【查询】Query</p>
<p>命令则是对会引起数据发生变化操作的总称，即我们常说的新增、更新、删除的这些操作，都是命令。</p>
<p>而查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查询数据。</p>
<p>CQRS的核心思想是将两类不同的操作进行分离，然后在两个独立的【服务】中实现。这里的服务一般指的是两个独立部署的应用，在某些特殊情况下，也可以部署在同一个应用内的不同接口上。 </p>
<h3 id="微服务的迭代"><a href="#微服务的迭代" class="headerlink" title="微服务的迭代"></a>微服务的迭代</h3><p>1.第一代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt="img"></p>
<p>2.第二代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt="img"></p>
<p>把那些服务监控、服务管理作为基础服务提供给我们的业务</p>
<p>架构分层</p>
<p> <img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/5.png" alt="img"></p>
<p>核心组件</p>
<ul>
<li>API网关</li>
<li>服务注册中心</li>
<li>配置中心</li>
<li>服务通信</li>
<li>服务治理</li>
<li>服务监控</li>
</ul>
<h2 id="net-x2F-rpc"><a href="#net-x2F-rpc" class="headerlink" title="net&#x2F;rpc"></a>net&#x2F;rpc</h2><h3 id="RPC出现的原因"><a href="#RPC出现的原因" class="headerlink" title="RPC出现的原因"></a>RPC出现的原因</h3><p>RPC需要解决三个问题</p>
<p>1.如何要确定要执行的函数？在本地调用中，函数主体通过函数指针函数指定，然后调用add函数，编译器你通过函数指针函数确定add函数在内存中的位置。但是在RPC中，调用不能通过函数指针完成，因为他们的内存地址可能完全不同。因此，调用方和被调用方都需要维护一个{fuction&lt;-&gt;ID}映射表，以确保调用正确的函数</p>
<p>2.如何表达参数？本地过程调用中传递的参数是通过堆栈结构实现的，但是RPC不能直接使用内存传递参数，因此参数或返回值需要在传输期间徐丽湖儿啊并转换成字节流，反之亦然</p>
<p>3.如何通过网络传输？函数的调用方和被调用方通常是通过网络连接的，也就是说 function ID和序列化字节流需要通过网络传输，因此，只要能够完成传输，调用方和被调用方就不受某个网络协议的限制。例如，一些RPC框架使用TCP协议，一些使用HTTP。</p>
<p>以往实现跨服务调用的时候，我们会采用restful api的方式，被调用方会对外提供一个HTTP接口，调用方按要求发起HTTP请求并接收API接口返回的响应数据。</p>
<p>本地调用，通过HTTP的API的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">//定义参数和响应  </span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(x, y int) int &#123;</span><br><span class="line">	return x + y</span><br><span class="line">&#125;</span><br><span class="line">// addHandler 解析参数+调用add+响应写回</span><br><span class="line">func addHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	// parse parameters</span><br><span class="line">	b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	var param addParam</span><br><span class="line">	json.Unmarshal(b, &amp;param)</span><br><span class="line">	// use the add func</span><br><span class="line">	ret := add(param.X, param.Y)</span><br><span class="line">	// return the response</span><br><span class="line">	respBytes, _ := json.Marshal(addResult&#123;Code: 0, Data: ret&#125;)</span><br><span class="line">	w.Write(respBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/add&quot;, addHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:9090&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	url := &quot;http://127.0.0.1:9090/add&quot;</span><br><span class="line">	param := addParam&#123;</span><br><span class="line">		X: 10,</span><br><span class="line">		Y: 20,</span><br><span class="line">	&#125;</span><br><span class="line">	// marshal to json</span><br><span class="line"></span><br><span class="line">	paramBytes, _ := json.Marshal(param)</span><br><span class="line">	// call</span><br><span class="line">	resp, _ := http.Post(url, &quot;application/json&quot;, bytes.NewReader(paramBytes))</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line">	respBytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	var respData addResult</span><br><span class="line">	json.Unmarshal(respBytes, &amp;respData)</span><br><span class="line">	fmt.Println(respData.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而RPC调用则不需要如此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">service.go</span><br><span class="line">type Args struct &#123;</span><br><span class="line">	X, Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ServiceA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Add is an out method</span><br><span class="line">// has two args and a return </span><br><span class="line">// two params must be out </span><br><span class="line">// and the return value must be error type </span><br><span class="line">func (s *ServiceA) Add(args *Args, reply *int) error &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line">server.go</span><br><span class="line">func main() &#123;</span><br><span class="line">  //new service instance   </span><br><span class="line">	service := new(yunyuansheng.ServiceA)</span><br><span class="line">  //register rpc service   </span><br><span class="line">	rpc.Register(service) </span><br><span class="line">  //botton on http  </span><br><span class="line">	//rpc.HandleHTTP()      </span><br><span class="line">  //botton on tcp   </span><br><span class="line">	l, e := net.Listen(&quot;tcp&quot;, &quot;:9091&quot;)</span><br><span class="line">	if e != nil &#123;</span><br><span class="line">		log.Fatal(&quot;listen error:&quot;, e)</span><br><span class="line">	&#125;</span><br><span class="line">	//http.Serve(l, nil)</span><br><span class="line">	for &#123;</span><br><span class="line">	  // accpet the request and serve   </span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">client.go</span><br><span class="line">func main() &#123;</span><br><span class="line">	//因为服务端是HTTP请求 所以要建立HTTP连接</span><br><span class="line">	client, err := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:9091&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 同步调用 Call</span><br><span class="line">	args := &amp;yunyuansheng.Args&#123;10, 20&#125;</span><br><span class="line">	reply := new(int)</span><br><span class="line">	err = client.Call(&quot;ServiceA.Add&quot;, args, reply)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;ServiceA.Add error:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;ServiceA.Add %d+%d=%d\n&quot;, args.X, args.Y, *reply)</span><br><span class="line"></span><br><span class="line">	//异步调用 Go</span><br><span class="line">	var reply2 int</span><br><span class="line">	divCall := client.Go(&quot;ServiceA.Add&quot;, args, &amp;reply2, nil)</span><br><span class="line">	replyCall := &lt;-divCall.Done //Done是一个调用结果的通知 有值了就说明调用完成了</span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>RPC的最终目的：让调用远程方法更加简单，并且速度更快</strong></p>
<p><strong>Go原生net&#x2F;rpc库需要注意的几点</strong></p>
<p><strong>1.可以支持很多种协议，包括但不限于HTTP和TCP，如果使用HTTP的话，那么客户端就使用DialHTTP，服务端通过HandleHTTP进行HTTP连接的处理，使用TCP的话，客户端使用Dial，服务端就应该for循环处理连接</strong></p>
<p><strong>2.客户端支持同步调用和异步调用两种方式，对应的分别是Call和Go</strong></p>
<p><strong>3.暴露出的服务必须满足两个条件，两个参数，一个返回值，返回值必须要是error类型，第二个参数必须是指针</strong></p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt="img"></p>
<ol>
<li>client以本地调用方式调用服务</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体</li>
<li>client stub找到服务地址，并将服务发送到服务端</li>
<li>server 接收到消息之后，通过server stub对消息进行解码</li>
<li>server stub根据解码的结果调用本地服务</li>
<li>本地服务执行并把消息返回给server stub</li>
<li>server stub将结果打包成能够进行网络传输的结构体，发送到消息方</li>
<li>client 收到消息并进行解码，得到最终结果</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">实习求职总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-24 11:08:23" itemprop="dateCreated datePublished" datetime="2023-02-24T11:08:23+08:00">2023-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-04 20:52:49" itemprop="dateModified" datetime="2023-03-04T20:52:49+08:00">2023-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我一直觉得博客嘛，就应该发一些技术相关的东西，看了很多同龄人的博客我才发现，其实博客可以发的东西有很多很多，不一定要仅限于技术，于是就有了这篇文章。</p>
<p>同时我是一个很喜欢用文字记录生活与想法的人，但是由于文字功底太弱，这些文字大多都躺在我的备忘录和废纸篓里。</p>
<p>昨天看到了一个我很尊敬的学长写的一篇博文，深有所感。于是想把这篇于2023-2-24日写好的博文修改一下，记录一下大学这两年的一些经历，感悟和想法。</p>
<p>还记得去年这个时候我还没有开始准备实习，那段时间应该是在完成工作室的考核，现在回头看看其实已经走出去很远了。</p>
<p>下面简单说一下我找实习的几个阶段吧。</p>
<h1 id="stage-one"><a href="#stage-one" class="headerlink" title="stage one"></a>stage one</h1><p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后打算和我的爱人去主城区耍的，然后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，我印象很深的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。</p>
<p>之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。</p>
<p>第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在编程上被认可了，然后就打车去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。</p>
<p>之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装，之后的任务就是写一个分布式消息队列。</p>
<p>差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。</p>
<p>除了工程上的收获之外，我还认识了很多很厉害的大佬，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，在大四的时候就能写出很多很多东西了，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来思考的方面特别多。而且他知识的广度也很大，前端后端嵌入式都会，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐，就不一一说了，食铁兽的氛围是真的挺好的，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。</p>
<h1 id="stage-two"><a href="#stage-two" class="headerlink" title="stage two"></a>stage two</h1><p>差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，差不多准备了两个礼拜之后就开始投递简历了，尴尬的事情来了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是一面挂，拿了一个小厂的offer但是不太想去。</p>
<h1 id="stage-three"><a href="#stage-three" class="headerlink" title="stage three"></a>stage three</h1><p>没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功。做完了就差不多七月底了，八月主要是在陪我的爱人，当时自己也生病了，除了复习八股之外还学了一些gRPC，做了一个简单的分布式系统来巩固知识。九月回校，这时候八股和算法都算比较巩固了，开始了新一轮的投递，两个礼拜下来面了五六家吧，也没有大厂愿意给面试机会，最后拿到了两个offer，分别是通明智云和daocloud，其实更想去daocloud，面试官说做的是容器方向，还能带薪做开源，狠狠的心动了，不过daocloud的给的薪资属实是有点少，算了一下得贴钱实习，于是去了通明智云，在通明智云的实习期间也很舒服，我的leader很信任我直接让我和客户对接，为期三个月的实习确实有真的在做东西学东西，也从同事前辈们身上学到了很多东西，总之是一段很有意义的实习经历。</p>
<h1 id="stage-four"><a href="#stage-four" class="headerlink" title="stage four"></a>stage four</h1><p>差不多十二月的时候，当时考虑到通明这边的实习期快到了，于是开启了新一轮的投递，可能是因为在盘hc，同样的也没有大厂面试机会，一轮面下来也拿了几个小厂的offer，而且待遇也不是很好，做的东西也不太感兴趣，唯一感兴趣的可能是默安科技的云原生开发，但是突如其来的我的爱人与我分手了，当时就不太想去实习了，想回家修养一阵子，于是把offer给拒了，在流程中的面试也给推了。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/1.png" alt="image-20230224111242791"></p>
<h1 id="stage-five"><a href="#stage-five" class="headerlink" title="stage five"></a>stage five</h1><p>年后市场开始复苏了，从一月底开始投递，一共投的也就那么几家吧，最后拿到了百度中台和莉莉丝运维的offer，最后打算去百度。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/2.png" alt="image-20230224111357693"></p>
<h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>从大一确定毕业就业开始，我就很想去大厂实习，但是拿到大厂offer之后也没有很开心，是真的没有波澜，很平淡，和我当时通过食铁兽面试，拿到通明智云的offer一样，非常平淡。也许这就是人生吧，很多事情不要太去追求结果，这样在结果不如意的时候真的会很痛苦，结果如意了也不见得开心，多关注过程，那些奋斗的日子回过头看是真的挺美好的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 14:54:48 / 修改时间：14:57:12" itemprop="dateCreated datePublished" datetime="2023-02-22T14:54:48+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h3 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h3><p>模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，<strong>设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案</strong></p>
<h3 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h3><p><strong>Gang of Four提出了软件设计模式</strong><br>Gof提出的设计模式有23个，包括</p>
<ul>
<li>创建型模式：如何创建对象</li>
<li>结构型模式：如何实现类或者对象的组合</li>
<li>行为型模式：类或者对象怎么交互以及怎样分配职责</li>
</ul>
<p>“简单工厂模式”不属于23种<br>设计模式：GOF的23种+简单工厂模式<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/16.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/17.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" alt="image.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计原则是设计模式的核心思想，一共有七种</p>
<ul>
<li>单一职责原则： 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个</li>
<li><strong>开闭原则</strong>：类的改动<strong>是通过增加代码</strong>进行的，而不是修改源代码</li>
<li>里氏代换原则：任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能</li>
<li><strong>依赖倒转原则</strong>：依赖于抽象（接口），不要依赖具体的实现（类），也就是<strong>针对接口</strong>编程</li>
<li>接口隔离原则：不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去</li>
<li>合成复用原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合</li>
<li><strong>迪米特法则</strong>：<strong>一个对象应当对其他对象尽可能少的了解</strong>，从而降低各个对象之间的耦合，提高系统的可维护性，例如在一个程序中，各个模块相互调用时，通常会提供一个同一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变的时候，不会影响其他模块的使用（黑盒原理）</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>类的职责是单一的，对外只提供一种功能，而引起类变化的原因也应该只有一个<br>在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂<br><strong>一个类对外只提供一种功能</strong><br><strong>实例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 以下代码不遵循单一职责原则，一个类实现了多个功能</span><br><span class="line">// 即一个clothes结构体实现了“工作装扮”和“逛街装扮”两个方法</span><br><span class="line">type Clothes struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (c *Clothes) Style() &#123;</span><br><span class="line">//	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (c *Clothes) Style2() &#123;</span><br><span class="line">//	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	c := Clothes&#123;&#125;</span><br><span class="line">//	c.Style()</span><br><span class="line">//	c.Style2()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 单一职责原则</span><br><span class="line">// 每一个类（结构体）负责一个功能或者一个逻辑</span><br><span class="line"></span><br><span class="line">type ClothesShop struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClothesWork struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesWork) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesShop) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := ClothesWork&#123;&#125;</span><br><span class="line">	c.Style()</span><br><span class="line">	c1 := ClothesShop&#123;&#125;</span><br><span class="line">	c1.Style()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则的核心思想就是当我们添加一个新功能的时候，不是通过修改代码，而是通过增添代码来实现的。<br>如果我们使用接口<code>interface</code>就可以进行一层抽象，然后提供一个抽象的方法供业务进行实现。<br><strong>增加功能的时候去增加代码而不是修改代码</strong><br><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码是平铺式设计 每当添加一个业务就需要增加方法 会导致Banker类越来越臃肿</span><br><span class="line">// 不符合开闭原则  每当有新的功能出现就要对类添加对应功能的代码</span><br><span class="line">// 当Banker业务越多再修改Banker的业务或者添加新业务的时候 出现问题的问题也会越来越大</span><br><span class="line">// 耦合度太高 Banker的职责也不够单一 代码的维护成本与业务的复杂程度成正比</span><br><span class="line"></span><br><span class="line">//type Banker struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Save() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 存款业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Transfer() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 转账业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Pay() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 支付业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 新增的Deal服务</span><br><span class="line">//func (b *Banker) Deal() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 交易业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">// banker := &amp;Banker&#123;&#125;</span><br><span class="line">// banker.Save()</span><br><span class="line">// banker.Transfer()</span><br><span class="line">// banker.Pay()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 开闭原则</span><br><span class="line">// 在Go中的描述就是通过接口实现多态，每个类去实现接口</span><br><span class="line">// 这样的话就能实现一个结果：类的改动是通过增加代码进行的，而不是修改源代码</span><br><span class="line"></span><br><span class="line">type AbstractBanker interface &#123;</span><br><span class="line">   Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SaveBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SaveBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了存款&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加转账功能</span><br><span class="line"></span><br><span class="line">type TransferBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tb *TransferBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了转账&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以基于抽象层进行业务封装-针对interface接口进行封装</span><br><span class="line"></span><br><span class="line">func BankBusiness(banker AbstractBanker) &#123;</span><br><span class="line">   banker.Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sb := SaveBanker&#123;&#125;</span><br><span class="line">   sb.Business()</span><br><span class="line">   tb := TransferBanker&#123;&#125;</span><br><span class="line">   tb.Business()</span><br><span class="line">   BankBusiness(&amp;sb)</span><br><span class="line">   BankBusiness(&amp;tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>在设计一个系统的时候我们可以将模块分成三个层次，抽象层、实现层、业务逻辑层。我们首先将抽象层的模块和接口定义出来，然后通过interface接口的设计依照抽象层依次实现每个实现层的模块，在我们写实现层代码的时候，实际上只需要参考对应的抽象层，实现每个模块。而业务逻辑层也是通过抽象层暴露出来的接口进行实现的，可以使用的方法就是抽象层暴露出来的方法<br><strong>模块与模块之间依赖抽象而不是具体实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码耦合度很高，不满足依赖倒转原则</span><br><span class="line">// 如果要满足张三开宝马，李四开奔驰，就需要重新添加代码</span><br><span class="line">// 如果司机人数为m，汽车数量为n，那么需要编写的方法为m*n</span><br><span class="line"></span><br><span class="line">//type Benz struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Benz) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;Benz is running&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type BMW struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *BMW) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;BMW is runnning&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Zhang3 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (z *Zhang3) DriveBenz(benz *Benz) &#123;</span><br><span class="line">//	benz.Run()</span><br><span class="line">//	fmt.Println(&quot;Zhang3 is driving Benz&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Li4 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (l *Li4) DriveBMW(bmw *BMW) &#123;</span><br><span class="line">//	bmw.Run()</span><br><span class="line">//	fmt.Println(&quot;Li4 is driving BMW&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	benz := &amp;Benz&#123;&#125;</span><br><span class="line">//	zhang3 := Zhang3&#123;&#125;</span><br><span class="line">//	zhang3.DriveBenz(benz)</span><br><span class="line">//	bmw := &amp;BMW&#123;&#125;</span><br><span class="line">//	li4 := Li4&#123;&#125;</span><br><span class="line">//	li4.DriveBMW(bmw)</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Car interface &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Driver interface &#123;</span><br><span class="line">	Driver(car Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">// 每个车子都实现Run方法</span><br><span class="line">// 每个司机都实现Drive方法</span><br><span class="line">// 这样需要实现的方法为m+n </span><br><span class="line">// 而且实现层只依赖于抽象层</span><br><span class="line">type Benz struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Benz) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;Benz is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BMW struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *BMW) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;BMW is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Zhang3 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (z3 *Zhang3) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Li4 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l4 *Li4) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;li4 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var benz Car = new(Benz)</span><br><span class="line">	z := new(Zhang3)</span><br><span class="line">	z.Drive(benz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。<br><strong>使用组合来实现父类方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cat) Eat() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫吃饭&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用继承来实现 添加一个睡觉的方法</span><br><span class="line"></span><br><span class="line">type CatB struct &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CatB) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用组合来添加可睡觉的方法</span><br><span class="line"> </span><br><span class="line">type CatC struct &#123;</span><br><span class="line">	C *Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cc *CatC) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	c := &amp;Cat&#123;&#125;</span><br><span class="line">	c.Eat()</span><br><span class="line">	cb := &amp;CatB&#123;&#125;</span><br><span class="line">	cb.Eat()</span><br><span class="line">	cb.Sleep()</span><br><span class="line">	cc := &amp;CatC&#123;&#125;</span><br><span class="line">	cc.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>依赖第三方进行解耦</strong></p>
<h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p>接口的意义就是实现多态的思想，我们可以根据interface类型来设计API接口，那么这种API接口的适应能力不仅能够适应当下所实现的全部模块，也适应未来实现的模块来进行调用。<code>**调用未来**</code>也许是接口最大的意义所在，良好的架构师可以针对interface进行设计一套框架，在未来的许多年后仍然可以适用</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" alt="image.png"><br>思想就是可以通过添加一层<strong>工厂模块</strong>，来做到业务逻辑层和基础模块层之间的耦合，避免业务逻辑层对基础模块层的直接依赖。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式并不属于GoF的23种设计模式，它是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：</p>
<ul>
<li>工厂：简单工厂模式的核心，它负责创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需要的产品对象</li>
<li>抽象产品：简单工厂模式所创建的所有对象的分类，它负责描述实例所公有的公共接口</li>
<li>具体产品：简单工厂模式所创建的具体实例对象</li>
</ul>
<p>设计模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Fruit interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type Apple struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Apple) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Banana struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Banana) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pear struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pear) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂模块</span><br><span class="line"></span><br><span class="line">type Factory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Factory) CreateFruit(kind string) Fruit &#123;</span><br><span class="line">	var fruit Fruit</span><br><span class="line">	if kind == &quot;apple&quot; &#123;</span><br><span class="line">		fruit = new(Apple)</span><br><span class="line">	&#125; else if kind == &quot;banana&quot; &#123;</span><br><span class="line">		fruit = new(Banana)</span><br><span class="line">	&#125; else if kind == &quot;pear&quot; &#123;</span><br><span class="line">		fruit = new(Pear)</span><br><span class="line">	&#125;</span><br><span class="line">	return fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	factory := new(Factory)</span><br><span class="line">	apple := factory.CreateFruit(&quot;apple&quot;)</span><br><span class="line">	apple.Show()</span><br><span class="line">	banana := factory.CreateFruit(&quot;banana&quot;)</span><br><span class="line">	banana.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>实现了对象创建和使用的分离</li>
<li>不需要记住具体类名，记住参数就可以，减少使用者记忆量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对工厂职责过重，一旦不能工作，系统会受到影响</li>
<li>增加系统中类的个数，复杂度和理解度增加</li>
<li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的逻辑太复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>抽象工厂：工厂的核心，任何工厂类都必须实现这个接口</li>
<li>工厂：具体工厂是抽象工厂的一个实现，负责实例化产品对象</li>
<li>抽象产品：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品：工厂方法模式所创建的具体实例对象</li>
</ul>
<p>简单工厂+开闭原则&#x3D;工厂<br>模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type fruit interface &#123;</span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂类（抽象的接口）</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateFruit() fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基础模块层</span><br><span class="line"></span><br><span class="line">type apple struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *apple) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type banana struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *banana) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type pear struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *pear) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AppleFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *AppleFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(apple)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BananaFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *BananaFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(banana)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PearFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *PearFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(pear)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line">func main() &#123;</span><br><span class="line">	//需求1 需要一个具体的苹果对象</span><br><span class="line">	//需要一个具体的苹果工厂</span><br><span class="line">	var a AbstractFactory</span><br><span class="line">	a = new(AppleFactory)</span><br><span class="line">	//生产一个具体的水果</span><br><span class="line">	var apple fruit</span><br><span class="line">	apple = a.CreateFruit()</span><br><span class="line">	apple.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>不需要记住具体类名，甚至连具体参数都不用记忆</li>
<li>实现了对象创建和使用的分离</li>
<li>系统的可拓展性也变得非常好，不需要修改接口和原类</li>
<li>对于新产品的创建，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加系统中的类的个数，复杂度和理解度增加</li>
<li>增加了系统的抽象性</li>
</ul>
<p><strong>适用场景</strong></p>
<ol>
<li>客户端不知道它所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定创建哪个对象</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。因此，可以将一些相关的产品组成一个“产品族”，从而由同一个工厂来统一生产。</p>
<ul>
<li>抽象工厂：它声明了一组用于创建一组产品的方法，每一个方法对应一种产品</li>
<li>具体工厂：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某在产品等级结构中</li>
<li>抽象产品：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li>
<li>具体产品：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li>
</ul>
<p>模式例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type AbstractApple interface &#123;</span><br><span class="line">	ShowApple()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractBanana interface &#123;</span><br><span class="line">	ShowBanana()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractPear interface &#123;</span><br><span class="line">	ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的工厂</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateApple() AbstractApple</span><br><span class="line">	CreateBanana() AbstractBanana</span><br><span class="line">	CreatePear() AbstractPear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type ChinaApple struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaBanana struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaPear struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ca *ChinaApple) ShowApple() &#123;</span><br><span class="line">	fmt.Println(&quot;china apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cb *ChinaBanana) ShowBanana() &#123;</span><br><span class="line">	fmt.Println(&quot;china banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cp *ChinaPear) ShowPear() &#123;</span><br><span class="line">	fmt.Println(&quot;china pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateApple() AbstractApple &#123;</span><br><span class="line">	var apple AbstractApple</span><br><span class="line">	apple = new(ChinaApple)</span><br><span class="line">	return apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;</span><br><span class="line">	var b AbstractBanana</span><br><span class="line">	b = new(ChinaBanana)</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreatePear() AbstractPear &#123;</span><br><span class="line">	var p AbstractPear</span><br><span class="line">	p = new(ChinaPear)</span><br><span class="line">	return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 需要中国的水果</span><br><span class="line">	//1. 创建中国工厂</span><br><span class="line">	var cF AbstractFactory</span><br><span class="line">	cF = new(ChinaFactory)</span><br><span class="line">	var cApple AbstractApple</span><br><span class="line">	cApple = cF.CreateApple()</span><br><span class="line">	cApple.ShowApple()</span><br><span class="line">	var cBanana AbstractBanana</span><br><span class="line">	cBanana = cF.CreateBanana()</span><br><span class="line">	cBanana.ShowBanana()</span><br><span class="line">	var cPear AbstractPear</span><br><span class="line">	cPear = cF.CreatePear()</span><br><span class="line">	cPear.ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>用于工厂方法模式的优点</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li>
</ol>
<p>缺点</p>
<ol>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了”开闭原则“</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族，可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>产品等级结构稳定。设计完成之后，不会像系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<h3 id="三种工厂的区别"><a href="#三种工厂的区别" class="headerlink" title="三种工厂的区别"></a>三种工厂的区别</h3><ul>
<li>简单工厂：一个工厂负责创建所有产品，违反开闭原则，添加新产品需要修改工厂逻辑，工厂会变得越来越复杂</li>
<li>工厂：一个工厂创建一个产品，系统的可扩展性非常好，无需修改接口和类，但是系统中类的个数变多，复杂度和理解度增加</li>
<li>抽象工厂：一个工厂创建一系列（同一个产品族）的产品，增加新的产品族很方便，无需修改已有系统，符合开闭原则，增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，违背了开闭原则，相当于在工厂方法的模式下进行了折中，如果产品结构等级稳定，那么就相当于完全遵循开闭</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。<br>要解决的问题是：保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。<br>类图：<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//三个要点</span><br><span class="line">// 某个类只能有一个实例</span><br><span class="line">// 它必须自行创建这个实例</span><br><span class="line">// 必须自行向整个系统提供这个实例</span><br><span class="line"></span><br><span class="line">// 总结：一个类永远只能有一个对象，这个对象还能被系统的其他模块使用</span><br><span class="line"></span><br><span class="line">//1. 因为这个类必须保证私有化 所以首字母要小写</span><br><span class="line">type singelton struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 2.指针只能指向这个唯一对象，但是这个指针不能改变方向，也必须小写</span><br><span class="line">var instance *singelton = new(singelton)</span><br><span class="line"></span><br><span class="line">// 3.对外提供一个方法来获取到这个对象 把instance的写权限去掉 只暴露读权限</span><br><span class="line"></span><br><span class="line">func GetInstance() *singelton &#123;</span><br><span class="line">	return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *singelton) DoSomeThing() &#123;</span><br><span class="line">	fmt.Println(&quot;Do something&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := GetInstance()</span><br><span class="line">	s.DoSomeThing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 懒汉式的单例模式:只有被第一次访问的时候 才给instance赋值 平常为nil</span><br><span class="line">// 但是懒汉式可能有并发问题： 同时有两个Getinstance同一时刻首次调用 那么就会出现两个instance 可以加锁解决</span><br><span class="line">// 锁的粒度太大了 可以通过一个uint的标记 使用atomic.LoadUnit函数判断 不用每次访问都加锁</span><br><span class="line">// 或者直接使用sync.Once进行new 这是对atomic.LoadUint的封装</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>单例模式提供了对唯一实例的受控访问</li>
<li>节约系统资源，由于在系统内存中只存在一个对象</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩展性差，单利模式中没有抽象层</li>
<li>单例类的职责过重</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统只需要一个实例对象，比如系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li>
<li>客户调用类的单个实力只允许使用一个公共访问点，除了该节点之外，不能通过其他途径访问该实例</li>
</ol>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Proxy模式又叫代理模式，可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。<br>所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类进行交互</p>
<ul>
<li>抽象主题：真实主题与代理主题的共同接口</li>
<li>真实主题：定义了代理角色所代表的真实对象</li>
<li>代理主题角色：含有对真实主题角色的引用，代理角色通常在客户端调用给真实主题对象之前或者之后执行某些操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct &#123;</span><br><span class="line">	Kind string</span><br><span class="line">	Fact bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line">type Shopping interface&#123;</span><br><span class="line">	Buy(goods *Goods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">type KoreaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ks *KoreaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go korea buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AmericaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AmericaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go america buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AfricaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AfricaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go africa buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 海外代理</span><br><span class="line"></span><br><span class="line">type OverSeasProxy struct &#123;</span><br><span class="line">	shopping Shopping</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) Buy(good *Goods) &#123;</span><br><span class="line">	//1.辨别真伪</span><br><span class="line">	if op.distinguish(good) == true &#123;</span><br><span class="line">		op.shopping.Buy(good)</span><br><span class="line">		op.check(good)</span><br><span class="line">	&#125;</span><br><span class="line">	//2.调用具体需要被代理的Buy方法</span><br><span class="line">	//3.海关安检</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辨别真伪</span><br><span class="line">func (op *OverSeasProxy) distinguish(goods *Goods) bool &#123;</span><br><span class="line">	fmt.Println(&quot;对&quot;, goods.Kind, &quot;进行了辨别真伪&quot;)</span><br><span class="line">	if goods.Fact == false &#123;</span><br><span class="line">		fmt.Println(&quot;发现假货&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return goods.Fact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) check(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;通过海关&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewProxy(s Shopping) Shopping &#123;</span><br><span class="line">	return &amp;OverSeasProxy&#123;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g1 := Goods&#123;</span><br><span class="line">		Kind: &quot;韩国面膜&quot;,</span><br><span class="line">		Fact: true,</span><br><span class="line">	&#125;</span><br><span class="line">	g2 := Goods&#123;</span><br><span class="line">		Kind: &quot;苹果&quot;,</span><br><span class="line">		Fact: false,</span><br><span class="line">	&#125;</span><br><span class="line">	var k Shopping = new(KoreaShopping)</span><br><span class="line">	var p Shopping</span><br><span class="line">	p = NewProxy(k)</span><br><span class="line">	p.Buy(&amp;g1)</span><br><span class="line">	var a Shopping = new(AmericaShopping)</span><br><span class="line">	p = NewProxy(a)</span><br><span class="line">	p.Buy(&amp;g2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.能够协调调用者和被调用者，在一定程度上降低了系统的耦合度<br>2.客户端可以针对抽象主题角色进行编程，符合开闭原则，系统具有姣好的灵活性和可拓展性<br>缺点：<br>1.实现较为复杂<br><strong>适用场景</strong><br>为其他对象提供一种代理以控制对这个对象的访问</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式（Decorator）用来动态地给一个对象增加一些额外的职责，比生成子类实现更加灵活<br>装饰模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用模式的时候，我们常常在一个代理类中创建一个对象的实例。并且当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<ul>
<li>抽象构件：是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方法处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件：它是抽象构建类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">type Phone interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的装饰器，装饰器的基础类</span><br><span class="line"></span><br><span class="line">type Decorator struct &#123;</span><br><span class="line">	phone Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Decorator) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的构件</span><br><span class="line"></span><br><span class="line">type Huawei struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (hw *Huawei) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a huawei phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Xiaomi struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (xm *Xiaomi) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a xiaomi phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MoDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md *MoDecorator) Show() &#123;</span><br><span class="line">	md.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a mo phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMoDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;MoDecorator&#123;Decorator&#123;</span><br><span class="line">		p,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KeDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kd *KeDecorator) Show() &#123;</span><br><span class="line">	kd.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a ke phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewKeDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;KeDecorator&#123;Decorator&#123;p&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var hw Phone</span><br><span class="line">	hw = new(Huawei)</span><br><span class="line">	hw.Show()</span><br><span class="line">	var mo Phone</span><br><span class="line">	mo = NewMoDecorator(hw)</span><br><span class="line">	mo.Show()</span><br><span class="line">	var ke Phone</span><br><span class="line">	ke = NewKeDecorator(hw)</span><br><span class="line">	ke.Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰</li>
<li>具体构建类与具体装饰类可以独立变化，符合开闭</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活激动的解决方案，同时意味着排错也比较困难</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式</li>
</ol>
<h3 id="装饰与代理的区别"><a href="#装饰与代理的区别" class="headerlink" title="装饰与代理的区别"></a>装饰与代理的区别</h3><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<ul>
<li>目标抽象类：定义客户所需接口，可以是具体类也可以是抽象接口</li>
<li>适配器类：可以调用另一个接口，作为一个转换器，让目标抽象类和适配者类进行适配</li>
<li>适配者类：被适配的角色，定义了一个已经存在的接口，这个接口需要适配</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type V5 interface &#123;</span><br><span class="line">	Use5V()</span><br><span class="line">&#125;</span><br><span class="line">type V220 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type phone struct &#123;</span><br><span class="line">	v V5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *V220) Use220V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用220V的电压 &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adapter struct &#123;</span><br><span class="line">	v220 *V220</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Adapter) Use5V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用适配器，以220V的电压充电&quot;)</span><br><span class="line">	a.v220.Use220V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPhone(v V5) *phone &#123;</span><br><span class="line">	return &amp;phone&#123;v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAdapter(v220 *V220) *Adapter &#123;</span><br><span class="line">	return &amp;Adapter&#123;v220&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *phone) Charge() &#123;</span><br><span class="line">	fmt.Println(&quot;Phone 进行了充电&quot;)</span><br><span class="line">	p.v.Use5V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	phone := NewPhone(NewAdapter(&amp;V220&#123;&#125;))</span><br><span class="line">	phone.Charge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都很好，可以很方便地更换适配器，符合开闭原则</li>
</ol>
<p>缺点：<br>适配器中置换适配者类的某些方法比较麻烦<br><strong>适应场景</strong><br>1.系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码<br>2.想创建一个可以重复使用的类，用来与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式(Facade)，为一组具有类型功能的类群，比如类库，子系统等等，提供一个一致的简单的界面</p>
<ul>
<li>外观角色：为调用方，定义简单的调用接口</li>
<li>子系统角色：功能提供方，指提供功能的类群</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">type SubSystemA struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemB struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemC struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemD struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sa *SubSystemA) MethodA() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SubSystemB) MethodB() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method b&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sc *SubSystemC) MethodC() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method c&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sd *SubSystemD) MethodD() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method d&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类</span><br><span class="line">type Facade struct &#123;</span><br><span class="line">	a *SubSystemA</span><br><span class="line">	b *SubSystemB</span><br><span class="line">	c *SubSystemC</span><br><span class="line">	d *SubSystemD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodOne() &#123;</span><br><span class="line">	f.a.MethodA()</span><br><span class="line">	f.b.MethodB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodTwo() &#123;</span><br><span class="line">	f.c.MethodC()</span><br><span class="line">	f.d.MethodD()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f := Facade&#123;&#125;</span><br><span class="line">	f.MethodOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。<br>2.它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可<br>3.一个子系统的修改对其他子系统没有任何影响<br>缺点;<br>1.不能很好的限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性<br>2.如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则<br><strong>适用场景</strong></p>
<ol>
<li>复杂系统需要简单入口使用</li>
<li>客户端程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系</li>
</ol>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>抽象类：在抽象类中定义了一系列基本操作，可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或者实现这些步骤</li>
<li>具体子类：是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类 做饮料</span><br><span class="line"></span><br><span class="line">type Beverage interface &#123;</span><br><span class="line">	BoilWater()</span><br><span class="line">	Brew()</span><br><span class="line">	PourInCup()</span><br><span class="line">	AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装一套流程模板</span><br><span class="line">type template struct &#123;</span><br><span class="line">	b Beverage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *template) MakeBeverage() &#123;</span><br><span class="line">	if t == nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	t.b.BoilWater()</span><br><span class="line">	t.b.Brew()</span><br><span class="line">	t.b.PourInCup()</span><br><span class="line">	t.b.AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MakeCoffee struct &#123;</span><br><span class="line">	template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) BoilWater() &#123;</span><br><span class="line">	fmt.Println(&quot;boil the water&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) Brew() &#123;</span><br><span class="line">	fmt.Println(&quot;use boiled water to brew&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) PourInCup() &#123;</span><br><span class="line">	fmt.Println(&quot;pour the coffee to the cup&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) AddThings() &#123;</span><br><span class="line">	fmt.Println(&quot;add sugar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMakeCoffee() *MakeCoffee &#123;</span><br><span class="line">	m := new(MakeCoffee)</span><br><span class="line">	m.b = m</span><br><span class="line">	return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	makeCoffee := NewMakeCoffee()</span><br><span class="line">	makeCoffee.MakeBeverage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时不会改变算法中步骤的执行顺序<br>2.模板方法是一种代码复用技术，他提取了类库中的公共行为，将公共行为放在父类中<br>3.可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行<br>4.不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则<br>缺点：<br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。<br><strong>适用场景</strong><br>1.具有同一的操作步骤或操作过程<br>2.具有不同的操作细节<br>3.存在多个具有同样操作步骤的应用场景，但某些具体的操作系统却各不相同<br>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个子类和操作步骤解耦合</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>讲一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式。命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不比知道如何完成请求。</p>
<ul>
<li>抽象命令类：一个抽象类或者接口，通过这些方法可以调用请求接收者的相关操作</li>
<li>具体命令类：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中</li>
<li>调用者：请求发送者，通过命令对象来执行请求</li>
<li>接收者：接收者执行与请求相关的操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">type Doctor struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatEye() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat eye&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatMouth() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat mouth&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Command interface &#123;</span><br><span class="line">	Treat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatEye struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatEye) Treat() &#123;</span><br><span class="line">	cmd.d.treatEye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatMouth struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatMouth) Treat() &#123;</span><br><span class="line">	cmd.d.treatMouth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Nurse struct &#123;</span><br><span class="line">	CmdList []Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Nurse) Notify() &#123;</span><br><span class="line">	if len(n.CmdList) == 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	for _, cmd := range n.CmdList &#123;</span><br><span class="line">		cmd.Treat()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	doctor := new(Doctor)</span><br><span class="line">	cmdEye := CommandTreatEye&#123;doctor&#125;</span><br><span class="line">	cmdMouth := CommandTreatMouth&#123;doctor&#125;</span><br><span class="line">	nurse := new(Nurse)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdEye)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdMouth)</span><br><span class="line">	nurse.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.降低系统的耦合度<br>2.新的命令很容易添加到系统中，满足开闭原则<br>3.可以比较容易地设计一个命令队列或者宏命令<br>缺点：<br>使用命令模式可能会导致某些系统有过多的具体命令类，因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用<br><strong>适用场景</strong><br>1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无需知道接收者的存在，也许无知道接收者是谁<br>2.系统需要在不同的时间指定请求、将请求排队和执行请求<br>3.系统需要将一组操作组合在一起形成宏命令</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>环境类：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略，在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类：它为所支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或者具体类，也可以是接口</li>
<li>具体策略类：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类，使用一种具体的算法实现某个业务处理</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/14.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type WeaponStrategy interface &#123;</span><br><span class="line">	UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AK47 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ak *AK47) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用AK47战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Knife struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (k *Knife) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用匕首战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Hero struct &#123;</span><br><span class="line">	strategy WeaponStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) SetWeaponStrategy(s WeaponStrategy) &#123;</span><br><span class="line">	h.strategy = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) Fight() &#123;</span><br><span class="line">	h.strategy.UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	hero := Hero&#123;&#125;</span><br><span class="line">	hero.SetWeaponStrategy(new(AK47))</span><br><span class="line">	hero.Fight()</span><br><span class="line">	hero.SetWeaponStrategy(new(Knife))</span><br><span class="line">	hero.Fight()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为<br>2.使用策略模式可以避免多重条件选择语句<br>3.策略模式提供了一种算法的复用机制<br>缺点：<br>1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类<br>2.策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类<br><strong>适用场景</strong><br>准备一组算法，并将每一个算法封装起来，使得它们可以互换</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出翻译。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<ul>
<li>抽象主题：被观察的对象</li>
<li>具体主题：被观察者的具体实现</li>
<li>观察者：接口或者抽象类</li>
<li>具体观察者：观察者的具体实现</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/15.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">type Listener interface &#123;</span><br><span class="line">	OnTeacherComing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Notifier interface &#123;</span><br><span class="line">	AddListener(l Listener)</span><br><span class="line">	RemoveListener(l Listener)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhang3 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhang3) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhao4 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhao4) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhao4 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuWang5 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuWang5) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;wang5 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClassMonitor struct &#123;</span><br><span class="line">	listenerList []Listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) AddListener(l Listener) &#123;</span><br><span class="line">	m.listenerList = append(m.listenerList, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) RemoveListener(l Listener) &#123;</span><br><span class="line">	for index, li := range m.listenerList &#123;</span><br><span class="line">		if li == l &#123;</span><br><span class="line">			m.listenerList = append(m.listenerList[:index], m.listenerList[index+1:]...)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) Notify() &#123;</span><br><span class="line">	for _, listener := range m.listenerList &#123;</span><br><span class="line">		listener.OnTeacherComing()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := &amp;StuZhang3&#123;</span><br><span class="line">		Badthing: &quot;抄作业&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := &amp;StuZhao4&#123;</span><br><span class="line">		Badthing: &quot;玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s3 := &amp;StuWang5&#123;</span><br><span class="line">		Badthing: &quot;看别人玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	classMonitor := new(ClassMonitor)</span><br><span class="line">	classMonitor.AddListener(s1)</span><br><span class="line">	classMonitor.AddListener(s2)</span><br><span class="line">	classMonitor.AddListener(s3)</span><br><span class="line">	classMonitor.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>观察者模式可以实现表现层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>观察者模式在观察目标和观察者之间建立了一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，不需要了解其具体的观察者</li>
<li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li>观察者模式满足开闭原则</li>
</ol>
<p>缺点</p>
<ol>
<li>如果一个观察者对象有很多直接和间接的观察者，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间存在循环依赖，系统可能会发生崩溃</li>
<li>观察者模式没有响应的机制让观察者知道所观察到的对象是怎样发生变化的</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这两个方面封装在独立的对象中使得它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致一个或者多个其他对象也发生改变</li>
<li>需要在系统中创建一个触发链路，A对象的行为影响B，B对象的行为影响C</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/toms%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/toms%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">toms初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:43 / 修改时间：22:19:45" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:43+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="toms初识"><a href="#toms初识" class="headerlink" title="toms初识"></a>toms初识</h1><p>tmos一个特征和功能的集和，为了满足当今市场而出现的一个代理、高性能的一系列操作系统和固件，他们都在big-ip硬件设备上或BIG-IP虚拟版中运行</p>
<p>基于包设计和基于代理（全权代理）设计的区别<br>- 基于包：这些网络设备都是网络数据流中间的节点，并不是数据交互流的终点或起点，并且这些设备只需要满足部分协议而不是整个协议栈，比如一个位于第三层（IP）的设备，可能只需要会读写IP地址TCP地址即可，至于第二层第一层的协议将与其无关。现在这些设备越来越智能了，可以修改tcp数据流，甚至能修改tcp数据包的头部（seq ack）字段，而这些是通过一个状态跟踪引擎来实现的这些设备可以识别出哪些是单独的http请求（第一次的）这些基于包设计的设备是比后者快的，而且也没有那么复杂，最根本的原因就是它们只需要理解一部分协议</p>
<p>- 基于代理： 全权代理和基于包的设计刚好是相反的，它需要理解整个网络传输的协议栈，同时他们也是协议的发起者和接收者，而一个代理服务器和客户端之间的通信与一个代理服务器和后段服务器之间的通信是不同的（反向代理、正向代理）<br>二者之间的矛盾基于代理的设计比基于包的设计更加智能，但是目前来说基于代理的设计性能更强。当流量激增的时候，基于包管理的性能也会被限制，所以在企业进行选型的时候，二者都可以被考虑</p>
<p>什么是tmos<br>- 模块的集和 每个模块提供一部分功能 比如arp ip tcp各自有各自的模块，每个模块都是自称一体的，这样将可以减少系统的复杂性，类似于搭积木一样，当需要增加对某个协议的支持时，我再去构建这么一个单独的模块<br>- 自主&amp;独立的 tmos具有自己的CPU 内存 和外围设备的接口，当一个基于tmos的设备受到数据包的时候，这些线路的子管理系统是完全在tmos中独立的，linux是不参与这个过程的，也就是说tmos并不与linux操作系统发生耦合，linux只用来管理程序<br>- 实施操作系统 （非抢占式的操作系统） 对于tmos这样高性能、大流量的操作系统来说，抢占式的os会浪费掉cpu的部分性能（高优先级插队），tmos的设计是每个组件执行必要的操作，然后把cpu让出去给下一个组件运行。这样将消除了中断、上下文切换等cpu开销，并且让程序有序运行<br>- 基于软件与硬件 它可以从软件和硬件两方面来解决问题，如果是难度比较高的，可能优先走的就是软件，如果是资源密集的，那么优先丢给硬件执行<br>- 事件驱动 因为tmos是模块化并且实时的，也就意味着它能够在任何时间内切换任务，也能够在短时间内改变性能来满足当前的需求<br>- 状态检测 tmos的内核是基于高速代理的，<br>- 动态数据包筛选 tmos能够筛选数据包，它有一个重要优势就是全权代理隐藏了后端服务的网络对战，f5的iRules允许动态控制应用程序流量，可以重定向，动态过滤，或者阻止流量等等<br>以上：tmos三一个功能强大、适应性强的解决反感，模块化与字包含、实时、事件驱动的操作系统相结合，为tmos提供了前所未有的功能<br>tmos体系中的特殊模块<br>tcp express 基于包管理的设计无法提供这个功能，tcp express包括了 延迟和选择性确认、显示拥塞统治、快重传，拥塞避免等等算法，tmos基本上把tcp能优化的地方全部进行了优化，这才能实现显著的加速</p>
<p>tmm（多线程进程）:流量管理微内核处理big-ip系统上的所有负载均衡流量，在tmos中作为额u一个实时用户进程运行，cpu和内存资源在big-ip配置中明确配置</p>
<p>影响tmm使用cpu资源的因素</p>
<p>每个处理器的内核</p>
<p>每个核心的超线程数</p>
<p>big-ip版本</p>
<p> big-ip系统许可的模块</p>
<p>单cpu </p>
<p>单核的cpu使用率<br>在big-ip 11.5.0之前，每个cpu内核被分配一个单独的tmm实例，每个内核处理数据平面任务（tmm特定）和控制平面任务（非tmm特定） 。从big-ip11.5.0开始，数据平面任务和控制平面任务都采用英特尔超线程技术在CPU的系统上使用单独的逻辑内核，偶数编号给TMM，奇数编号给其他进程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/Map%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Map详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 22:12:30 / 修改时间：22:15:37" itemprop="dateCreated datePublished" datetime="2022-11-15T22:12:30+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Map详解"><a href="#Map详解" class="headerlink" title="Map详解"></a>Map详解</h1><h3 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h3><p>基本上每种计算机语言里面都会内置一个map类型，map是一个由一组key,value组成的数据类型，并且同一个key只会出现一次。同时map支持增删改查四种操作，map的主要实现方式有两种，分别是哈希查找表(hash table)和搜索树(search tree)</p>
<p>哈希表：使用一个哈希函数将key分配到不同的bucket(桶，可以理解成数组中的索引)，开销主要是在哈希函数的计算和数组的常数访问时间，很多场景下，我们可以简单的把哈希表的时间复杂度看成O(1)。哈希表通常还会有一个碰撞的问题，所谓的哈希碰撞就是多个key被哈希函数分配到了同一个bucket。一般有两种解决方法：链表法和开放地址法。链表法是将一个bucket实现程一个链表，落在同一个bucket中的key会插入这个链表。而开发地址法则是在发生碰撞之后，通过一定的规律，在空着的bucket里面挑选，用来放置新的key </p>
<p>搜索树：一般使用自平衡二叉树，比如AVL树和红黑树</p>
<p>二者的区别是，自平衡搜索树的时间复杂度最低为O(logN)，而哈希表的最差情况是O(N)，哈希表平均查找效率是O(1)。 还有一个区别是，遍历自平衡搜索树，返回的key是有序的，而哈希表则是乱序的</p>
<h3 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h3><p>Go中的Map使用的是哈希表，并且使用链表的方式解决哈希冲突</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">	count     <span class="type">int</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">	B         <span class="type">uint8</span></span><br><span class="line">	<span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">	noverflow <span class="type">uint16</span></span><br><span class="line">	<span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">	hash0     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">	buckets    unsafe.Pointer</span><br><span class="line">	<span class="comment">// 等量扩容的时候，buckets 长度和 oldbuckets 相等</span></span><br><span class="line">	<span class="comment">// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">	oldbuckets unsafe.Pointer</span><br><span class="line">	<span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B就是buckets数组的长度对数，也就是buckets数组长度为2^B，buckets里面存放着key-value对，buckets也是一个指针，类似于slice中指向数组的指针。</p>
<p>buckets指向的是下面这个东西</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后就变成了</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其中bmap就是我们所说的哈希桶，每个桶里面最多装下8个key-value对，这些key之所以会落入同一个桶中，是因为他们经过哈希计算之后，得到的结果是一类的(哈希结果得到的后八位相同)，之后会根据key计算出来的hash值的高8位来决定key到底落入桶内的那个位置(哪个槽)</p>
<p><img src="/2022/11/15/Map%E8%AF%A6%E8%A7%A3/1.png"></p>
<p>其中每个bmap的key1…key8是存放在一起的，value1….value8是存放在一起的，这样的目的是为了节省因为内存对齐造成的空间浪费。</p>
<p>每个bucket设计成最多只能存放8个key-value对，如果有第九个key-value落入当前的bucket，则需要再构建一个bucket,然后通过overflow指针连接起来。</p>
<p><strong>创建map</strong></p>
<p>底层调用的是makemap函数，主要做的工作就是初始化hamp结构体的各种字段，比如计算B的大小，设置哈西种子hash0等等</p>
<p><strong>哈希函数</strong></p>
<p>map的一个关键点在于哈希函数的选择，在程序启动时会检测cpu是否支持aes，如果支持则使用aes hash，否则使用memhash。hash函数有加密型和非加密型，加密型的一般用于加密数据、数字摘要等，典型代表就是md5 sha1 sha256 aes256这种，非加密型的就是查找，而map就是使用的查找hash函数</p>
<p><strong>key定位过程</strong></p>
<p>key经过哈希计算后得到哈希值，共64bit，计算它落到那个桶的时候，会用到最后B个bit位，最后B个bit位的值，就是落入桶的序号、当两个不同的key落在同一个桶中，也就是发生了哈希冲突，解决手段是链表法，从前往后找到第一个空位，这样，在查找某个key的时候先找到对应的桶，然后再去遍历bucket里的key。</p>
<p>在槽内的查找过程：使用高八位的bit值，高八位的值就是槽位，如果在bucket中没找到，并且overflow不为空，还要继续去overflow bucket中查找，直到找到或是所有的key槽位都遍历完</p>
<p>综上，这是一个双重循环的过程，外层循环查找所有bucket和overflow bucket，内层循环遍历单个bucket的所有槽位</p>
<p><strong>get</strong></p>
<p>Go中读取map有两种语法，带comma和不带comma，当要查询的key不在map里，带comma的用法会返回一个bool型变量提示key是否在map中，而不带comma的语法则会返回一个对应类型的零值</p>
<p><strong>遍历</strong></p>
<p>本来map的遍历过程比较简单：遍历所有的bucket以及它后面挂的overflow bucket(第一层遍历)，然后挨个遍历bucket中的所有cell(槽)，每个bucket包含8个cell，从有key的cell中取出key value </p>
<p>但是现实并没有这么简单，因为扩容并不是一个原子的操作，每次最多只搬运两个bucket，所以如果触发了扩容操作，那么很长时间内，map状态都是处于一种中间态，有些bucket已经搬迁到新家，有些bucket还呆在老地方</p>
<p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老bucket的过程</p>
<p>具体是遍历老的bucket，然后再遍历老的bucket裂变到新的bucket里的元素</p>
<p><strong>赋值</strong></p>
<p>调用的是mapassign函数，语法和插入key的过程一样，只不过前者的key在map在不存在，后者存在</p>
<p>具体过程</p>
<p>1.检查map标志位flgas,如果为1则说明其他协程在执行写操作，导致程序panic</p>
<p>2.如果map正在扩容，那么当key定位到了某个bucket后，需要确保这个bucket对应的老bucket完成了迁移，即老bucket的key都要迁移到新的bucket中之后，才能在新的bucket中进行插入或者更新的操作</p>
<p><strong>删除</strong></p>
<p>调用的是底层的mapdelete函数</p>
<p>1.检查标志位flags，如果发现标志位为1，说明其他协程在执行写操作，直接panic </p>
<p>2.计算key的哈希，找到落入的bucket，如果正在扩容中，直接完成一次扩容</p>
<p>3.同样是两层循环，找到key的具体位置，然后删掉</p>
<p><strong>扩容</strong></p>
<p>使用哈希表的目的是快速找到目标key，随着map中添加的key越来越多,key发生碰撞的概率也越来越大，当bucket中的8个cell倍塞满的时候，效率就是最低的，最理想的情况是一个bucket只装一个key，这样就能达到o1的效率，当然这样空间消耗太多了</p>
<p>触发扩容的条件</p>
<p>1.装载因子超过阈值6.5</p>
<p>2.overflow的bucket数量过多，当B&lt;15如果overflow的数量大于2^B,当B&gt;&#x3D;15，如果overflow的数量大于2^15(装载因子比较小，map的插入和查找效率也很低，但是bucket的数量很多)</p>
<p>两种扩容方式</p>
<p>1.元素太多，bucket太少，将B+1，让bucket的数量翻倍</p>
<p>2.元素不多，但overflow bucket很多，说明很多bucket都没满，开辟一个新的bucket空间，将老bucket中的元素移动到移动到新的bucket，是的一个bucket中的key排列更加紧密</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/Slice%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Slice详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-03 22:10:39 / 修改时间：23:01:35" itemprop="dateCreated datePublished" datetime="2022-11-03T22:10:39+08:00">2022-11-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Slice详解"><a href="#Slice详解" class="headerlink" title="Slice详解"></a>Slice详解</h1><h3 id="slice和数组的区别"><a href="#slice和数组的区别" class="headerlink" title="slice和数组的区别"></a>slice和数组的区别</h3><p>众所周知，go是一门强类型的语言，什么是强类型呢？就是对类型要求非常严格(在运算时)，所以go中的float不能和int进行运算，甚至int和int64也不能进行运算。</p>
<p>数组是指长度固定的数据集合，比如 [3] int 指的就是长度为3的int类型集合，它和[4] int是两个完全不同的类型，所以不能作比较，比较也是一种运算。</p>
<p>而slice则是动态数组，长度不固定，可以动态扩容，slice的类型和长度没有关系，所以不同的slice可以进行比较(但这个操作通常没有意义)</p>
<h3 id="slice本质"><a href="#slice本质" class="headerlink" title="slice本质"></a>slice本质</h3><p>slice其实就是一个结构体，里面有着对数组的封装，还有len和cap两个字段来描述数组的长度和容量</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 元素指针 指向的其实是一个底层的数组</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要判断slice是否为空，要使用</p>
<p><code>len(slice)==0</code></p>
<p>而不能使用</p>
<p><code>slice==nil</code></p>
<p>因为slice&#x3D;0判断的是数组内是否有元素，如果没有元素则为空，而slice&#x3D;&#x3D;nil判断的是一整个结构体是否为Nil 如果我们用var 的方式声明，不会给slice分配内存，那么slice确实&#x3D;nil。但如果我们使用make的方式进行声明，那么就会给slice分配内存，所以slice就!&#x3D;nil了</p>
<p>同理的 要判断两个slice是否相同，不能简单的通过slice1&#x3D;&#x3D;slice2进行判断，而是要循环切片进行判断</p>
<h3 id="slice传参"><a href="#slice传参" class="headerlink" title="slice传参"></a>slice传参</h3><p>在我们把slice作为参数传递出去的时候，传的是<strong>值</strong>，这也就是为什么我们在被调函数中对数组进行append，在主调函数中看不到这个变化。但是如果直接通过下标的方式对slice进行修改，那么是可以反映到主调函数中的(因为下标修改是直接对底层的数组进行修改)</p>
<p>准确的来说，go中所有的参数传递，都是值传递，并没有引用传递，那有的同学可能就疑惑了，我传递map的话不是在被调函数中的改变可以反映到主调函数中吗？</p>
<p>因为进行函数调用的时候，slice类型会调用runtime.makeslice函数，这个函数的返回值类型是值，而map类型会调用runtime.makemap函数，这个函数的返回值类型是一个指针</p>
<h3 id="slice的扩容过程"><a href="#slice的扩容过程" class="headerlink" title="slice的扩容过程"></a>slice的扩容过程</h3><p>网上流传的版本是:当slice容量小于1024的时候，每次扩容翻倍，在1024长度之后，每次扩容1.25倍，而在1.18版本之后变为了，当容量小于256的时候，扩容为两倍，超过256，newcap&#x3D;oldcap+(oldcap+3*256) &#x2F;4</p>
<p>这个说法不对，或者说只对了一半</p>
<p>go 1.9.5源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.9.5 src/runtime/slice.go:82</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//内存对齐 </span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>go 1.18源码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go 1.18 src/runtime/slice.go:178</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//内存对齐</span></span><br><span class="line">	capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">	newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只看前半部分，那么网上的各种文章说的是对的，现实是，后半部分还对newcap做了一个内存对齐，这个和内存分配策略有关，进行内存对齐之后，新slice的容量&gt;&#x3D;未进行内存对齐之前的cap</p>
<h3 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h3><p>首先new和make都是Go内置的用来分配内存的函数，区别是make用来给slice map channel等引用类型分配内存，返回值是一个值类型，而new用来给数组、结构体值类型来分配内存，后者返回值是一个指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">85k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:17</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
