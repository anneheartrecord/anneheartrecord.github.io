<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/" class="post-title-link" itemprop="url">你真的了解分布式理论吗?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-11 11:13:28 / 修改时间：11:21:33" itemprop="dateCreated datePublished" datetime="2024-01-11T11:13:28+08:00">2024-01-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>随着时代的发展，传统的单台机器可能无法完成我们期待的任务，所以发展出了分布式系统这么一个概念，目的是为了提高系统的性能、可伸缩性、可用性、容错性。其本质就是<strong>堆机子</strong>，通过增加机器数量，完成之前单台机器难以完成的任务。<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869043389-1cd50b6b-7594-4807-a8f9-6f514f51e568.png" alt="image.png"><br><strong>分布式系统：多台独立的计算机组成的系统，我们将每一台计算机视为一个结点，这些节点通过网络互相通信和协作。</strong><br><strong>但是引入了分布式系统之后，随之而来的是单体架构不会出现的问题。</strong><br>比如</p>
<ul>
<li>通信和网络问题：在单体架构中，只有一台机器，无需和其他机器进行通信。而在分布式系统中，节点之间通过网络进行通信，这就导致可能会出现消息延迟、丢包、网络不稳定等问题造成的系统稳定性下降</li>
<li>一致性和可用性的权衡：在单体架构中，一台机器接受请求之后进行处理，处理完成即可响应。但是在分布式系统中，在出现网络分区时，你可以选择一致性（先同步数据、再进行响应），也可以选择可用性（先进行响应、再进行数据同步）。</li>
<li>数据一致性问题：多节点环境下，确保数据的一致性变得更为复杂，而且无法做到数据的实时强一致性，只能保证系统在一定时间的稳定运行之后，各节点的数据趋于一致。</li>
</ul>
<p>为了解决这些问题，业界提出了一些分布式基石级别的理论以及落地方案。<br>本文会向大家介绍分布式的一些基础理论，以及流行的分布式算法。</p>
<h2 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP是分布式系统方向中的一个非常重要的理论，可以粗略的将它看成是分布式系统的起点，CAP分别代表的是分布式系统中的三种性质，分别是<strong>Consistency（可用性）、Availability（一致性）、Partition tolerance（网络分区容忍性），它们的第一个字母分别是C A P，于是这个理论被称为CAP理论。</strong></p>
<ul>
<li>一致性（Consistency）：所有节点在同一时间看到的数据是一致的。在分布式系统中，一致性要求所有节点对于某个操作的执行都具有相同的视图。</li>
<li>可用性（Availability）：系统在有限时间内能够为用户提供满足要求的响应，即系统对于请求的响应不能无期限的延迟或失败。</li>
<li>分区容忍性（Partition Tolerance）：成熟的分布式系统必须满足的性质，系统能够在节点之间发生网络分区的请款修改继续工作。</li>
</ul>
<p>理论上来说，CAP三者同时最多满足两者，但是并不是必须满足两个，许多系统最多只能同时满足0、1个</p>
<p><strong>为什么CAP最多只能满足两个呢?</strong></p>
<p>我们可以以电商系统来当做例子，这个电商系统有两台服务器，彼此之间使用网络进行通信。</p>
<p>网络正常的时候，可以同步数据到另一台机器之后，再进行返回，或者返回之后再进行数据的同步。但是一旦出现了网络隔离，那么就可以有两个选择，即<strong>先同步数据</strong>还是<strong>先返回响应</strong>。</p>
<p><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869386111-1a091a25-3d9e-476d-a986-caccda9b22f8.png" alt="image.png"><br>如下图所示，假设当一个请求打到了Server2这里<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869467081-c434fed3-a734-48d1-bbcc-0cf1aee5b6e0.png" alt="image.png"><br>C: 追求的是数据一致性 当有一个请求来了之后 它会等待网络隔离的情况结束之后 向另一个机器进行数据的同步</p>
<p>首先，他会在本地处理好请求，这个请求常常会伴随着某些数据的变化，比如缓存内容的变化，程序内部某些共享变量的变化等等。<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869539296-362287d4-2a9a-42c1-9b99-b3e825f081c7.png" alt="image.png"><br>之后，它会等待网络恢复，即能够和Server1进行通信。<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869568358-fab0af25-b094-4e9e-b9d6-3fb5f7477423.png" alt="image.png"><br>网络恢复后，Server1和Server2处于同一个网络中，彼此可以通信，这时进行数据的同步。<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869637891-dce91a09-8771-4d1d-9fe7-70c7dfe4e057.png" alt="image.png"><br>完成数据同步之后，返回响应。<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1704869833707-b7ccfa89-b9d6-4bb2-81fa-aaefb9cd252c.png" alt="image.png"></p>
<p>A: 追求的是可用性 也就是尽可能提供有效服务 当一个请求来了之后 它会立即返回 哪怕数据是陈旧的 也得优先提供服务，其他分区的节点返回的结果（数据）可能是不一样，图也是反过来的。</p>
<p>注意：这里的AC不可同时满足指的是<strong>当整个分布式系统中出现网络隔离的时候，我们不能既想着保证数据的实时强一致性，又去追求服务的可用性</strong>。</p>
<p>但是当没有网络隔离的时候，其实这两个性质是可以同时满足的，因为『同步数据』和『返回结果』这两个操作都是在同一个网络中，只有先后关系，不会因为某个操作导致另一个操作的『死等』。</p>
<p>在分布式系统中，<strong>P是会必然发生的</strong>，造成P的原因可能是网络隔离，也可能是节点宕机。</p>
<p>我们无法保证分布式系统每一时刻都不出现网络隔离，如果不满足P的特性，一旦发生分区错误，那么分布式系统就无法工作，这显然违背了分布式的理念，连最基本的分布式系统条件都没有满足</p>
<p><strong>典型的CP和AP的产品</strong></p>
<p>CP：Zookeeper 当系统在发生分区故障之后 客户端的所有请求都会被卡死或者超时 但是系统总会返回一致的数据</p>
<p>AP：Eureka 分区发生故障之后 客户端依然可以访问系统 但是获取的数据有的是新数据 有的是老数据</p>
<p>当然 ，CAP这几个特性不是BOOL类型的，而是一个范围类型，完全是看系统具体需要什么样的要求。</p>
<p>比如分区容错，有的系统一台机器出错，系统会认为不影响业务的话，认为分区不存在。只有多台机器都出问题了，系统受到严重影响才认为出现分区</p>
<h3 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h3><p>PACELC理论是对CAP理论的扩展，在维基百科上的定义是</p>
<p><code>It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</code></p>
<p>翻译：如果有分区（P），那么系统就必须在可用性（A）和一致性（C）之间取得平衡，否则（E），当系统运行在无分区的情况下，系统需要在延迟（L）和一致性（C）之间取得平衡。</p>
<p>它相比于CAP，多引入了一个延迟Latency的概念，在出现分区错误的时候，取前半部分PAC，理论和CAP的内容一致。没有出现分区错误的时候取LC，也就是Latency与Consistency。</p>
<p>当前分布式系统指导理论更替代CAP理论，理由如下</p>
<ul>
<li>PACELC更能满足实际操作中分布式系统的工作场景，是更好的工程实现策略</li>
<li>当P存在的场景下，需要在A C之间做取舍，但是实际上分布式系统大部分时间里P是不存在的，那么在L和C之间做取舍是一个更好的选择</li>
<li>PACELC可以在latency与consistency之间获得平衡</li>
</ul>
<p>要保证系统的高可用，那么就得采用冗余的思想，我的其他博文有提到4个9的异地多活策略，也是采用的数据冗余思想，而一旦涉及到了复制数据，在分布式中就一定会在Consistency和Latency之间做一个取舍<br><img src="/2024/01/11/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E5%90%97/1_1683621125204-c5637883-11bb-42f3-940d-4defe9f90030.png"><br><strong>举个例子</strong></p>
<p>在强一致性的场景下，需要三个从节点都落盘数据，才能给客户端返回OK，这个时候当master向slave同步数据的时候，超过20ms触发超时了，整个系统还是会不断的重试这个过程，这显然造成了系统的可用性比较低<br>所以我们一般都会在数据一致性和请求时延之间做一个balance</p>
<p>例如：当同步超过五次之后，认为这个节点故障，选择直接返回，可以消除写时的长尾抖动，同时给节点打上故障标签，进行后续的处理</p>
<h3 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h3><p>base模型是Basically Avaliable(基本可用)、Soft State（软状态）、Eventually Consistent（最终一致性）三个短语的缩写，核心思想如下</p>
<p>即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。对应到CAP中的概念，<strong>就是牺牲C，来保证AP的满足</strong>，这是对传统ACID模型的取舍，适用于大规模的分布式系统，尤其是与存储相关的分布式组件，例如分布式缓存、分布式存储等等。</p>
<p>BA：基本可用指的是当系统出现了不可预知的故障，系统依旧可用，不过可用度也许会降低，比如响应时间上出现损失，功能上只能满足基本功能等等</p>
<p>S：基于原子性而言的话，当要求多个节点数据一致时，我们认为这是一种『硬』状态，而允许系统中的数据存在中间状态，并认为其不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据时延</p>
<p>E：最终一致性，系统不可能一直都处于一个软状态中，必须有个时间期限。在期限过后，应该保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于时延、负载、方案等等</p>
<p>在工程实践中，有这么几种最终一致性的实现策略，通常都是多种策略混合实现</p>
<ul>
<li>因果一致性：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。与此同时，与节点A无因果关系的节点C的数据访问没有这样的限制</li>
<li>读已知所写：节点A更新一个数据之后，自身总是能访问到更新过的最新值，而不会访问旧值</li>
<li>会话一致性：将对系统数据的访问过程框定在了一个会话当中，系统能保证同一个有效的会话中实现客户端在一个会话中读取到该数据项永远是最新值</li>
<li>单调读一致性：如果一个节点从系统中读取出一个数据项的某个值之后，那么系统对于该节点后续的任何数据访问都不该返回更旧的值</li>
<li>单调写一致性：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</li>
</ul>
<h3 id="NWR多数派理论"><a href="#NWR多数派理论" class="headerlink" title="NWR多数派理论"></a>NWR多数派理论</h3><p>NWR多数派理论是分布式系统共识和分布式一致性算法的基础，只有理解了NWR才能理解<code>Raft</code>、<code>Paxos</code>、<code>Gossip</code>这些分布式一致性算法。这个理论是分布式系统中一种常见的一致性模型，被广泛应用于保证数据的一致性和可靠性，以及系统的可用性。</p>
<p>它指的是：<strong>在多数副本的一致性模型中，只有大多数副本确认了某个操作，才认为这个操作已经完成</strong>。</p>
<p>NWR中N代表的是副本数量，W代表写入的副本数量，R则为读取的副本数量。在多数的一致性模型中，一般要求W+R&gt;N，以保证读写操作的一致性。同样的，NWR也有着三个阶段。</p>
<ul>
<li>Negotiation（协商）：所有节点通过相互通信来达成一致性决策，在协商阶段，节点之间需要同步信息，最后达成一致。</li>
<li>Write（写入）：决策被转化为实际的操作，节点进行写入操作。</li>
<li>Read（读取）：节点读取其他节点的值，并使用协商阶段的决策和写入阶段的结果，也就是说读一定是读的最新值。</li>
</ul>
<p>在写入操作的时候，只有W个副本被成功写入才返回成功，而在读取操作时，只有R个副本成功返回相同的数据才返回成功。这样，只要大多数副本成功确认了操作，就可以认为这个操作已经完成。</p>
<p>NWR在现有组件的应用还是很广泛的，比如Raft选主判断逻辑为投票数量&gt;&#x3D;n&#x2F;2则成功选主，比如Redis的哨兵机制，有哨兵标记下线则为主观下线，&gt;&#x3D;n&#x2F;2标记下线则为客观下线。</p>
<h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><p>分布式一致性算法用于确保在分布式系统中不同节点之间达成一致决策的算法。这些算法致力于解决由于节点故障、网络分区或并发操作等原因导致的数据不一致的问题。<br>常见的分布式一致性算法有Raft、Paxos、Gossip等等，在分布式一致性算法中，每台计算机都视为<strong>等同的节点</strong>，这和分布式事务完全相反。<br>分布式事务和分布式一致性算法的目的是一样的，本质都是将一个任务放在分布式的环境下处理和解决，但是实现则不一样。</p>
<ul>
<li>在分布式事务中，不同机器的作用是不一样的，一个任务会被拆解成多个步骤，分别交给不同的角色进行处理，全部成功则提交，一旦有失败则回滚，也就是不同机器各司其职。</li>
<li>在分布式算法中，每台机器的作用都是一样的，每一个节点都能处理请求，它的作用是进行各个节点之间的同步，并解决可能出现的问题，比如数据竞态问题（data racing）等等。</li>
</ul>
<p>具体算法的实现细节我们另开一篇文章来阐述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文向大家介绍了常见的分布式基础理论，后面还会向大家介绍Raft、Paxos、Gossip等分布式算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">微服务进程间通信实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-25 18:41:55 / 修改时间：18:43:09" itemprop="dateCreated datePublished" datetime="2023-06-25T18:41:55+08:00">2023-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h1 id="微服务通信的难点"><a href="#微服务通信的难点" class="headerlink" title="微服务通信的难点"></a>微服务通信的难点</h1><p>在微服务架构中，不同的服务是托管在不同的代码库，运行在不同的进程甚至是机器上的，这会比单体架构中服务之间进行通信付出更大的成本</p>
<p>目前有很多进程间通信的技术可供开发者选择，服务可以基于同步请求&#x2F;响应的通信机制，比如HTTP RESTFUL 或者 gRPC。另外也可以使用具有异步的消息队列，比如AMQP 或者 STOMP。消息的格式也不尽相同，可以选择具有可读性的JSON，也可以使用更加高效的、基于二进制的Protocol Buffers</p>
<p>在通信中最重要的东西其实是协议<code>Protocol</code>，只要双方进行通信，那就都是基于某种<code>Protocol</code>实现的。比如说使用MQ进行通信，以Pulsar进行举例，那么一条消息的ID通常是以下格式</p>
<p><code>分区ID：分块ID：偏移量</code></p>
<p>如果使用HTTP进行通信，那么其实<code>URL Header Body</code>如何编码及解析 也是一种协议 比如<code>HTTP HEADER</code>必带的某些属性，比如版本 以及空行等等</p>
<h2 id="语义化版本控制规范（Semvers）"><a href="#语义化版本控制规范（Semvers）" class="headerlink" title="语义化版本控制规范（Semvers）"></a>语义化版本控制规范（Semvers）</h2><p>Semvers要求API版本号由三个部分组成</p>
<ul>
<li>MAJOR 当你对API进行不兼容的更改时</li>
<li>MINOR 当你对API进行向后兼容的增强时</li>
<li>PATCH 当你进行向后兼容的错误修复时</li>
</ul>
<p>有几个地方可以在API中使用版本号，比如实现REST API，则可以使用主要版本作为URL路径的第一个元素；或者如果要实现使用消息机制的服务，则可以在发布的消息中包含版本号。这些做法都是为了正确地为API设置版本，并以受控的方式更改它们</p>
<p>例如 REST 的API路径为 <code>/v1/...</code>为前缀 就是进行主要并且不向后兼容的改变</p>
<h2 id="两类消息"><a href="#两类消息" class="headerlink" title="两类消息"></a>两类消息</h2><p>消息的格式大体可以分为文本和二进制两大类</p>
<p>文本：<code>JSON</code>和<code>XML</code>，好处是它们的可读性很高，同事也是自描述的。<code>XML</code>和<code>JSON</code>都可以允许消息的接收方只挑选它们感兴趣的值，而忽略掉其他。因此，对消息的修改可以做到很强的后向兼容性</p>
<p>弊端主要是消息往往会冗余过长，特别是XML。消息的每一次传递都必须反复包含除了值意外的属性名称，这样会造成额外的开销。另一个弊端是解析文本引入的额外开销，尤其是消息比较大的时候，因此在对性能和效率比较敏感的场景下，更得倾向于基于二进制格式的消息<br>一个典型的XML数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;person&gt;</span><br><span class="line">    &lt;name&gt;John&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;30&lt;/age&gt;</span><br><span class="line">    &lt;address&gt;</span><br><span class="line">      &lt;street&gt;123 Street&lt;/street&gt;</span><br><span class="line">      &lt;city&gt;New York&lt;/city&gt;</span><br><span class="line">      &lt;country&gt;USA&lt;/country&gt;</span><br><span class="line">    &lt;/address&gt;</span><br><span class="line">  &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个典型的JSON数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;person&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">    &quot;age&quot;: 30,</span><br><span class="line">    &quot;address&quot;: &#123;</span><br><span class="line">      &quot;street&quot;: &quot;123 Street&quot;,</span><br><span class="line">      &quot;city&quot;: &quot;New York&quot;,</span><br><span class="line">      &quot;country&quot;: &quot;USA&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二进制消息：有几种不同的二进制格式，比如<code>Protocol buffers</code> 和 <code>Thrift</code>，这两种格式都提供了一个强类型定义的<code>IDL</code>（接口描述文件），用于定义消息的格式。编译器会自动根据这些格式生成序列化和反序列化的代码。因此你不得不采用API优先的方法来进行服务设计 </p>
<p>Protocol Buffers使用tagged filed（带标记的字段）来标记数据和格式</p>
<h2 id="REST成熟度模型"><a href="#REST成熟度模型" class="headerlink" title="REST成熟度模型"></a>REST成熟度模型</h2><p><strong>REST成熟度模型</strong></p>
<ul>
<li>LEVEL 0 客户端只是向服务端发起POST 请求 进行服务调用 所有操作都通过POST进行实现</li>
<li>LEVEL 1 引入了资源的概念。要执行对资源的操作，客户端需要发出执行要执行的操作，和包含任何参数的POST请求 也是所有操作都通过POST实现</li>
<li>LEVEL 2 使用HTTP动词来执行操作，譬如GET 获取 POST创建 PUT更新</li>
<li>LEVEL 3 在由GET请求返回的资源中包含链接，这些链接能够执行该资源允许的操作。例如客户端通过订单资源的链接取消某一个订单，或者发送GET请求去获取该订单。这样也可以避免在客户端代码中写入硬链接的URL</li>
</ul>
<h2 id="在一个请求中获取多个资源的挑战–GraphQL"><a href="#在一个请求中获取多个资源的挑战–GraphQL" class="headerlink" title="在一个请求中获取多个资源的挑战–GraphQL"></a>在一个请求中获取多个资源的挑战–GraphQL</h2><p>REST资源通常以业务为导向，因此在设计REST API时的一个常见问题就是如何使得客户端可以在单个请求中检索多个相关的对象。假设客户端想要检索Order和这个Order的Consumer，纯REST API要求客户端至少发出两个请求，一个用于Order，另一个用于Consumer。更复杂的情况需要往返并且遭受更多的延迟</p>
<p>一个解决方案是API允许客户端在获取资源时检索相关资源，例如客户可以受用<code>GET /orders/order-id-1345?expand=consumer</code> 检索Order及其consumer 。这种方法在许多场景中都很有效，但对于更加复杂的场景来说，它通常是不够的，实现它也可能很耗时。</p>
<p>这就导致了GraphQL的出现，它们旨在支持高效的数据获取，以下是一个典型的GraphQL请求数据 来进行参数的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 1.72,</span><br><span class="line">      &quot;mass&quot;: 77</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>REST优缺点</p>
<p>优点：<br>1.简单 开发者熟悉<br>2.可以使用浏览器拓展或者命令行进行测试 比如postman和curl<br>3.直接支持请求&#x2F;响应方式的通信<br>4.HTTP对防火墙友好<br>5.不需要中间代理 简化结构</p>
<p>缺点：<br>1.只支持请求&#x2F;响应方式的通信<br>2.可能导致可用性降低 由于客户端和服务直接通信而没有使用代理来缓冲 因此它们必须在REST API调用期间都保持在线<br>3.客户端必须知道服务实例的位置 （URL） 这是现代应用程序中的一个重要问题<br>4.在单个请求中获取多个资源具有挑战性<br>5.有时很难将多个更新操作映射到http动词</p>
<p><strong>grpc</strong>：使用REST的一个挑战是由于HTTP仅提供优先数量的动词，因此设计支持多个更新操作的REST API并不容易，避免这个问题的进程间通信方式就是GRPC 这是一个用于编写跨语言客户端和服务端的框架</p>
<p>grpc是一种基于二进制消息的协议，可以通过<code>Protocol Buffer</code>的IDL来定义grpc 的api 可以使用<code>protocol buffe</code>r编译器来生成客户端的桩 和服务端的骨架 ，分别称为<code>stub</code> 和 <code>skeleton</code>，编译器可以为各种语言生成代码，包括j<code>ava c ``nodejs</code>和<code>golang</code>等 </p>
<p>客户端和服务器底层使用的是<code>http 2</code>协议，<code>grpc api</code>由一个或者多个请求&#x2F;响应消息定义组成，服务定义类似于接口，是强类型方法的集合，除了支持简单的请求&#x2F;响应RPC之外，<code>grpc</code>还支持流式rpc，分为客户端流式、服务端流式、双向流式等等，并以<code>protocol buffer</code>格式交换二进制的消息数据，<code>protocol buffer</code>是一种高效且紧凑的二进制标记格式。<code>protocol buffers</code>消息的每个字段都有编号，并且有一个类型代码，消息接收方可以提取所需的字段，并跳过其无法识别的字段，因此grpc使api能够在保持向后兼容的同时进行变更</p>
<p>grpc的好处</p>
<ul>
<li>设计具有复杂更新操作的API很简单</li>
<li>具有高效、紧凑的进程间通信消息，效率很高，尤其是在交换大量消息的时候</li>
<li>支持在远程过程调用和消息传递过程中使用双向流式消息方式</li>
<li>实现了客户端和用各种语言编写的服务端之间的互操作性</li>
</ul>
<p>弊端</p>
<ul>
<li>基于REST JSON的API机制相比，请求的客户端需要做更多的工作，比如定义对应的protocol buffer文件</li>
<li>老的防火墙可能不支持http 2</li>
</ul>
<h3 id="使用服务发现"><a href="#使用服务发现" class="headerlink" title="使用服务发现"></a>使用服务发现</h3><p>只要我们进行某些远程调用，不管是<code>rpc</code>还是<code>restful ap</code>i，为了发出请求，我们都需要知道服务实例的网络位置，我们把这个过程叫做服务发现。</p>
<p>通常RPC调用的服务发现通过服务注册与发现中心来实现，而<code>restful api</code>的服务发现是通过<code>DNS + IP</code>和端口来实现的</p>
<p>在传统的应用程序中，服务实例的网络位置通常是静态的。例如，代码可以从偶尔更新的配置文件中读取网络位置。但在现代的基于云微服务的应用程序中，通常不那么简单，IP地址和服务实例并不是强关联的了，某些时候服务实例会动态的销毁、创建，空出IP地址和占用IP地址</p>
<p>因此服务实例需要具有动态分配的网络地址，并且服务实例会因为自动扩展、故障和升级的原因进行动态的更改</p>
<p>服务发现在概念上非常简单：关键是一个服务注册表，这是包含服务实例网络位置信息的一个数据库，当服务实例启动和停止时，服务发现机制会更新服务注册表。当客户端调用服务时，服务发现机制会查询服务注册表以获取可用服务实例的列表，并将请求路由到其中一个服务实例</p>
<p>实现服务发现有一下两种主要方式</p>
<ul>
<li>服务及其客户直接与服务注册表交互，比如<code>CONSUL</code>和<code>ETCD</code>等等 也就是自注册+客户端服务发现 服务实例掉哟个服务注册表的注册API来注册起网络位置，并且会定期进行健康检查，通过心跳机制防止过期；当客户端想要调用服务的时候，会查询服务注册表一获取服务实例的列表。为了提高性能，客户端可以选择缓存服务实例，然后通过负载均衡算法来选择服务实例之后发出请求。并且可以处理多平台部署的问题。比如，有一些服务在K8S上部署，其余服务在遗留环境中运行。在这种情况下，使用<code>consul</code>就能同时适用于两种环境，而基于k8s的服务发现仅能用于部署在K8S平台上的部分服务</li>
<li>基础设施来处理服务发现 Docker\K8s，部署平台为每个服务提供DNS 虚拟IP 和解析的DNS名称等等 服务注册、发现、路由完全都通过部署平台进行处理</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列和上述提到的不同的最大的点就是 不管是HTTP RPC 还是服务注册与发现中心</p>
<p>它们的调用都是同步的  即发出请求 立马就能得到结果</p>
<p>而消息队列可以是异步的 生产者生产完成消息之后 消费者并不一定需要立马去进行消息的消费和后续处理 </p>
<p>异步 是消息队列最重要的功能之一</p>
<p>具体的消息队列学习内容可以看笔者之前的关于消息队列系统学习的一篇博客</p>
<p>简单来说 消息队列就是</p>
<p>通过生产者、消息中间件、消费者这几个组件实现点对点和发布订阅、PULL&#x2F;PUSH几种模式</p>
<p>消息队列又根据有没有消息中间件这个组件分为无代理消息和有代理消息</p>
<p>无代理消息：</p>
<ul>
<li>允许更轻的网络流量和更低的延迟 少了两次转发</li>
<li>避免了消息中间件可能成为性能瓶颈的可能性</li>
<li>不需要维护消息 降低操作复杂度</li>
</ul>
<p>弊端：</p>
<ul>
<li>服务之间需要知道彼此的位置 必须采用服务发现机制</li>
<li>导致可用性降低 因为在交换消息时 消息的发送方和接收方都必须在线</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/08/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5Day2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/08/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5Day2/" class="post-title-link" itemprop="url">一周撸完K8S基础概念Day2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-08 07:02:16 / 修改时间：07:07:10" itemprop="dateCreated datePublished" datetime="2023-06-08T07:02:16+08:00">2023-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="K8S对象"><a href="#K8S对象" class="headerlink" title="K8S对象"></a>K8S对象</h2><h3 id="什么是K8S对象"><a href="#什么是K8S对象" class="headerlink" title="什么是K8S对象"></a>什么是K8S对象</h3><p>在k8s中，对象是持久化的实体，k8s使用这些实体去表示整个集群的状态，它们描述了以下信息</p>
<ul>
<li>哪些容器化应用正在运行</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时行为的策略，比如重启策略、升级策略以及容错策略</li>
</ul>
<p>k8s对象是一种”意向表达（Record of Intent）”，一旦创建该对象，K8S系统将不断工作以确保该对象存在。最终系统应该达到K8S所谓的期望状态<br>我们操作K8S对象需要用到K8S的API，可以直接使用<code>kubectl</code>命令行，也可以在程序中使用客户端库，直接调用K8S API</p>
<p><strong>对象规约（spec）与状态（status）</strong></p>
<p>几乎每个Kubernetes对象都包含两个嵌套的字段，它们负责管理对象的配置，分别是<code>spec</code>与<code>status</code><br>对于具有spec的对象，你必须在创建对象时设置其内容，描述希望对象所具有的特征：期望状态（desired state）<br>status描述了对象的当前状态（current state），它是由k8s系统和组件设置并更新的。<br><strong>在任何时刻，控制平面都在管理对象的实际状态，以使其达成期望状态</strong></p>
<p><strong>描述K8S对象</strong></p>
<p>创建K8S对象的时候必须提供对象的spec用来描述对象的期望状态，以及对象的 一些基本信息（name kind），当时用API创建独享的时候，API在请求主体中应该包含JSON格式的数据，大部分情况下我们提供的是<code>.yaml</code>文件来为<code>kubectl</code>提供这些信息，当<code>kubectl</code>发起API请求的时候，这些信息会被转换成JSON格式</p>
<p>下面是一个.yaml的示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line"></span><br><span class="line">kind: Deployment</span><br><span class="line"></span><br><span class="line">metadata:</span><br><span class="line"></span><br><span class="line">  name: nginx-deployment</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line"></span><br><span class="line">  selector:</span><br><span class="line"></span><br><span class="line">    matchLabels:</span><br><span class="line"></span><br><span class="line">      app: nginx</span><br><span class="line"></span><br><span class="line">  replicas: 2 # 告知 Deployment 运行 2 个与该模板匹配的 Pod</span><br><span class="line"></span><br><span class="line">  template:</span><br><span class="line"></span><br><span class="line">    metadata:</span><br><span class="line"></span><br><span class="line">      labels:</span><br><span class="line"></span><br><span class="line">        app: nginx</span><br><span class="line"></span><br><span class="line">    spec:</span><br><span class="line"></span><br><span class="line">      containers:</span><br><span class="line"></span><br><span class="line">      - name: nginx</span><br><span class="line"></span><br><span class="line">        image: nginx:1.14.2</span><br><span class="line"></span><br><span class="line">        ports:</span><br><span class="line"></span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了通过<code>.yaml</code>这种声明式API的方式创建Deployment， 也可以通过<code>kubectl</code>命令行的方式，通过命令将<code>.yaml</code>文件作为参数进行创建，下面是一个栗子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml //应用某yaml文件  </span><br><span class="line"></span><br><span class="line">deployment.apps/nginx-deployment created // output </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>必需字段<br>在创建K8S对象中使用的<code>.yaml</code>文件里，需要配置的字段如下</p>
<ul>
<li><code>apiVersion</code> 创建对象使用的K8S API的版本</li>
<li><code>kind</code> 想要创建的对象类型</li>
<li><code>metadata</code> 帮助唯一标识对象的一些数据  比如name uid和可选的namespace </li>
<li><code>spec</code> 所期望的该对象的状态</li>
</ul>
<h3 id="K8S对象管理"><a href="#K8S对象管理" class="headerlink" title="K8S对象管理"></a>K8S对象管理</h3><p><code>kubectl</code>命令行工具支持多种不同的方式来创建和管理k8s对象，需要注意的是应该只使用一种技术来管理k8s对象，混合和匹配技术作用在同一对象上将会导致未被定义的行为</p>
<ul>
<li>指令式命令 作用于活跃对象 支持多个写者 难度低</li>
<li>指令式对象配置 作用于单个文件 支持一个写者 难度中等</li>
<li>声明式对象配置 作用于文件目录 支持多个写者 难度高</li>
</ul>
<p><strong>指令式命令</strong></p>
<p>使用指令式命令时，用户可以在集群中的活动对象上进行操作，用户将操作传递给<code>kubectl</code>命令作为参数或者标志<br>推荐在开始的时候或者在集群中运行一次性任务使用这种方式，因为它直接作用在活动对象上，所以它不提供以前配置的历史记录<br>下面是一个创建deployment对象来运行nginx的实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image nginx</span><br></pre></td></tr></table></figure>

<p><strong>指令式对象配置</strong></p>
<p><code>kubectl</code>命令制定操作，可选标志和至少一个文件名，文件内需要包含<code>YAML</code>或者<code>JSON</code>格式的对象的完整定义<br>下面是一些栗子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml //创建配置文件中定义的对象</span><br><span class="line">kubectl delete -f nginx.yaml -f redis.yaml //删除两个配置文件中定义的对象</span><br><span class="line">kubectl replace -f nginx.yaml //覆盖配置文件中定义的对象</span><br></pre></td></tr></table></figure>

<p><strong>声明式对象配置</strong></p>
<p>使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户未定义要对文件执行的操作，<code>kubectl</code>会自动检测每个文件的创建、更新和删除操作，这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f configs/ //查看configs目录下所有对象配置文件要进行的更改</span><br><span class="line">kubectl apply -f configs/ //将configs目录下要进行的更改应用</span><br></pre></td></tr></table></figure>

<h3 id="对象名称与ID"><a href="#对象名称与ID" class="headerlink" title="对象名称与ID"></a>对象名称与ID</h3><p>集群中的每一个对象都有一个名称来标识其在同类资源中的唯一性<br>每个K8S对象也有一个UID来标识在整个集群中的唯一性<br>比如同一个<code>namespace</code>下只能有一个名为abc的pod，但是可以命名一个pod和一个deployment同为abc </p>
<p><strong>名称</strong></p>
<p>是客户端提供的字符串，引用资源URL中的对象，如<code>/api/v1/pods/xxx</code><br>某一时刻，只能有一个给定类型的对象具有给定的名称。但是如果删除该对象就可以创建同名的新对象<br>名称在同一资源的所有API版本中必须是唯一的，这些API资源通过各自的API组、资源类型、命名空间和名称来区分，也就是说API版本在上下文中不相关的<br>资源命名约束有<code>DNS子域名</code>、<code>RFC 1123标签名</code>、<code>RFC 1035标签名</code>、<code>路径分段名称</code>这四种命名约束</p>
<p><strong>UID</strong></p>
<p>uid是系统生成的字符串，唯一标识对象，在K8S集群中每个生命周期中创建的每个对象都有一个不同的UID</p>
<h3 id="标签与选择算法"><a href="#标签与选择算法" class="headerlink" title="标签与选择算法"></a>标签与选择算法</h3><p><strong>标签（Labels）</strong>是附加到K8S对象（比如Pod）上的键值对，旨在指定对用户有意义并且相关的对象的标识属性，但不直接对核心系统有语义含义。标签可以用于组织和选择对象的子集，可以在创建时附加到对象，随后可以随便添加和修改，每个对象都可以定义一组键值标签，每个键对于给定的对象必须是唯一的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;labels&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签能够允许用户以松耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射<br>常见标签</p>
<ul>
<li>“release” : “stable”, “release” : “canary”</li>
<li>“environment” : “dev”, “environment” : “qa”, “environment” : “production”</li>
<li>“tier” : “frontend”, “tier” : “backend”, “tier” : “cache”</li>
<li>“partition” : “customerA”, “partition” : “customerB”</li>
<li>“track” : “daily”, “track” : “weekly”</li>
</ul>
<p>下面是一个lables带有enviroment和app两个标签的pod </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: label-demo</span><br><span class="line">  labels:</span><br><span class="line">    environment: production</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br></pre></td></tr></table></figure>


<p>标签选择算符<br>与名称和UID不同的是，标签不支持唯一性，通常我们希望许多对象携带相同的标签<br>通过标签选择算符，客户端&#x2F;用户可以识别一组对象<br>API目前支持两种类型的选择算符：等值和集合</p>
<p>等值支持三个运算符 分别是 <code>=</code> <code> ==</code>  <code>!=</code> 前两者表示相等，含义相同，后者表示不相等<br>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">environment = production  //environment label等于xx </span><br><span class="line">tier != fronted  // tier label != xx </span><br><span class="line"></span><br><span class="line">//pod选择accelerator = nvidia </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cuda-test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: cuda-test</span><br><span class="line">      image: &quot;registry.k8s.io/cuda-vector-add:v0.1&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          nvidia.com/gpu: 1</span><br><span class="line">  nodeSelector:</span><br><span class="line">    accelerator: nvidia-tesla-p100</span><br></pre></td></tr></table></figure>

<p>基于集合的标签允许通过一组值来过滤间 支持三种操作符 in notin 和 exists </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment in (a,b) //env = a 或 b </span><br><span class="line">tirer notin (a,b) // tire != a &amp; tirer != b </span><br><span class="line">partition //包含了partition标签</span><br><span class="line">!partition //没包含partition标签</span><br></pre></td></tr></table></figure>

<p>API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l environment=production,tier=frontend </span><br><span class="line">kubectl get pods -l &#x27;environment in (production),tier in (frontend)&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><code>Namespace</code>提供了一种机制，将同一集群中的资源划分为相互隔离的组，同一<code>Namespace</code>内的资源名称要唯一，每个K8s资源只能在一个<code>Namespace</code>中，这其实是在多个用户之间划分集群资源的一种方法<br>初始命名空间<br>k8s启动的时候会创建四个初始化命名空间</p>
<ul>
<li><code>default</code> k8s包含这个命名空间，以便于你无需创建新的命名空间就可以使用新集群</li>
<li><code>kube-node-lease</code> 包含用于各个节点关联的<code>Lease</code>租约对象，节点租约允许<code>kubelet</code>发送心跳，由此控制面板能够检测到结点故障</li>
<li><code>kube-public</code> 所有的客户端（包括未经身份验证的客户端）都可以读取该命名空间，该命名空间主要预留为集群使用，以便某些资源可以在整个集群中可见可读</li>
<li><code>kube-system</code> 用于k8s系统创建的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace //列出集群中现存的namespace </span><br><span class="line">kubectl run nginx --image=nginx --namespace=&lt;namespacename&gt;</span><br></pre></td></tr></table></figure>

<p>当创建一个服务的时候，k8s会创建一个相应的DNS条目<br>该条目的形式是<code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code>，这意味着如果容器只使用服务名称，就会被解析到本地命名空间的服务<br>大多数对象都存在<code>namespace</code>中，比如pod、service 等，但是<code>namespace</code>的资源本身并不在<code>namespace</code>中，而且底层资源，比如node和持久化卷，不属于任何命名空间</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>可以通过注解给对象添加任意的非标识的元数据，客户端可以获取这些元数据信息，注解只是添加一些元数据信息，不用来表示和选择对象，类似于编程中的注释，不过这是对于K8S对象的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: annotations-demo</span><br><span class="line">  annotations:</span><br><span class="line">    imageregistry: &quot;https://hub.docker.com/&quot;</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx:1.14.2</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>通常我们可以用注解来记录以下这些信息</p>
<ul>
<li>由声明性配置所管理的字段。 将这些字段附加为注解，能够将它们与客户端或服务端设置的默认值、 自动生成的字段以及通过自动调整大小或自动伸缩系统设置的字段区分开来。</li>
<li>构建、发布或镜像信息（如时间戳、发布 ID、Git 分支、PR 数量、镜像哈希、仓库地址）。</li>
<li>指向日志记录、监控、分析或审计仓库的指针。</li>
<li>可用于调试目的的客户端库或工具信息：例如名称、版本和构建信息。</li>
<li>用户或者工具&#x2F;系统的来源信息，例如来自其他生态系统组件的相关对象的 URL。</li>
<li>轻量级上线工具的元数据信息：例如配置或检查点。</li>
<li>负责人员的电话或呼机号码，或指定在何处可以找到该信息的目录条目，如团队网站。</li>
<li>从用户到最终运行的指令，以修改行为或使用非标准功能。</li>
</ul>
<h3 id="字段选择器"><a href="#字段选择器" class="headerlink" title="字段选择器"></a>字段选择器</h3><p>字段选择器<code>Field Selectors</code>允许你根据一个或者多个资源字段的值筛选K8S对象 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --field-selector status.phase=Running //筛出来status.phase字段值为runnning的所有Pod</span><br></pre></td></tr></table></figure>

<p>不同的k8s资源类型支持不同的字段选择器，所有资源类型都支持<code>metadata.name</code>和<code>metadata.namespace</code>字段，使用不被支持的字段选择器会产生错误</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>终结器（Finalizer）是带有命名空间的键，告诉k8s等到特定的条件被满足后，再完全删除被标记为删除的资源，<code>Finalizer</code>提醒控制器清理被删除的对象拥有的资源</p>
<p>当你告诉K8S删除一个指定了<code>Finalizer</code>的对象时，K8S API通过填充<code>.metadata.deletionTimestamp</code>来标记要删除的对象，并返回202状态码使其进入只读状态，此时控制平面或者其他组件会采取<code>Finalizer</code>所定义的行动，而目标对象仍然处于终止中（Terminating）的状态，这些行为完成后，控制器会删除目标对象相关的<code>Finalizer</code>。当<code>metadata.finalizers</code>字段为空时，kubernetes认为删除已完成并删除对象</p>
<p>工作原理<br>当使用清单文件创建资源的时候，可以在<code>metadata.finalizers</code>中指定Finalizers。当视图删除该资源的时候，处理删除请求的API服务器会注意到<code>finalizers</code>字段中的值，并进行以下操作</p>
<ul>
<li>修改对象 将开始执行删除的时间添加到<code>metadata.deletionTimestamp</code>字段</li>
<li>禁止对象被删除，直到其<code>metadata.finalizers</code>字段为空</li>
<li>返回202状态码</li>
</ul>
<h3 id="属主与附属"><a href="#属主与附属" class="headerlink" title="属主与附属"></a>属主与附属</h3><p>在K8S中，一些对象是其他对象的<code>Owner</code>。例如ReplicaSet是一组Pod的属主，具有属主的对象是属主的附属(Dependent)<br>附属对象中有一个<code>metadata.ownerReferences</code>字段，用于引用其属主对象，一个有效的属主引用，包含与属主对象同在一个命名空间下的对象名称和一个UID，K8S自动为一些对象的附属资源设置属主引用的值，这些对象包含了<code>ReplicaSet</code> <code>DaemonSet</code> <code>Deployment</code> <code>Job</code> <code>CronJob</code> <code>ReplicationController</code>等</p>
<h3 id="推荐使用的标签"><a href="#推荐使用的标签" class="headerlink" title="推荐使用的标签"></a>推荐使用的标签</h3><p>除了<code>kubectl</code>和<code>dashboard</code>之外，还可以使用其他工具来可视化和管理K8S对象，一组通用的标签可以让多个工具之间相互操作，用所有工具都能理解的通用方式描述对象<br>元数据围绕应用的概念进行组织，K8S不是平台即服服务，应用程序是非正式的，并且使用元数据进行描述，应用程序包含的定义应该是送伞的<br>共享标签和注解都是用同一个前缀:<code>app.kubernetes.io</code>，没有前缀的标签是用户私有的，共享前缀可以确保共享标签不会干扰用户自定义的标签</p>
<table>
<thead>
<tr>
<th>键</th>
<th>描述</th>
<th>示例</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>app.kubernetes.io&#x2F;name</td>
<td>应用程序的名称</td>
<td>mysql</td>
<td>字符串</td>
</tr>
<tr>
<td>app.kubernetes.io&#x2F;instance</td>
<td>用于唯一确定应用实例的名称</td>
<td>mysql-abcxzy</td>
<td>字符串</td>
</tr>
<tr>
<td>app.kubernetes.io&#x2F;version</td>
<td>应用程序的当前版本（例如<a target="_blank" rel="noopener" href="https://semver.org/spec/v1.0.0.html">语义版本 1.0</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>、修订版哈希等）</td>
<td>5.7.21</td>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>app.kubernetes.io&#x2F;component</td>
<td>架构中的组件</td>
<td>database</td>
<td>字符串</td>
</tr>
<tr>
<td>app.kubernetes.io&#x2F;part-of</td>
<td>此级别的更高级别应用程序的名称</td>
<td>wordpress</td>
<td>字符串</td>
</tr>
<tr>
<td>app.kubernetes.io&#x2F;managed-by</td>
<td>用于管理应用程序的工具</td>
<td>helm</td>
<td>字符串</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/08/%E4%B8%BA%E4%BB%80%E4%B9%88K8S%E8%A6%81%E6%94%BE%E5%BC%83Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/08/%E4%B8%BA%E4%BB%80%E4%B9%88K8S%E8%A6%81%E6%94%BE%E5%BC%83Docker/" class="post-title-link" itemprop="url">为什么K8S要放弃Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-08 07:01:58 / 修改时间：07:07:03" itemprop="dateCreated datePublished" datetime="2023-06-08T07:01:58+08:00">2023-06-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h3 id="K8S与Docker"><a href="#K8S与Docker" class="headerlink" title="K8S与Docker"></a>K8S与Docker</h3><p>K8S是从14年发布的，到现在已经成为了容器编排领域的龙头，大部分的个人开发或者团队都会选择使用Kubernetes进行容器的管理 </p>
<p>我们可以把集群简单的理解为：一组能够在一起协同工作的计算机</p>
<p>K8S虽然是现在容器编排领域的龙头，但是他也有他的缺点<br>1.虽然Kubernetes对外宣传的是单个集群最多支持5000结点，Pod总数不超过150000，容器总数不超过30000，但是在具体生产环境中，集群可能就2000左右<br>2.多集群管理还不够成熟，是K8S社区正在探索的方向</p>
<p>集群接口：<br>Cluster API也是Kubernetes社区中和多集群管理相关的项目，目标是通过声明式的API简化多集群的准备、 更新和运维工作，也就是通过声明式API定义机器和集群的状态</p>
<p>K8S的一些应用场景<br>1.应用分发 K8S提供了几种部署应用的最基本方式，分别是Deployment StatefulSet 和 DaemonSet 这些资源分别适用于无状态服务、有状态服务和节点上的 守护进程，这些资源能够提供最基本的策略但是无法应对更复杂的应用<br>2.批处理调度<br>3.硬多租户</p>
<p>K8S是容器编排领域的事实标准，而Docker从诞生之日到今天都在容器中扮演着举足轻重的地位，也一直是K8S的默认容器引擎，然而在2020年12月，K8S社区决定着手移除仓库中Dockershim的相关代码</p>
<h3 id="Dockershim是什么？"><a href="#Dockershim是什么？" class="headerlink" title="Dockershim是什么？"></a>Dockershim是什么？</h3><p>它是Docker的<strong>垫片</strong>，K8S中的结点代理Kubelet为了访问Docker提供的服务，会先访问Dockershim，Dockershim会将请求转发给管理容器的Docker服务</p>
<p>移除的原因</p>
<ul>
<li>K8S引入容器运行时接口（CRI） 隔离不同容器运行时的实现机制，容器编排系统不应该依赖于某个具体的运行时隔离</li>
<li>Docker没有支持也不打算支持K8S中的CRI接口，需要K8S社区在仓库中维护Dockershim</li>
</ul>
<h3 id="从可扩展性的角度看问题"><a href="#从可扩展性的角度看问题" class="headerlink" title="从可扩展性的角度看问题"></a>从可扩展性的角度看问题</h3><p>K8S通过引入新的容器运行时接口将容器管理与具体的运行时解耦，不再依赖某个具体的运行时实现，K8S通过下面的一系列接口为不同模块提供了扩展性</p>
<p>K8S在较早期的版本中引入了CRD CNI CRI CSI等接口，而CRI是1.5版本引入的新接口，Kubelet可以通过这个接口使用各种各样的容器运行时，其实CRI的发布就意味着K8S一定会将Dockershim的代码从仓库中移除。</p>
<p>CRI是一系列用于管理容器运行时和镜像的GRPC接口，我们能在它的定义中找到RuntimeService和ImageService两个服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service RuntimeService &#123;  //Runtime的grpc接口 </span><br><span class="line">    rpc Version(VersionRequest) returns (VersionResponse) &#123;&#125;</span><br><span class="line">    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) &#123;&#125;</span><br><span class="line">    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) &#123;&#125;</span><br><span class="line">    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) &#123;&#125;</span><br><span class="line">    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) &#123;&#125;</span><br><span class="line">    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) &#123;&#125;</span><br><span class="line">    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) &#123;&#125;</span><br><span class="line">    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) &#123;&#125;</span><br><span class="line">    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) &#123;&#125;</span><br><span class="line">    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) &#123;&#125;</span><br><span class="line">    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) &#123;&#125;</span><br><span class="line">    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) &#123;&#125;</span><br><span class="line">    rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) &#123;&#125;</span><br><span class="line">    rpc ReopenContainerLog(ReopenContainerLogRequest) returns (ReopenContainerLogResponse) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service ImageService &#123; //镜像的grpc接口 </span><br><span class="line">    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) &#123;&#125;</span><br><span class="line">    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) &#123;&#125;</span><br><span class="line">    rpc PullImage(PullImageRequest) returns (PullImageResponse) &#123;&#125;</span><br><span class="line">    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) &#123;&#125;</span><br><span class="line">    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而这些接口都是容器运行时需要暴露给Kubelet的接口</p>
<p>Kubernetes作为松散的开源社区，每个成员都只会在开源社区上花费有限时间，所以既然Docker社区没有打算支持K8s的CRI接口，维护Dockershim又需要很多精力，所以K8S会移除对Dockershim的支持</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%8D%E5%AE%9AJSON%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%8D%E5%AE%9AJSON%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">“如何解析不定JSON数据”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:41 / 修改时间：15:58:49" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:41+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p>在开发中常常会碰到很多JSON类型的数据进行交互，而其中有很多JSON数据你是不能确定它的字段和结构的，而Go语言是一门静态强类型的语言，在进行JSON解析的时候必须要确定字段的类型，定义出对应的结构体，然后再进行Unmarshal，那这二者之间的冲突我们该如何解决呢？</p>
<h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ul>
<li>json是JavaScript Object Notation（JavaScript对象表示法）</li>
<li>json是轻量级的文本数据交换格式</li>
<li>json独立于语言</li>
<li>json具有自我描述性，更容易理解</li>
<li>json使用js语法来描述数据对象，但是json仍然独立于语言和平台，json解析器和json库支持许多不同的编程语言</li>
</ul>
<p>json是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，之所以json这么流行，是因为json的结构和多级结构体（对象）刚好能对应上，而前后端交互的时候后端通常会返回给前端一个多级的结构体，于是json慢慢开始流行了，且json是跨语言和跨平台的，自身也足够轻量级。<br>json的标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">一个标准的json数据</span><br><span class="line">//每个key对应的是一个value</span><br><span class="line">&#123;</span><br><span class="line">“k1&quot;: 1,</span><br><span class="line">&quot;k2&quot;: 2 //注意结尾的这个不能有逗号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json字符串</span><br><span class="line">&#123;</span><br><span class="line">&quot;k1&quot;: &quot;1&quot;,</span><br><span class="line">&quot;k2&quot;: &quot;2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json数组</span><br><span class="line">&#123;</span><br><span class="line">“k1”: [1,2],</span><br><span class="line">“k2”: [3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json对象</span><br><span class="line">&#123;</span><br><span class="line">“k1”: &#123;“1”: “haihai”&#125;,</span><br><span class="line">“k2”: &#123;“2”:”haihahai”&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json对象数组</span><br><span class="line">&#123;</span><br><span class="line">“k1”: [</span><br><span class="line">&#123;“k11”: “hellohello”&#125;,</span><br><span class="line">&#123;“k12”: “badbad”&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json数组对象</span><br><span class="line">&#123;</span><br><span class="line">“k2”: &#123;</span><br><span class="line">	“hello”: [1,2,3]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所有的JSON数据都是由上述几种JSON数据组合而成</span><br></pre></td></tr></table></figure>

<h2 id="如何在Go中解析不确定的JSON数据"><a href="#如何在Go中解析不确定的JSON数据" class="headerlink" title="如何在Go中解析不确定的JSON数据"></a>如何在Go中解析不确定的JSON数据</h2><h3 id="通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体"><a href="#通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体" class="headerlink" title="通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体"></a>通过测试、看文档的方式去确定对应的JSON数据，然后构造对应的结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 请求其他服务   </span><br><span class="line">jsonStr := xxx</span><br><span class="line"></span><br><span class="line">var data interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := json.Unmarshal([]byte(jsonStr),&amp;data)</span><br><span class="line"></span><br><span class="line">fmt.Println(data)</span><br></pre></td></tr></table></figure>

<p>比如可以先拿一个interface{}类型来接住JSON数据，然后看这个interface{}的值，来确定这个JSON数据哪些字段是string 哪些是object 哪些是int float等等<br>当然这也不是完全适用的，比如下面这种情况，有一个字段如下<br>type : []<br>能看出来type是一个切片类型的值，但是具体的类型你并不知道，可能是[]int 也有可能是[]string []float等等</p>
<h3 id="map-string-interface"><a href="#map-string-interface" class="headerlink" title="map[string] interface{}"></a>map[string] interface{}</h3><p>这个类型是map键值对，值可以是任意类型，因为在go中任意类型都实现了空接口interface{}，而json数据也是key value的键值对，所以map[string] interface{}天然支持解析json类型数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := xxx</span><br><span class="line">var data map[string]interface&#123;&#125; </span><br><span class="line">err := json.Unmarshal([]byte(jsonStr),&amp;data)</span><br><span class="line"></span><br><span class="line">// 你想取的字段</span><br><span class="line">fieldValue := data[&quot;field&quot;]</span><br><span class="line"></span><br><span class="line">// 类型断言</span><br><span class="line">if value,ok := data[&quot;field&quot;].(float64);ok &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if vluae,ok := data[&quot;field&quot;].(int64); ok &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">理论上所有的合法的JSON数据都可以被反序列化到map[string]interface&#123;&#125;中</span><br><span class="line">但是实际应用中 可能会出现一些无法被map[string]interface&#123;&#125;解析的JSON数据</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON 数据中包含了多层嵌套的数据结构。在这种情况下，如果没有使用递归或者其他方式对嵌套数据进行处理，可能会导致反序列化失败。</li>
<li>JSON 数据中包含了数组类型，但是数组元素类型不一致或者无法转换成相应的类型。在这种情况下，可能需要手动处理数组元素或者使用其他数据类型来保存数组数据。</li>
<li>JSON 数据中包含了自定义数据类型或者复杂的数据结构，无法使用 map[string]interface{} 类型来反序列化。在这种情况下，需要定义相应的结构体或者使用其他适合的数据类型来反序列化。</li>
</ul>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>除了encoding&#x2F;json之外，还有很多第三方库可以用来解析不确定的JSON数据，例如gjson和jsonparser，这些库通常提供了更加灵活和高效的JSON解析方式，可以根据具体的需求选择合适的库来使用</p>
<h2 id="json-RawMessage与json-Number"><a href="#json-RawMessage与json-Number" class="headerlink" title="json.RawMessage与json.Number"></a>json.RawMessage与json.Number</h2><ul>
<li>json.RawMessage 是一个非常高效的数据类型，因为她不需要进行任何解析和类型转换，直接保存了未经处理的原始JSON数据，在反序列化的时候只需要将<code>json.RawMessage</code>转化为对应的数据类型即可，无需重新解析JSON数据</li>
<li>json.Number 表示JSON中的数字类型，可以用来保存任意精度的数字。这个数字可以特别大，可能会无法用Go中的整数或者浮点数来表示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    jsonData := []byte(`&#123;</span><br><span class="line">        &quot;id&quot;: 12345,</span><br><span class="line">        &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">        &quot;age&quot;: 30,</span><br><span class="line">        &quot;score&quot;: 95.5,</span><br><span class="line">        &quot;is_student&quot;: true,</span><br><span class="line">        &quot;tags&quot;: [&quot;tag1&quot;, &quot;tag2&quot;, &quot;tag3&quot;],</span><br><span class="line">        &quot;extra&quot;: &#123;</span><br><span class="line">            &quot;field1&quot;: &quot;value1&quot;,</span><br><span class="line">            &quot;field2&quot;: 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;`)</span><br><span class="line"></span><br><span class="line">    var m map[string]json.RawMessage</span><br><span class="line">    err := json.Unmarshal(jsonData, &amp;m)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var id int</span><br><span class="line">    err = json.Unmarshal(m[&quot;id&quot;], &amp;id)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;id: %d\n&quot;, id)</span><br><span class="line"></span><br><span class="line">    var name string</span><br><span class="line">    err = json.Unmarshal(m[&quot;name&quot;], &amp;name)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;name: %s\n&quot;, name)</span><br><span class="line"></span><br><span class="line">    var age int</span><br><span class="line">    err = json.Unmarshal(m[&quot;age&quot;], &amp;age)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;age: %d\n&quot;, age)</span><br><span class="line"></span><br><span class="line">    var score float64</span><br><span class="line">    err = json.Unmarshal(m[&quot;score&quot;], &amp;score)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;score: %f\n&quot;, score)</span><br><span class="line"></span><br><span class="line">    var isStudent bool</span><br><span class="line">    err = json.Unmarshal(m[&quot;is_student&quot;], &amp;isStudent)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;is_student: %v\n&quot;, isStudent)</span><br><span class="line"></span><br><span class="line">    var tags []string</span><br><span class="line">    err = json.Unmarshal(m[&quot;tags&quot;], &amp;tags)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;tags: %v\n&quot;, tags)</span><br><span class="line"></span><br><span class="line">    var extra map[string]json.RawMessage</span><br><span class="line">    err = json.Unmarshal(m[&quot;extra&quot;], &amp;extra)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    var field1 string</span><br><span class="line">    err = json.Unmarshal(extra[&quot;field1&quot;], &amp;field1)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;extra.field1: %s\n&quot;, field1)</span><br><span class="line"></span><br><span class="line">    var field2 int</span><br><span class="line">    err = json.Unmarshal(extra[&quot;field2&quot;], &amp;field2)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;extra.field2: %d\n&quot;, field2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不确定的类型</span><br><span class="line">data := make(map[string]interface&#123;&#125;)</span><br><span class="line">if err := json.Unmarshal(rawData, &amp;data); err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if value, ok := data[&quot;age&quot;].(float64); ok &#123;</span><br><span class="line">    // 处理年龄为浮点数的情况</span><br><span class="line">&#125; else if value, ok := data[&quot;age&quot;].(int); ok &#123;</span><br><span class="line">    // 处理年龄为整数的情况</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 处理年龄为其他类型或不存在的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：类型断言的底层为反射，因为在运行时需要判断一个接口值的具体类型，而这个类型是在编译时无法确定的，需要在运行时动态地获取。效率比正常的代码低一到两个数量级，而且需要消耗额外的时间和内存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Go模糊测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:32 / 修改时间：15:58:27" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:32+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p>在Go 1.18开始提供了Fuzzing能力的支持，testing包在我们常见的T B类型之外新增了F的类型，用于支持模糊测试</p>
<h2 id="Fuzzing-Test"><a href="#Fuzzing-Test" class="headerlink" title="Fuzzing Test"></a>Fuzzing Test</h2><p>日常测试代码的时候我们经常使用table driven test的方式来构造一组输入和预期的结果，之后调用我们的待测函数，检查结果是否和我们的预期匹配，也就是我们平常说的Mock数据</p>
<p>这就引出了一个问题，这个table要多大呢？<br>通常大家都只是写一个【正常】的case 一个【异常】的case<br>但是这些样例其实是不够的，比如一些异常值、corner case，可能无法处理，或者可能有程序挂掉、安全问题等等</p>
<p>而fuzzing test的作用就是帮我们自动生成输入数据，以下是维基百科对于fuzzing test的定义</p>
<p><code>Fuzzing is a technique where you automagically generate input values for your functions to find bugs</code></p>
<p>模糊测试能够【持续】、【自动】地生成一系列【半随机】的数据作为待测函数的输入，来找到程序里隐藏的bug，对于边界case能够很好的验证。模糊测试中的输入不是由人工指定的，而是自动生成的随机数据，所以可以规避掉人工主观判断造出来的数据。</p>
<p>模糊测试通常可以不依赖于开发测试人员定义好的数据集，取而代之的则是一组通过数据构造引擎自行构造的一系列随机数据。模糊测试会讲这些数据作为输入提供给待测程序，并且监测程序是否出现panic、断言失败、无限循环，或者其他的异常情况</p>
<p>这些通过数据构造引擎生成的数据被称为<strong>语料（corpus）</strong>，另外模糊测试其实也是一种持续测试的手段，因为如果不限制执行的次数或者执行的最大时间，它就会一直不停的执行下去</p>
<h2 id="Go模糊测试"><a href="#Go模糊测试" class="headerlink" title="Go模糊测试"></a>Go模糊测试</h2><p>让我们来看看一个Golang实现的模糊测试长什么样<br><img src="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1682407394290-f8c3006a-9f60-4362-a4e8-025536043457.png"></p>
<p>签名部分：从常见的<code>func TestXxx(t *testing.T)</code> 变成了<code>func FuzzXxx(f *testing.F)</code></p>
<p>seed corpus：一组用户提供的语料，fuzzing引擎会使用这个语料来生成随机数据。其实就是一个样本，之后引擎就知道要生成什么类型的随机数据了</p>
<p>Fuzzing arguments: 接受*testing.t和想要随机生成的数据类型<br><img src="/2023/05/31/Go%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/1682408593234-75061a31-701a-4f88-8121-7cb8c0d683df.png"><br>模糊测试的要求</p>
<ul>
<li>模糊测试必须是一个名称类似于<code>FuzzXxx</code>的函数，仅接受一个<code>*testing.F</code>参数，无返回值</li>
<li>模糊测试必须在<code>*_test.go</code>中运行</li>
<li>Fuzz target(模糊目标)必须是对<code>(*testing.F).Fuzz</code>的方法调用，参数是一个函数，并且这个函数的第一个参数是<code>*tesing.T</code>，然后是模糊参数（fuzzing argument），没有返回值</li>
<li>一个模糊测试中必须只有一个模糊目标</li>
<li>所有种子语料库（seed corpus）必须具有与模糊参数相同的类型，顺序相同</li>
<li>模糊参数只能是以下的类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string, []byte</span><br><span class="line">int, int8, int16, int32/rune, int64</span><br><span class="line">uint, uint8/byte, uint16, uint32, uint64</span><br><span class="line">float32, float64</span><br><span class="line">bool</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，在Go执行的过程中，多个fuzzing target是并行来处理的，底层会有多个worker，调度的顺序也不一定，所以不能做持久化，也不能依赖一些全局状态，不要尝试改变入参</p>
<p><strong>运行模糊测试</strong></p>
<p>我们依然可以使用<code>go test</code>命令来跑模糊测试，只是需要加上一个<code>-fuzz=FuzzTestName</code>的选项。同时这个包下所有其他类型的test都会优先于模糊测试执行，毕竟比较耗费资源，随机数据生成是有样本的。</p>
<p>执行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~ go test -fuzz FuzzFoo</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 0/192 completed</span><br><span class="line">fuzz: elapsed: 0s, gathering baseline coverage: 192/192 completed, now fuzzing with 8 workers</span><br><span class="line">fuzz: elapsed: 3s, execs: 325017 (108336/sec), new interesting: 11 (total: 202)</span><br><span class="line">fuzz: elapsed: 6s, execs: 680218 (118402/sec), new interesting: 12 (total: 203)</span><br><span class="line">fuzz: elapsed: 9s, execs: 1039901 (119895/sec), new interesting: 19 (total: 210)</span><br><span class="line">fuzz: elapsed: 12s, execs: 1386684 (115594/sec), new interesting: 21 (total: 212)</span><br><span class="line">PASS</span><br><span class="line">ok      foo 12.692s</span><br></pre></td></tr></table></figure>

<p>Fuzzing test的局限性，在单元测试中因为测试输入是固定的，所以可以和把得到的结果和预期结果进行比较来判断执行结果是否与预期相符合。</p>
<p>但是在使用fuzzing的时候，我们无法预测输出结果是什么，因为测试的输入除了我们代码只能给指定的用例之外，还有fuzzing随机生成的输入，所以我们无法提前知道预期结果是什么</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/Go%E5%B8%B8%E8%A7%81%E6%89%8B%E6%90%93demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/Go%E5%B8%B8%E8%A7%81%E6%89%8B%E6%90%93demo/" class="post-title-link" itemprop="url">Go常见手搓demo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:23 / 修改时间：15:58:36" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:23+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="手搓快排"><a href="#手搓快排" class="headerlink" title="手搓快排"></a>手搓快排</h2><p>需要注意的点有两个<br>1.循环里两数交换的条件为 i &lt; j 意味着左指针还在右指针的左侧 即两者还没相遇<br>2.递归的时候一个是j  一个是j+1 把数组一分为二进行递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	nums := []int&#123;3, 1, 2, 4, 6, 5&#125;</span><br><span class="line">	quickSort(nums, 0, len(nums)-1)</span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func quickSort(nums []int, l, r int) &#123;</span><br><span class="line">	if l &gt;= r &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	i, j, mid := l-1, r+1, nums[(l+r)/2]</span><br><span class="line">	for i &lt; j &#123;</span><br><span class="line">		i++</span><br><span class="line">		for nums[i] &lt; mid &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		j--</span><br><span class="line">		for nums[j] &gt; mid &#123;</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		if i &lt; j &#123;</span><br><span class="line">			nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort(nums, l, j)</span><br><span class="line">	quickSort(nums, j+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手搓堆排"><a href="#手搓堆排" class="headerlink" title="手搓堆排"></a>手搓堆排</h2><p>需要注意的点：<br>1.heapify用来递归做调整 其中heapSize表示堆大小 i表示要操作的节点下标 left 和 right 的值分别是 2_i+1 与 2_i+2<br>2.buildHeap和heapify都传参都是i,n，而堆排的时候是维护一个当前大小的堆，所以是0,i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	nums := []int&#123;3, 1, 2, 4, 6, 5&#125;</span><br><span class="line">	heapSort(nums)</span><br><span class="line">	fmt.Println(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func buildHeap(nums []int, heapSize int) &#123;</span><br><span class="line">	for i := heapSize / 2; i &gt;= 0; i-- &#123;</span><br><span class="line">		heapify(nums, i, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func heapSort(nums []int) &#123;</span><br><span class="line">	heapSize := len(nums)</span><br><span class="line">	buildHeap(nums, heapSize)</span><br><span class="line">	for i := heapSize - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">		nums[i], nums[0] = nums[0], nums[i]</span><br><span class="line">		heapify(nums, 0, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func heapify(nums []int, i, heapSize int) &#123;</span><br><span class="line">	largest := i</span><br><span class="line">	left, right := 2*i+1, 2*i+2</span><br><span class="line">	if left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest] &#123;</span><br><span class="line">		largest = left</span><br><span class="line">	&#125;</span><br><span class="line">	if right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest] &#123;</span><br><span class="line">		largest = right</span><br><span class="line">	&#125;</span><br><span class="line">	if largest != i &#123;</span><br><span class="line">		nums[largest], nums[i] = nums[i], nums[largest]</span><br><span class="line">		heapify(nums, largest, heapSize)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个生产者-消费者模型"><a href="#实现一个生产者-消费者模型" class="headerlink" title="实现一个生产者-消费者模型"></a>实现一个生产者-消费者模型</h2><p>要注意的就是<br>通过select来实现一有消息就读，如果读完就退出<br>那怎么判断是否读完呢？这里就需要生产者主动关闭channel了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int,10)</span><br><span class="line">	go Processor(ch)</span><br><span class="line">	go Consumer(ch)</span><br><span class="line">  //睡一会</span><br><span class="line">	time.Sleep(15 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Processor(ch chan int) &#123;</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		// 模拟发时间的时延 这里可有可无</span><br><span class="line">		//time.Sleep(1 * time.Second)</span><br><span class="line">		fmt.Println(&quot;process:&quot;, i)</span><br><span class="line">	&#125;</span><br><span class="line">	close(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Consumer(ch chan int) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">  	// 有数据就读出来 关闭了就退出</span><br><span class="line">		case i, ok := &lt;-ch:</span><br><span class="line">			if ok &#123;</span><br><span class="line">				fmt.Println(&quot;consumer:&quot;, i)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				fmt.Println(&quot;over!&quot;)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现两个goroutine打印奇偶数"><a href="#实现两个goroutine打印奇偶数" class="headerlink" title="实现两个goroutine打印奇偶数"></a>实现两个goroutine打印奇偶数</h2><p>需要注意的点是<br>关闭通道的时候需要异步进行，也就是异步Wait()，然后立马关掉ch<br>同步的话会有一个问题就是Even和Odd都往这个ch中写东西了，但是没有人去消费它，所以我们只能选择手动关闭。但是等待for range完毕，然后同步关闭的话会导致ch阻塞（因为for range不是消费）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func Even(wg *sync.WaitGroup, ch chan int) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	for i := 0; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(wg *sync.WaitGroup, ch chan int) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	for i := 1; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	wg.Add(2)</span><br><span class="line">	go Even(&amp;wg, ch)</span><br><span class="line">	go Odd(&amp;wg, ch)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		close(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	for v := range ch &#123;</span><br><span class="line">		fmt.Println(&quot;number:&quot;, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现两个goroutine交替打印奇偶数"><a href="#实现两个goroutine交替打印奇偶数" class="headerlink" title="实现两个goroutine交替打印奇偶数"></a>实现两个goroutine交替打印奇偶数</h2><p>需要注意的点：<br>通道必须得是有缓冲的，不然在main goroutine中往里面&lt;-1就会阻塞住，下面的go协程就不会执行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func Even(ch chan int) &#123;</span><br><span class="line">	for i := 0; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Println(&quot;number:&quot;, i)</span><br><span class="line">		ch &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(ch chan int) &#123;</span><br><span class="line">	for i := 1; i &lt;= 100; i += 2 &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Println(&quot;number:&quot;, i)</span><br><span class="line">		ch &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int, 1)</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">	go Even(ch)</span><br><span class="line">	go Odd(ch)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/go-sum%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/go-sum%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">go.sum是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 15:34:11 / 修改时间：15:58:07" itemprop="dateCreated datePublished" datetime="2023-05-31T15:34:11+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>802</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<p><code>go.sum</code>是Go语言管理包管理 <code>go mod</code>而使用的一种锁文件，用于记录Go项目中所有依赖包的路径和哈希值。每一行记录了一个依赖项的信息，包括依赖项的模块路径、版本、哈希值等等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github.com/pkg/errors v0.8.1 h1:OIzxFfzpYLMvPCkkN+UD9dJ9yRuoxzZbDvI8Du5OJ+E=</span><br><span class="line">github.com/pkg/errors v0.8.1/go.mod h1:9JFJoAoLZpNq3W4x/+xGw15jqJ7VHvq3u/L7V9XbTcg=</span><br><span class="line">golang.org/x/crypto v0.0.0-20210322153248-947e6a75a262 h1:2Q1cGh1Zpq/NWDTzDxKk/gZN+Yyo0F8wgJOu09Kml9Q=</span><br><span class="line">golang.org/x/crypto v0.0.0-20210322153248-947e6a75a262/go.mod h1:XTbTeuV6yl+B2H/UsM6UStw6z/5PhRlQIyH9/pXli/Y=</span><br></pre></td></tr></table></figure>

<p>go.sum文件的作用在于记录各个依赖项的版本和哈希值，用于验证项目的依赖关系是否发生变化。<br>当使用go mod安装依赖包的时候，会根据go.mod文件中指定的版本号下载相应的依赖包，并计算依赖包的哈希值，将这些信息记录到go.sum中，当再次构建项目的时候，go.mod会检查go.sum文件，确保依赖项的哈希值和之前记录的值一样，以此来保证项目的构建过程是可重现的<br>go.sum文件的重要性在于保证Go项目的依赖关系的可靠性和安全性，避免因为依赖包版本不一样导致的不可预期的问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/" class="post-title-link" itemprop="url">一周撸完K8S基础概念 Day1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-30 13:03:31 / 修改时间：13:04:49" itemprop="dateCreated datePublished" datetime="2023-05-30T13:03:31+08:00">2023-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="K8S概述"><a href="#K8S概述" class="headerlink" title="K8S概述"></a>K8S概述</h2><h3 id="什么是K8S？"><a href="#什么是K8S？" class="headerlink" title="什么是K8S？"></a>什么是K8S？</h3><p>Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。名字源于希腊语，意味”舵手”</p>
<p><strong>k8s出现的必要性</strong><br><img src="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/1685096676336-cedce0c3-dafd-4972-8a64-71c8dceec279.png" alt="image.png"><br>按照部署的方式来进行划分，我们可以简单的划分成四个时代</p>
<p><strong>传统部署时代</strong><br>如图一一样，APP部署在OS上，OS跑在硬件上。这会导致一个问题，如果在同一台机器上运行多个应用程序，如果某一个APP占用了机器的大部分资源，那么就会影响到其他APP，造成性能抖动甚至饿死的严重后果</p>
<p><strong>虚拟化部署时代</strong><br>为了解决上述问题，虚拟化技术被引进了，虚拟化技术允许你在单个物理服务器的CPU上运行多台虚拟机（VM）。虚拟化能使应用程序在不通过的VM之间被彼此隔离，且能提供一定程度的安全性，因为一个应用程序的信息不能被另一应用程序随意访问。<br>虚拟化技术能够更好地利用物理服务器的资源，并且可以更加轻松地添加、更新应用程序，因此具有更强的可扩缩性，以及降低硬件成本等等的好处</p>
<p><strong>容器部署时代</strong><br>容器类似于VM，但是相比于VMWare生成的那种VM，容器更加轻量级，并且与VM类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等等，容器之间可以共享OS。容器和基础架构是分离的，因此可以跨云和OS发行版进行移植</p>
<p><strong>容器的优势</strong></p>
<ul>
<li>敏捷应用程序的创建和部署：相比于VM镜像更加简便，提高了容器镜像创建的简便性和效率</li>
<li>持续开发、集成和部署：基于镜像不可变性，通过快速简单的回滚，提供可靠且频繁的容器镜像构建和部署</li>
<li>关注开发和运维的分离：在构建、发布时创建镜像，而不是部署的时候，从而将应用与基础架构进行分离</li>
<li>可观察性：不仅可以显示OS级别的信息和指标，还能够显示应用程序的运行状态、其他指标信号</li>
<li>跨开发、测试和生产的环境一致性：在开发物理机上也可以和在云中运行一样的应用程序</li>
<li>跨云和操作系统发行版本的可移植性：可在任意环境运行</li>
<li>松耦合、分布式、弹性：一个大的单体被分解成较小的服务，并且可以动态的管理和部署，而不是在一台大型单机上整体运行</li>
<li>资源隔离：可预测的应用程序性能</li>
<li>资源利用：高效率和高密度</li>
</ul>
<p><strong>K8S能做什么</strong><br>上文我们说到，容器是打包和运行应用程序的很好的一种方式，而在生产环境中，我们需要对很多容器（容器的集群）进行管理，保证服务不会出故障、确保服务的可靠性，稳定性。<br>例如一个容器发生故障，则需要把这个容器下掉，新增一个运行该服务的容器，再把它上线。而K8S就是帮助我们实现这个过程，简化操作流程的工具</p>
<p>K8S的功能</p>
<ul>
<li>服务发现与负载均衡：K8S可以使用DNS、或者自己的IP来暴露容器，如果进入容器的流量很大，K8S通过Kube-Proxy来实现的负载均衡，可支持的负载均衡算法有（轮询、最少链接、IP哈希），默认为轮询，通过负载均衡来分配网络流量，从而使部署更加稳定</li>
<li>存储编排：K8S允许自动挂载你选择的存储系统，例如本地存储、公共云提供商等</li>
<li>自动部署和回滚：可以使用K8S描述已部署容器的所需状态，并控制状态更改的速率</li>
<li>自动完成装箱计算：当K8S拥有许多节点组成一个集群之后，在这个集群上运行容器化的任务时，可以告知K8S每个容器需要多少资源（CPU 内存等），K8S可以将这些容器按实际情况调度到节点上，以最佳方式利用分配的资源</li>
<li>自我修复：K8S将重新启动失败的容器、替换容器、杀死不响应用户定义的健康检查的容器，并且在准备好服务之前不将其通告给客户端</li>
<li>密钥与配置管理：K8S允许你存储和管理敏感信息，例如密码、OAuth令牌和SSH密钥，可以在不重建容器镜像的情况下部署和更新密钥以及应用程序配置，也无需在堆栈配置中暴露密钥</li>
</ul>
<h2 id="K8S组件"><a href="#K8S组件" class="headerlink" title="K8S组件"></a>K8S组件</h2><p><img src="/2023/05/30/%E4%B8%80%E5%91%A8%E6%92%B8%E5%AE%8CK8S%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-Day1/1685330733242-4d722d72-3d62-41f8-a370-527489669c2e.svg"><br>上述是K8S运行的架构流程图，我们可以看得出来，一个K8S集群主要由两部分组成，分别是<code>Control Plane</code>控制平面，老版本也叫做Master；<code>Node</code>工作节点，老版本也叫做Worker Node </p>
<p>我们将一组工作机器称为节点，节点会运行容器化应用程序，每个集群至少有一个工作节点。工作节点会托管Pod，控制平面管理集群中的工作节点与Pod</p>
<p>整体的一个典型的工作流程如下：</p>
<ol>
<li>用户使用K8S API与API服务器交互，发布应用程序的描述（如Pod Service等）</li>
<li>调度器根据应用程序的要求选择合适的节点，并将任务指派给节点上的Kubelet </li>
<li>Kubelet根据指令在节点上创建和管理容器，确保它们的状态与期望的状态</li>
</ol>
<h3 id="控制平面组件"><a href="#控制平面组件" class="headerlink" title="控制平面组件"></a>控制平面组件</h3><p>控制平面组件会为集群做出全体决策，比如资源的调度，以及检测和响应集群事件。可以理解成K8S集群的大脑，负责管理和控制整个集群的行为。<br>控制平面组件可以在集群中的任何节点上运行，通常来说为了简单起见，只会在同一个计算机上启动所有的控制平面组件，并且不会在这台机器上运行任何容器</p>
<p>**kube-apiserver **<br>API服务器是K8S控制平面的组件之一，提供了与K8S集群通信的接口，允许用户和其他组件通过HTTP RESTful API与K8S进行交互，这个组件负责公开K8S API，负责处理接受请求的工作，验证并配置API对象的数据，这些对象包括pods services replicationcontrollers等，为REST操作提供服务，可以将它简单理解为K8S控制平面的前端，其他所有组件都通过该前端进行交互。<br>同时，API SERVER还负责验证请求的身份和权限，通过Token UserName&#x2F;Password TLS证书等进行确认和交互，验证用户或者组件的身份，一旦用户验证成功，API Server会使用访问控制策略进行角色授权<br>并且它负责资源管理，维护一组持久化存储(etcd)来存储资源的配置、状态和元数据<br>它还负责记录集群中的事件和日志信息，当资源对象发生变化或者出现错误的时候，它会生成事件并将其发送给订阅者 </p>
<p><strong>etcd</strong><br>它是一个分布式的一致且高可用的键值存储，用作k8s所有集群数据的后台数据库，存储集群的配置数据、元数据和状态信息的可靠持久化存储。etcd提供了高可用性、一致性和分布式的特性，为K8S的控制平面组件提供了一个共享的数据存储，API Server、kube scheduler 和 CM 等组件通过使用etcd来存储和检索集群的配置信息、资源对象的状态以及各种元数据，这些信息包括Pod Service Namespace PersistentVolume等的定义和状态</p>
<p>etcd的一些关键功能</p>
<ul>
<li>分布式存储：etcd使用Raft一致性算法来实现数据的分布式存储，它将数据分片并复制到集群中的多个节点上，确保数据的可用性和容错性，这意味着即使一些节点失效，集群应该可以继续正常工作</li>
<li>一致性：etcd的Raft算法保证了数据的一致性，所有的写操作都需要经过多数节点的确认，确保数据的正确复制和同步，这样可以避免数据损坏和不一致的情况发生</li>
<li>高可用性：etcd具有高可用性，通过在集群中的多个节点上复制数据，提供了容错能力</li>
<li>快速读写：etcd通过在内存中保持数据的副本，实现了快速的读写操作，使用B+树作为底层数据结构，提供高效的索引和检索功能</li>
<li>监控和故障恢复：etcd提供了一些监控和故障恢复机制，可以监测节点的状态和健康状况。当节点发生故障或变得不可用时，集群可以自动进行重新选举，选择新的领导者节点来接管工作</li>
</ul>
<p>**kube-scheduler **<br>负责监视新创建的、未指定运行节点（node）的Pods，并选择节点来让Pod运行在该节点上，以实现负载均衡、资源利用率最大化和高可用性<br>调度决策考虑的因素包括：单个Pod及Pods集合的资源需求、软硬件及策略约束、亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限<br>scheduler的主要功能如下</p>
<ol>
<li>资源调度：scheduler根据容器的资源需求（如CPU 内存）和节点的资源利用率，决定将工作负载调度到哪个节点上运行</li>
<li>节点选择：scheduler根据工作负载的要求，选择适合的节点进行调度，通过筛选和评分机制来选择节点，同时scheduler还考虑亲和性规则，以便将相关的工作负载调度到同一节点上，提高应用程序的性能和效率</li>
<li>拓展性和灵活性：scheduler具有可插拔的架构，允许用户根据自己的需求自定义和拓展调度算法，用户可以实现自定义的调度策略，通过调整评分函数和优先级规则来满足特定的业务需求</li>
<li>调度器扩展：k8s提供了灵活的调度器扩展机制，允许用户添加额外的带哦赌气，这些调度器可以根据特定的需求和场景来实现自定义的调度逻辑</li>
</ol>
<p>工作流程如下：</p>
<ol>
<li>用户创建或者更新一个工作负载的描述，例如Deployment StatefulSet等</li>
<li>当新的工作负载被提交时，Scheduler接收到这个事件，并根据工作负载的需求和集群状态进行调度决策</li>
<li>Scheduler遍历集群中的可用节点，评估每个节点的适合程度，并为每个节点打分</li>
<li>Schedulergenuine打分结果选择最合适的节点，并将工作负载的调度决策通知给相应的节点的Kubelet </li>
<li>Kubelet在选择的节点上启动和管理容器，并把容器的状态报告给控制平面</li>
</ol>
<p><strong>kube-controller-manager(cm)</strong><br>负责运行控制器进程，理论上来说每个控制器都是一个独立的进程，但是为了降低复杂性，它们都被编译到一个可执行文件中，并且在同一个进程中运行。<br>这些控制器包括</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的JOB对象，然后创建Pods来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片对象，以提供给Service和Pod之间的链接</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>CM启动时，它的各个控制器开始监视集群中的特定资源对象</li>
<li>控制器通过API Server获取资源对象的当前状态，并将其与所需要的期望状态进行对比</li>
<li>如果二者不一致，那么控制器会触发相应的操作来使它们保持一致，这可能包括创建、更新或者删除资源对象</li>
<li>控制器通过API Server发出相应的操作请求，将更改应用于集群中的资源对象</li>
<li>控制器不断循环执行，以确保资源对象的状态和行为与期望状态保持一致</li>
</ol>
<p>**cloud-controller-manager(ccm)  **<br>嵌入了特定的云平台控制逻辑，云控制器管理器允许将你的集群连接到云提供商的API之上，并将与该云平台交互的组件同你的集群交互的组件分离开来。<br>与cm类似，ccm将若干逻辑上独立的控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。你可以对其执行水平扩容以提升性能或者增强容错能力。</p>
<ul>
<li>节点控制器（Node Controller）： 用于在节点终止响应后检察云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>CCM组件在启动的时候与云平台的API进行认证和链接，并监视云资源对象的状态</li>
<li>CCM的控制器通过与云平台的API进行交互，获取云平台资源对象的状态，并将其与K8S中的对象进行比较</li>
<li>如果二者状态不一致，CCM的控制器会触发相应的操作，通过与云平台的API发出请求，将更改应用于云资源</li>
</ol>
<h3 id="工作节点组件"><a href="#工作节点组件" class="headerlink" title="工作节点组件"></a>工作节点组件</h3><p>节点组件会在每个节点上运行，负责维护运行的pod并提供K8S运行环境</p>
<p>**kubelet **<br>kubelet会在集群中每个节点(node)上运行，它保证容器(containers)都运行在Pod中。<br>kubelet接收一组通过各类机制提供给它的PodSpecs，确保这些PodSpecs中描述的容器处于运行状态且健康，kubelet不会管理不是由k8s创建的容器，kubelet是k8s集群中的每个node上的主要组件之一，负责管理节点上的容器化工作负载，与控制平面交互，确保集群中的容器正确运行，并且维护节点的健康状态</p>
<p>主要功能：</p>
<ul>
<li>容器管理：kubelet负责在节点上创建、启动、停止和销毁容器，它通过与容器运行时（Docker Containerd）进行交互，执行容器的生命周期管理操作</li>
<li>资源管理：Kubelet监控节点的资源使用情况，并根据预定义的资源配额和调度策略来分配资源给容器，它会定期向K8S控制平面报告节点上的资源状态</li>
<li>健康检查：Kubelet定期对节点上的容器进行健康检查，包括容器的存活状态、资源利用率等，如果容器故障或者资源不足，Kubelet会尝试重启、恢复或迁移容器</li>
<li>节点注册：Kubelet在节点启动时将自身注册到K8s控制平面，使控制平面能够管理和监控该节点上的容器化工作负载</li>
<li>网络管理：Kubelet配置节点上的网络参数，包括容器网络和节点网络。它为容器分配IP地址，并配置容器之间和容器与外部的网络通信</li>
<li>卷管理：Kubelet负责挂在和卸载容器中使用的持久卷，它与卷插件交互，使容器能访问和使用持久化存储</li>
<li>日志和监控：Kubelet收集和管理节点上容器的日志和监控数据，它可以将日志发送到集中式日志系统，并提供容器的运行指标和事件信息</li>
</ul>
<p>工作流程如下：</p>
<ol>
<li>Kubelet监听来自K8S控制平面的指令和命令</li>
<li>K8S获取需要在节点上运行的pod列表，并根据指定的pod规范创建和管理容器</li>
<li>对于每个容器，Kubelet通过容器运行时（如Docker）来启动和停止容器，并监控其状态</li>
<li>Kubelet定期向K8s控制平面报告节点的资源使用情况和容器状态</li>
<li>Kubelet定期凑够控制平面获取Pod的更新和变更，并相应地执行容器的生命周期管理操作</li>
</ol>
<p><strong>kube-proxy</strong><br>kube-proxy是集群中每个节点(node)上所运行的网络代理，实现k8s概念的一部分，它维护节点上的一些网络规则，这些网络规则会允许从集群内部或外部的网络会话与Pod进行网络通信。运行在每个节点上，并与K8S控制平面和节点上的网络组件进行交互，以实现服务的可访问性和网络流量的转发<br>如果操作系统提供了可用的数据包过滤层，则kube-proxy会通过它来实现网络规则，否则，kube-proxy只做流量转发</p>
<p>主要功能：</p>
<ul>
<li>服务代理：Kube-proxy监听K8S控制平面中的服务和短空定义，并为它们创建对应的网络代理规则，这些规则通常基于IP Tables或者IPVS，根据服务的选择器和端口信息，将流量转发到相应的后端pod </li>
<li>负载均衡：Kube-proxy实现了负载均衡功能，将来自集群内部和外部的网络请求均匀地分发到后端的Pod。它可以基于轮询、随机选择或最少连接等算法来进行负载均衡</li>
<li>服务发现：Kube-proxy监听K8S控制平面中国的服务和端口定义的变化，当服务的Pod副本数量发生变化、服务的标签或者端口信息发生变更时，Kube-proxy会相应地更新代理规则，以确保服务的访问正常</li>
<li>节点故障处理：Kube-proxy监测节点的健康状态，并在节点故障或网络中断的情况下自动更新代理规则，它会将流量重新路由到其他健康节点上的Pod，以保证服务的高可用性</li>
<li>透明代理：Kube-proxy支持透明代理模式，可以在不修改应用程序代码的情况下，将应用程序流量转发到后端Pod。这种方式对应用程序是透明的，它们无需感知代理的存在</li>
</ul>
<p>Kube-proxy的工作流程如下：</p>
<ol>
<li>Kube-proxy从K8S控制平面获取服务和端口定义，并为每个服务创建代理规则</li>
<li>当有新的服务或端口定义添加到集群中，或者现有的定义发生变化时，Kube-proxy监测到变化并相应地更新代理规则</li>
<li>Kube-proxy监听来自服务暴露的端口上的网络流量</li>
<li>根据代理规则，Kube-proxy将流量转发到后端Pod上的容器，实现负载均衡和服务发现的功能</li>
</ol>
<p><strong>Container Runtime 容器运行时</strong><br>容器运行环境是负责运行容器的软件，K8S支持许多容器运行环境，例如containerd CRI-O 以及K8S CRI的其他任何实现<br>Container Runtime（容器运行时）是 Kubernetes 中负责管理和运行容器的核心组件。它提供了创建、启动、停止和销毁容器的功能，以及管理容器的资源和隔离性。</p>
<p>Kubernetes 支持多种容器运行时，其中最常用的是 Docker 和 Containerd。下面将详细介绍容器运行时的工作原理和功能：</p>
<ol>
<li>容器生命周期管理：容器运行时负责与容器生命周期相关的操作。它可以根据容器镜像创建并启动容器，监控容器的运行状态，并在需要时停止或销毁容器。 </li>
<li>容器隔离性：容器运行时使用 Linux 内核的命名空间和控制组（cgroup）等特性，为容器提供隔离的运行环境。每个容器都具有独立的文件系统、网络栈、进程空间和资源限制，从而实现容器之间的隔离和安全性。 </li>
<li>容器网络：容器运行时负责设置和管理容器的网络。它为每个容器分配唯一的 IP 地址，并处理容器之间的网络通信。容器运行时还可以与网络插件协同工作，以实现更高级的网络功能，如跨主机的容器通信和负载均衡。 </li>
<li>容器存储：容器运行时管理容器的存储。它可以为容器提供本地存储卷或挂载外部存储卷，使容器能够持久化存储和访问数据。 </li>
<li>容器镜像管理：容器运行时负责下载、管理和缓存容器镜像。它可以从容器镜像仓库中拉取镜像，并将其存储在本地节点上，以便在需要时快速创建容器。 </li>
<li>容器资源管理：容器运行时与 Kubernetes 的调度器和资源管理器交互，以确保容器在节点上得到适当的资源分配。它可以根据容器的资源需求和节点的可用资源进行调度和限制，以实现资源的公平分配和利用。</li>
</ol>
<p>容器运行时在 Kubernetes 中的工作流程如下：</p>
<ol>
<li>Kubernetes 控制平面下发容器启动的指令，包括容器镜像、资源要求等信息。 </li>
<li>容器运行时根据指令从容器镜像仓库拉取镜像，并创建容器的运行时环境。 </li>
<li>容器运行时使用 Linux 命名空间和控制组等功能，为容器提供隔离的运行环境。 </li>
<li>容器运行时启动容器中的应用程序，并监控容器的运行状态。 </li>
<li>容器运行时与容器网络 插件协同工作，为容器分配 IP 地址，并处理容器之间的网络通信。</li>
<li>容器运行时根据 Kubernetes 控制平面的指令，停止或销毁容器。</li>
</ol>
<p>总之，容器运行时是 Kubernetes 中关键的组件之一，它负责管理和运行容器，提供容器的隔离性、生命周期管理、网络和存储功能，与其他 Kubernetes 组件协同工作，实现容器化应用程序的高效运行和管理。</p>
<p><strong>node、kubelet、pod和container之间的联系</strong></p>
<p>Node：是K8S集群中的工作节点，也被称为主机或者服务器，每个Node提供容器运行的基础设施，并承载运行着的容器<br>Kubelet：是运行在每个Node上的K8S组件之一，是Node上的代理程序，Kubelet负责管理和运行Node上的容器，并与K8S控制平面交互<br>Pod:Pod是K8S的最小调度和部署单元，它是一个逻辑上相关的容器组，可以包含一个或者多个容器，Pod提供了一个抽象层，为容器提供共享的网络和存储资源，使容器之间可以进行通信和共享数据，Pod是在Node上进行调度和运行的<br>Container：容器是在Pod中运行的实际应用程序或服务，一个Pod可以包含一个或者多个容器，这些容器共享同一个网络命名空间和存储卷，容器被kubelet创建、启动、停止和销毁</p>
<p>通过这种方式，kubelet作为Node上的代理程序，负责与Kubernetes控制平面交互，并协调管理Node上的容器。Pod是在Node上调度和运行的最小单元，它可以包含一个或多个容器，这些容器共享同一个网络和存储环境。这种关系使得kubernetes可以以分布式和高可用的方式运行和管理容器化应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">消息队列系统学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-28 23:07:27" itemprop="dateCreated datePublished" datetime="2023-05-28T23:07:27+08:00">2023-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-30 13:03:52" itemprop="dateModified" datetime="2023-05-30T13:03:52+08:00">2023-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>博客:cbb777.fun</p>
<p>全平台账号:安妮的心动录</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/anneheartrecord">https://github.com/anneheartrecord</a></p>
<p>下文中我说的可能对，也可能不对，鉴于笔者水平有限，请君自辨。有问题欢迎大家找我讨论</p>
<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列，我们一般会称为MQ（Message Queue）,也就是说消息队列的本质就是一个队列，而队列是一种先进先出的数据结构，提供<strong>消息传递和消息排队</strong>模型，可以在分布式环境下提供应用解耦、弹性伸缩、流量削峰、异步通信、数据同步、微服务之间通信等功能，作为分布式系统架构中的一个重要组件，有着举足轻重的地位<br>我们会将要传输的数据、消息放在消息队列中<br>其中，往MQ里放东西的叫做生产者<br>从MQ里面取消息的叫做消费者</p>
<h2 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>现在有一个系统A，A可以产生一个UserId<img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565301195-6a5df167-0f49-4812-b648-247b6c15cf0e.png"><br>然后有系统B和系统C都需要这个UserId去做相关的操作<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565335300-52330f30-1d93-49be-b70b-c50906a61096.png"><br>这样就会有一个问题，每当出现改动的时候，我都要改动整个系统，比如B不需要A的消息了，那么就要改A、B，新来的一个D服务，需要用到A的消息，那么又需要修改，整个系统的冗余度很高<br>引入消息队列之后：系统A将id写到消息队列中，BC服务从消息队列中拿数据</p>
<p>系统A只负责写数据，不关心数据的消费、处理，而BC服务只负责拿数据，即使BC服务挂了，也和系统A没关系，只和消息队列有关，这样就能做到多个服务之间的解耦</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565724785-78356256-717e-4f5a-865d-90afe84f7226.png"><br>如果是同步的话，A必须要等待B C D 处理完之后才能返回，整个时间比较久<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670565780159-8d1d3475-6244-4a13-b440-bf94f90cedab.png"><br>如果是异步的话，A（比如注册服务）将消息写道消息队列之后就可以返回，之后再发给邮件服务和短信服务消费</p>
<h3 id="限流、削峰"><a href="#限流、削峰" class="headerlink" title="限流、削峰"></a>限流、削峰</h3><p>当请求来的时候，先把请求放在消息队列中，然后系统再根据自己能够处理的请求数去消息队列里面拿数据，这样即使每秒请求数很大，也不会把系统打崩</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>消息队列通常有很多种方式来实现流量控制</p>
<p>1.配额控制：通过为每个生产者或者消费者分配配额，限制它们可以发送或者接受的消息数量。这可以保证消息队列中的资源不会被过度使用，并确保系统在高负载情况下的稳定性</p>
<p>2.窗口机制：当生产者将消息发送到消息队列的时候，消息队列会给每个生产和分配一个发送窗口，当消费者确认之后把对应的消息从窗口里面删除</p>
<p>3.缓冲区：消息队列把消息往缓冲区里丢，消费者从缓冲区里去取</p>
<p>4.速率限制：这个一般是在客户端实现的，可以实现生产者在每秒、每分钟生产多少条消息</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h3><p>常见的消息队列都有确认机制（ACK机制），当消费者消费数据之后会给消息队列中间件发送一个确认消息，消息队列收到之后就会把这条消息从队列中删除。</p>
<p>当出现网络传输等故障，ACK没有传送到消息队列，导致消息队列不知道消费者已经消费过该消息了，再次将消息分发给其他的消费者</p>
<p>解决：</p>
<p>1.看场景，如果场景不需要幂等，那么可以不管，比如这条消息拿去插入数据库，重复插入主键相同的数据是会自动出错的，再比如做redis的set操作，也不需要管，多次set之后仍然是幂等的</p>
<p>2.准备第三方介质做消费记录，比如加个redis，给消息分配一个全局id，只要消费过该消息就将&lt;id,message&gt;写入redis。消费者消费之前先去redis中查有没有消费记录即可</p>
<h3 id="如何保证消息的可靠性传输"><a href="#如何保证消息的可靠性传输" class="headerlink" title="如何保证消息的可靠性传输"></a>如何保证消息的可靠性传输</h3><p>消息队列丢数据主要有三个可能</p>
<p>1.生产者丢数据</p>
<p>2.消息队列组件丢数据</p>
<p>3.消费者丢数据</p>
<p>生产者：可以采用transaction机制，开启事务来发送消息，如果发送失败就回滚。但是生产中用的不多，因为会导致吞吐量的下降，一般都是用confirm机制，如果生产者成功把消息发送给队列，队列会回一个ack，否则回一个nack</p>
<p>消息队列：可以开启持久化，而且一般是集群部署的，有master和slave节点，一般都是同步复制，只有主节点和从节点都写入成功才返回ack给生产者</p>
<p>消费者：取消自动确认，自动确认后消息队列收到ACK会立马把消息从队列中删掉，而是手动确认（即处理后才回ACK）。</p>
<h2 id="消息队列需要考虑的问题"><a href="#消息队列需要考虑的问题" class="headerlink" title="消息队列需要考虑的问题"></a>消息队列需要考虑的问题</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>消息队列肯定不是单机的，这样可用性和健壮性都非常差，所以项目中使用的消息队列都得集群或者分布式</p>
<h3 id="数据问题"><a href="#数据问题" class="headerlink" title="数据问题"></a>数据问题</h3><p>消息丢失：当消费者拿了数据还没使用的时候，服务就挂掉了，就会导致消息的丢失，一般会使用ACK应答机制，当消费者拿到消息发送确认ACK信号，消息队列才会把对应的消息删掉</p>
<p>消息堆积：消息堆积分为客户端堆积和服务端堆积<br>一般都会设置告警规则来通知开发者消息堆积的问题</p>
<p>如果是客户端消息堆积，那可以考虑扩大消费线程或者节点来解决， 针对于某些特殊场景，如果消息堆积已经影响到业务，并且堆积的消息可以跳过不消费，那么可以重置消费消息位置为最新位置开始消费，快速恢复业务。</p>
<p>如果是服务端消息堆积，考虑服务端宕机的情况，快速恢复之后重新可用</p>
<h3 id="消费者取数据"><a href="#消费者取数据" class="headerlink" title="消费者取数据"></a>消费者取数据</h3><p>两种方法</p>
<p>1.push 消息队列有新消息的时候主动叫消费者去拿，实时性强。如果消费者故障，服务端堆积消息。</p>
<p>2.pull 消费者不断的轮询消息队列，看看有没有新数据，如果有就消费，实时性弱。</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670576619633-e8cfd841-4823-44df-b3dd-eecd0052c3eb.png"></p>
<h2 id="消息队列的传输模式"><a href="#消息队列的传输模式" class="headerlink" title="消息队列的传输模式"></a>消息队列的传输模式</h2><h3 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h3><p>用于消息生产者和消息消费者之间点到点的通信，消息生产者将消息发送到某个特定的消费者<br>特点：<br>1.每个消息只有一个消费者<br>2.发送者和接收者都没有时间依赖<br>3.接受者确认消息接受和处理成功</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670575350774-76cb25c0-2bae-4ac7-baae-ecb911767458.png"></p>
<h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p>发布订阅模型支持向一个特定的消息主题产生消息，在这种模型下，发布和订阅者彼此不知道对方的存在，多个消费者可以获得消息，在发布者和订阅者之间存在<strong>时间依赖性</strong>，<strong>发布者publish</strong>需要建立一个<strong>订阅subscription</strong>，以便消费者能够订阅。订阅者必须<strong>保持持续的活动状态</strong>并<strong>接受消息</strong></p>
<p>主题、订阅、消费者（组）之间的关系为 M：N：O</p>
<p>在这种情况下，订阅者未连接时，发布的消息将<strong>在订阅者重新连接的时候重新发布</strong><br>特点：<br>1.每个消息可以有多个订阅者<br>2.客户端只有订阅之后才能收到消息<br>3.持久订阅和非持久订阅</p>
<p>持久订阅：订阅关系建立之后，消息就不会消失，不管订阅者是否在线<br>非持久订阅：订阅者为了接受消息，必须一直在线，当只有一个订阅者的时候等于点对点模式</p>
<h3 id="pub-sub-vs-queue"><a href="#pub-sub-vs-queue" class="headerlink" title="pub-sub vs queue"></a>pub-sub vs queue</h3><p>发布订阅和队列模式是消息队列中的两种不同的消息模式</p>
<p>发布-订阅模式：发布者将消息发送到特定的主题（topic）上，订阅者可以选择订阅感兴趣的主题，从而接受与该主题相关的消息。在该模式中，消息被广播给所有订阅者，每个订阅者可以独立处理消息，订阅者之间不会相互干扰。发布-订阅模式通常用于广播消息或者通知</p>
<p>队列模式：消息发送到队列中，然后一个或者多个消费者从队列中收取并处理消息。在该模式中，每条消息只能被一个消费者接收和处理。如果有多个消费者，消息将被平均分配给它们。队列模式通常用于实现任务分配或者负载均衡等场景</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670575824095-d0f958e8-2464-46ad-9afd-0faf74cd101b.png"></p>
<h2 id="市面上消息队列对比"><a href="#市面上消息队列对比" class="headerlink" title="市面上消息队列对比"></a>市面上消息队列对比</h2><p>记住两个最常见的MQ的对比就可以，硬盘MQ代表是Kafka 内存MQ代表是RabbitMQ</p>
<p>Kafka的优点是客户端支持多语言、使用pull模式，支持消息批量操作，支持replica机制，Zookeeper自动选举leader恢复能力，数据可靠，有容错容灾的能力，单机吞吐量为10W级，延迟毫秒，数据基于硬盘层面存储，多Client支持有序，不支持事务，但是可以通过LOW LEVEL API的方式保证消息只支持消费一次</p>
<p>RabbitMQ的优点是客户端支持多语言，多协议支持，不支持消息批量操作，有pull和push两种模式，使用的主从模式master&#x2F;slave，master提供服务，slave做备份，数据可靠（因为有备份），单机吞吐量为万级别，消息延迟为微秒级，内存级别，可以主动开启持久化，支持集群和负载均衡，不保证多Client消息有序</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1670576658702-ebe9380a-41e5-4206-9f90-ce09c6af384d.png"></p>
<h3 id="pulsar-kafka-rabbitmq-nsq的异同"><a href="#pulsar-kafka-rabbitmq-nsq的异同" class="headerlink" title="pulsar kafka rabbitmq nsq的异同"></a>pulsar kafka rabbitmq nsq的异同</h3><p>1.pulsar 和 kafka基于发布订阅模式，而rabbitmq 和 nsq基于的是队列模式</p>
<p>2.pulsar和kafka都采用了持久化机制，以支持高吞吐量和高可靠性，而rabbitmq和nsq则将数据存储在内存中，以支持更低的延迟和更高的吞吐量</p>
<p>3.pulsar和kafka都支持 多租户和多数据中心部署，可以轻松地在多个数据中心或者云平台上进行扩展，而rabbitmq和nsq则更加适合单个数据中心的部署</p>
<p>4.pulsar和kafka都具有出色的可伸缩性和高可用性，处理数据单位是百万级别的；而rabbitmq和nsq则更加适合小规模的应用程序，具有更低的延迟和更高的性能</p>
<p>5.pulsar和kafka都提供了消息流的处理程序，使用户可以对消息进行实时分析和处理</p>
<p>总的来说：pulsar和kafka更适合处理大量消息和数据流，rabbitmq和nsq则更适合小规模应用程序，具有更低的延迟和更高的性能</p>
<h1 id="Pulsar底层实现"><a href="#Pulsar底层实现" class="headerlink" title="Pulsar底层实现"></a>Pulsar底层实现</h1><p>Pulsar是Apache基金会的顶级项目，是<strong>云原生的分布式消息队列</strong>，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据恢复机制，具有强一致性、高吞吐、低时延及高可扩展性等流数据存储特性</p>
<ul>
<li>云原生MQ</li>
<li>单个Pulsar实例原生支持多集群，可跨机房完成消息复制</li>
<li>支持超过一百万个topic</li>
<li>支持多语言客户端</li>
<li>主题多种订阅模式（独占、共享和故障转移）</li>
<li>通过Book Keeper来实现持久化存储，保证消息传递</li>
<li>分层式存储，可在数据陈旧时将数据从热存储卸载到冷存储中</li>
</ul>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Messages有很多的部分组成， 下面是几个值得注意的</p>
<ul>
<li>value&#x2F;payload 消息的数据</li>
<li>properties 可选的属性，是一个key-&gt;value的键值对</li>
<li>producer name 生产者名称</li>
<li>publish time 发布时间戳</li>
<li>sequence id 在topic中 每个msg属于一个有序的队列 sequence id是它在序列中的次序</li>
</ul>
<p>Pulsar和其他的MQ一样，会对消息的大小做出限制</p>
<p>这个限制通过broker.conf中的maxMessageSize 决定</p>
<p>不设置的话，默认为5MB</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者是关联到topic的程序，它发布消息到Pulsar的broker上</p>
<p><strong>发送模式</strong></p>
<ul>
<li>异步发送：生产者发送消息之后会等待broker的确认，如果没有收到确认则认为是发送失败</li>
<li>同步发送：会把消息放在阻塞队列中，然后立马返回，然后这个阻塞队列会往broker中发消息</li>
</ul>
<p><strong>主题访问模式</strong></p>
<ul>
<li>Shared（共享）  多个生产者可以发布一个主题，这是默认设置</li>
<li>Exclusive（独占） 一个主题只能由一个生产者发布，如果已经有生产者链接，其他生产者试图发布该主题将立即得到错误。如果”老”的生产者与broker发生网络分区，”老”生产者将被驱逐，”新”生产者将被选为下一个唯一的生产者</li>
<li>WaitForExclusive（独占等待） 如果已经有一个生产者连接，生产者的创建是未决的，直到生产者获得独占访问。成功成为排他性的生产者被视为领导者，因此，如果想实现leader选举方案，可以使用这种模式</li>
</ul>
<p><strong>压缩、批处理与分块</strong><br>压缩：我们可以主动压缩生产者在传输期间发布的消息，Pulsar目前支持以下类型的压缩</p>
<ul>
<li>LZ4</li>
<li>ZLIB</li>
<li>ZSTD</li>
<li>SNAPPY</li>
</ul>
<p>批处理：如果批处理开启，producer将会积累一批消息，然后通过一次请求发送出去。批处理的大小取决于最大的消息数量及最大的延迟发布</p>
<p>分块：分块和批处理不能同时启用，要启用分块，必须提前禁用批处理。Chunking只支持持久化的主题</p>
<p>一个producer与一个订阅consumer的分块消息<br>当生产者向主题发送一批大的分块消息和普通的非分块消息时。将M1切成分块M1-C1、M1-C2、M1-C3。这个broker在其管理的ledger里面保存所有的三个块消息，然后以相同的顺序分发给消费者（独占&#x2F;灾备）。消费者将在内存缓存所有的块消息，直到收到所有的消息快。将这些消息合并成为原始的消息M1，发送给处理进程<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682219039171-07775a32-cf8b-4b8f-87ab-d77646e3db76.png"></p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费者通过订阅关联到主题，然后接受消息的程序</p>
<p><strong>接收模式</strong></p>
<p>消息可以通过同步或者异步的方式从broker接受</p>
<p>同步：同步接收将会阻塞，直到消息可用</p>
<p>异步：异步接收立刻返回future值，一旦新消息可用，它将即可完成</p>
<p><strong>监听</strong></p>
<p>客户端类库提供了它们对于consumer的监听实现，在这个接口中，一旦接受到新的消息，received方法将被调用</p>
<p><strong>确认</strong></p>
<p>消费者成功处理消息之后需要发送确认（ack）给broker，以让broker丢掉这条消息（否则将一直存储）。消息的确认可以逐个进行，也可以累积到一起。累计确认的时候，消费者只需要确认最后一条它收到的消息，所有之前的消息都认为被成功消费。累积确认不能用于shared模式，因为shared订阅为同一个订阅引入了多个消费者</p>
<p><strong>主题</strong></p>
<p>和其他的MQ一样，Pulsar中的topic是带有名称的通道，用来从producer到consumer传输消息，topic的名称是符合良好结构的URL</p>
<p><code>&#123;persistent|non-persistent&#125;://tenant/namespace/topic</code></p>
<ul>
<li>peisistent|non-persistent 定义了topic的类型，Pulsar支持两种不同的topic：持久化和非持久化，默认是持久化类型，也就是会保存到硬盘上的类型</li>
<li>tenant 实例中topic的租户，tenant是Pulsar多租户的基本要素，可以被跨集群的传播</li>
<li>namespace topic的管理单元，与topic组的管理机制相关。大多数的topic配置在namespace层面生效，每个tenant可以有多个namespace</li>
<li>topic 主题的最后组成部分</li>
</ul>
<p><strong>Partitioned topics 分区主题</strong></p>
<p>普通的主题只由单个broker提供服务，这限制了主题的最大吞吐量，分区主题是由多个broker处理的一种特殊类型的主题，因此允许更高的吞吐量<br>分区主题实际上实现为N个主题，N是分区的数量。当消息发布到分区主题的时候，每个消息都被路由到几个Broker中的一个。分区在broker之间的分布由Pulsar自动的进行处理<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682220786986-bcdaace6-1ac7-48f7-b874-208796a3b695.png"><br>如上图，Topic有五个分区，划分在3个broker上，因为分区比broker多，前两个broker分别处理两个分区，而第三个broker只处理一个分区（Pulsar自动处理分区的分布）<br>此主题的消息将广播给两个消费者，路由模式决定将每个消息发布到哪个分区，而订阅模式决定将哪些消息发送到哪个消费者</p>
<p><strong>路由模式</strong></p>
<ul>
<li>RoundRobinPartition message无key则轮询，有key则hash指定分区（默认模式）</li>
<li>SinglePartition message 无key 则producer将会随机选择一个分区，将所有的消息都发送给该分区。如果message有key，那么会hash指定分区</li>
<li>CustomParition 使用自定义消息路由实现</li>
</ul>
<p><strong>顺序保证</strong></p>
<p>消息的顺序与路由模式和消息的key有关</p>
<ul>
<li>Per-key-partition （按key分区） 具有相同key的所有消息将被顺序放置在同一个分区中</li>
<li>Per-producer （按照Producer） 来自同一生产者的所有消息都是有序的</li>
</ul>
<p><strong>哈希方案</strong></p>
<p>HashingScheme是一个enum，表示在选择要为特定消息使用的分区时可用的标准哈希函数集</p>
<p>有两种类型的标准哈希函数可用：JavaStringHash和Murmur3_32Hash，生产者的默认哈希函数是Java，但是当生产者的客户端是多语言的时候，Java是没用的</p>
<p><strong>持久&#x2F;非持久化主题</strong></p>
<p>默认情况下,Pulsar会保存所有没确认的消息到Book Keeper中，持久Topic消息会在broker重启或者consumer出问题的时候保存下来</p>
<p>Pulsar也支持非持久化Topic 这些Topic的消息只存在于内存中，不会存储到磁盘</p>
<p>因为Broker不会对消息进行持久化存储，当Producer将消息发送给Broker时，Broker可以立即将ack返回给Producer，所以非持久化的消息传递会比持久化的更快。相对的，当Broker因为一些原因宕机、重启后，非持久化的Topic消息都会消失，订阅者将无法收到这些消息。</p>
<p><strong>Dead letter topic 死信主题</strong></p>
<p>死信主题允许你在用户无法成功消费某些消息时使用新消息。在这种机制中，无法使用的消息存储在单独的主题中，成为死信主题。</p>
<p>死信主题依赖于消息的重新投递，由于确认超时或者否认确认，消息将被重新发送。如果要对消息使用否定确认，请确保在确认超时之前对齐进行否定确认。</p>
<p><strong>Retry letter topic 重试主题</strong></p>
<p>对于许多在线业务系统，由于业务逻辑处理中出现异常，消息会被重复消费。</p>
<p>若要配置重新消费失败消息的延迟时间，可以配置生产者将消息发送到业务主题和重试主题，并在消费者上启用自动重试。当在消费者上启用自动重试的时候，如果消息没有被消费，那么就会存储到重试主题中，在指定的延迟时间后，消费者会主动接受来自重试主题的失败消息</p>
<p><strong>订阅模式</strong></p>
<p>Pulsar支持exclusive （独占） failover（灾备） shared（共享） 和 key_shared（Key共享）四种消息订阅模式，示意图如下<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231688042-eeae1153-5dd6-4257-ab60-8b8514176129.png"></p>
<p><strong>独占模式</strong><br>默认的消息订阅模式。只能有一个消费者消费消息<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231855780-0822f566-06df-4dd8-8bdd-3c1d7284dfa1.png"></p>
<p><strong>灾备模式</strong><br>灾备模式下，一个topic也是只有单个consumer消费一个订阅关系的消息，但是在这个模式下，每个消费者会被排序，当前面的消费者无法连接上broker后，消息会由下一个消费者进行消费<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231915296-3eed9904-91c2-43b4-b850-2b53441c8fe4.png"><br><strong>共享模式</strong><br>共享模式下，消息可被多个consumer同时消费，无法保证消费的顺序，消息通过roundrobin的方式投递到每一个消费者<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682231969316-adf66ecb-d07a-49d5-aff9-33594197eefa.png"><br><strong>key共享模式</strong><br>按照key对消息进行投递，相同的key的消息会被投递到同一个consumer上，消费示意图如下<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682232008012-741758f7-8650-4ae5-a9c9-63bcdb815600.png"></p>
<p><strong>消息保留与过期</strong><br>默认策略</p>
<ul>
<li>立即删除所有被消费者确认过的消息</li>
<li>以backlog的形式，持久化保存所有未被确认的消息</li>
</ul>
<p>两个特性</p>
<ul>
<li>消息保留可以让你保存consumer确认过的消息</li>
<li>消息过期可以让你给未被确认的消息设置ttl</li>
</ul>
<p>消息保留和过期是针对namesapce层面进行设置和管理的</p>
<p><strong>消息去重</strong></p>
<p>实现消息去重的一种方式是确保消息只生产一次，即生产者幂等，这种方式的缺点在于把消息去重的工作交给应用来做。<br>在pulsar中，broker支持配置开启消息去重，用户不需要主动在代码中保证Producer只生产一次，启动之后即使消息被多次发送到topic上，也只会被持久化到磁盘一次</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682240083542-ca650a22-889b-4906-be94-014ecf18debe.png"></p>
<p>原理：Producer对每一个发送的消息，都会采用递增的方式生成一个唯一的sequence ID，这个消息会放在message的元数据中传递给broker。</p>
<p>同时，broker也会维护一个pendingmessage队列，当broker返回发送成功ack之后，producer会将pendingmessage队列中的sequence id删除，标识producer任务这个消息生产成功。</p>
<p>broker会记录针对每个producer接受到的最大sequence id和已经处理完的最大sequence id</p>
<p>当broker开启消息去重之后，Broker会针对每个消息请求进行是否去重的判断，如果消息重复，则直接返回ack，不走后续存储的流程</p>
<p><strong>延时消息</strong></p>
<p>延时消息功能允许Consumer能够在消息发送到topic之后，过一段时间之后才能消费到这条消息。在这种集中中，消息在发布到broker之后，会被存储在book keeper中，当到消息特定的延迟时间时，消息就会传递给consumer</p>
<p>broker不会在存储的时候做特殊处理，而是会把设置了延迟时间的消息加入到DelayedDeliveryTracker中，当到了指定的发送时间时，Tracker才会把这条消息推送给消费者</p>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243085046-f38a72f7-331c-432c-b990-e8de4b438bc4.png"><br>原理：</p>
<p>在Pulsar中有两种方式实现延迟消息，分别为deliverAfter和deliverAt</p>
<p>deliverAfter可以指定在多长时间之后进行消费</p>
<p>deliverAt可以指定具体的延迟消费时间戳</p>
<p>DelayedDeliveryTracker会记录所有需要延迟投递的消息的index，index由timestamp、 ledger id 、和entry id三部分组成，其中ledger id 和 entry id用来定位该消息</p>
<p>timestamp除了记录需要投递的时间，还用于延迟优先级队列排序。tracker会根据延迟时间对消息进行排序<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243400607-7ce2e51a-9fc5-48bd-a1be-dfa226eb2fd7.png"></p>
<p><strong>多租户模式</strong></p>
<p>Pulsar的云原生架构天然支持多租户，每个租户下还支持多Namespace，非常适合做共享大集群，方便维护。此外Pulsar天然支持租户之间的逻辑隔离，防止互相干扰，还能实现大集群资源的充分利用</p>
<ul>
<li>Tenant（租户）和 Namespace是Pulsar支持多租户的两个核心概念</li>
<li>在租户级别，Pulsar为特定的租户预留合适的存储空间、应用授权和认证机制</li>
<li>在namespace级别，Pulsar有一系列的配置策略（policy），包括存储配额、流控、消息过期策略等等</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682243577968-08304a97-3d76-453a-85a1-10a8ab01388e.png"></p>
<p><strong>统一消息模型</strong></p>
<p>Pulsar做了队列模型和流模型的统一，在topic级别只需要保存一份数据，同一份数据可多次消费。以流式、队列等方式计算不同的订阅模型，大大的提升了灵活度</p>
<p>同时Pulsar通过事务采用Exactly-Once刚好一次的语义，在进行消息传输过程中，可以确保消息不重不丢<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682244903659-cac62393-1696-488c-bf90-160904556ea4.png"></p>
<p><strong>分片流</strong></p>
<p>Pulsar将无界的数据看作是分片的流，分片分散存储在分层存储（tiered storage）、BookKeeper集群和Broker节点上，而对外提供一个统一的、无界数据的视图</p>
<p>不需要用户显示迁移数据，对用户无感知，减少存储成本并保持近似无限的存储<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682301934196-2cc57808-2996-478a-a2af-458ebb95ce7e.png"></p>
<p>跨地域复制</p>
<p>Pulsar中的跨地域复制是将Pulsar中持久化的消息在多个集群之间备份<br>在Pulsar2.4.0中新增了复制订阅模式，在某个集群失效情况下，该功能可以在其他集群恢复消费者的消费状态，从而达到热备模式下的消息服务高可用<br><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682302140012-861fac45-f4a9-40a3-a11a-e843e0093230.png"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>单个Pulsar集群由以下三部分组成</p>
<ul>
<li>一个或者多个broker 用于负责处理和负载均衡producer发出的消息 并将这些消息分派给consumer。Broker 和 Pulsar配置存储交互来处理相应的任务，并将消息存储在BookKeeper实例中（bookies）；Broker底层依赖的是Zookeeper集群来处理特定的任务</li>
<li>包含一个或者多个bookie的BookKeeper负责消息的持久化存储</li>
<li>一个ZooKeeper集群用来处理多个Pulsar集群之间的协调任务</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682307910434-a21873d5-4aea-4273-a704-33f2b20b5c06.png"></p>
<p>Pulsar分离出Broker和Bookie两层架构，Broker为无状态的服务，用于发布和消费消息，而BookKeeper专注于存储，Pulsar存储是分片的，这种架构可以避免扩容时受到限制，实现数据的独立拓展和快速恢复</p>
<p><strong>Brokers</strong><br>Pulsar的broker是一个无状态的组件，主要负责运行另外的两个组件</p>
<ul>
<li>一个HTTP服务器（service discovery） 它暴露了REST系统管理接口以及在生产者和消费者之间进行Topic查找的API</li>
<li>一个调度分发器（Dispatcher） 它是一个异步的TCP服务器 通过自定义二进制协议应用与所有相关的数据传输</li>
</ul>
<p>出于性能考虑，消息通常从Managed Ledger缓存中分派出去，除非积压超过缓存大小。如果积压的消息对于缓存来说太大了，则Broker开始从BookKeeper中读取Entries</p>
<p>为了支持全局Topic异地复制，Broker会控制Replicators追踪本地发布的条目</p>
<p><strong>ZooKeeper元数据存储</strong></p>
<p>Pulsar使用ZooKeeper进行元数据存储、集群配置和协调</p>
<ul>
<li>配置存储Quorum存储了租户、命名空间、和其他需要全局一致的配置项</li>
<li>每个集群有自己独立的本地ZooKeeper保存集群内部的配置，例如broker负责哪几个主题及所有权归属元数据、broker负载报告ledger元数据等等</li>
</ul>
<p><strong>BookKeeper持久化存储</strong></p>
<p>Apache Pulsar为应用程序提供有保障的信息传递，如果消息成功到达broker，就认为其预期达到了目的地</p>
<p>为了提供这种保证，未确认送达的消息需要持久化直到它们被确认送达。这种消息传递模式通常成为持久消息传递，在Pulsar内部，没分新消息都被保存并同步N份</p>
<p>BookKeeper是一个分布式的预写日志（WAL）系统，有如下几个特性</p>
<ul>
<li>使得Pulsar能够利用独立的日志，称为ledgers，随着时间的推移可以为topic创建多个ledgers</li>
<li>保证多系统挂掉时的ledgers的读取一致性</li>
<li>提供不同Boookies之间均匀的IO分布的特性</li>
<li>容量和吞吐量都具有水平伸缩性，能够通过增加bookies立即增加容量到集群中</li>
</ul>
<p><img src="/2023/05/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/2_1_1682317442354-57387d85-94bc-47b5-8615-f2bcb012be42.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:26</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
