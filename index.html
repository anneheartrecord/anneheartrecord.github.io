<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远不要高估自己">
<meta property="og:type" content="website">
<meta property="og:title" content="安妮的心动录的园子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="安妮的心动录的园子">
<meta property="og:description" content="永远不要高估自己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安妮的心动录">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>安妮的心动录的园子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安妮的心动录的园子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BC%9A%E6%8C%81%E7%BB%AD%E5%86%99%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BC%9A%E6%8C%81%E7%BB%AD%E5%86%99%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">为什么我会持续写面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:19:07 / 修改时间：22:23:43" itemprop="dateCreated datePublished" datetime="2023-03-27T22:19:07+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么我会持续写面经？"><a href="#为什么我会持续写面经？" class="headerlink" title="为什么我会持续写面经？"></a>为什么我会持续写面经？</h1><p>从我去年投出第一份简历，经历第一场面试，到现在应该已经陆陆续续面了好几十场了，小厂、中厂、大厂都有，基本上每一场面试我都有做记录并且review，我觉得这是一件很有意义并且回报很高的事情</p>
<h2 id="提升专业技能"><a href="#提升专业技能" class="headerlink" title="提升专业技能"></a>提升专业技能</h2><p>我认为在技术岗方面，对于在校生来说，不论是实习还是秋招、春招，对于你的专业技能硬性要求大概只有这些</p>
<ul>
<li>工程方面的能力：你写了什么项目，你对自己的项目理解的程度深不深，常用的技术栈你学的怎么样，你的debug能力，把你招进来是不是真的能有产出，一些常用的框架、命令、工具你会不会用，会不会协同合作等等</li>
<li>基础方面的能力：比如MySQL、Redis、MQ、Linux命令的使用，设计模式的理解，再到八股文（操作系统、计网、数据结构、计算机组成、编译原理、MySQL底层、Redis底层、MQ底层、一些工具的底层比如Docker等等）</li>
<li>做题的能力：目前来看算法题能不能写出来越来越重要了，写不出题面试过的概率微乎其微</li>
<li>知识的深度和广度：这些就属于随缘考察了，面试官问什么都可能，可能是智力题、逻辑题，也有可能是云原生、分布式、微服务这种比较新的东西</li>
</ul>
<p>而做好面试记录，编写面经的过程中你就能很清楚的知道，在面试过程中你哪些点答的好，哪些点答的不好，你可以听面试官的语气来察觉出你给出的答案是不是他想听到的，然后对自己的整个知识框架进行查漏补缺</p>
<p>注意：<strong>这里的查漏补缺不是一有答不上来的问题就去学</strong>，这样成本太大了，挑你觉得你需要会的东西去学。</p>
<p>比如你从来没用过某个技术栈，所以答不上来某个问题，这个技术栈你目前用不到，也不是必会的技能，那就完全没必要去学。</p>
<p>但是如果你是某个很重要的点，比如设计模式不会，那我强烈建议你去好好学一学。</p>
<h2 id="提升软素质"><a href="#提升软素质" class="headerlink" title="提升软素质"></a>提升软素质</h2><p>除了专业技能之外，面试也会考察候选人的软素质，比如语言表达能力、抗压能力等等。我觉得逻辑清晰，语句通顺，面试官能听懂你说的东西，并且觉得你说的有道理，这是很重要的一个能力。</p>
<p>比如说某个八股文的点，你和面试官的理解可能不一样，但是你能把自己的逻辑讲清楚，为什么会是这样，能够自圆其说，说出来的逻辑能够闭环，哪怕你说的东西是错的，都会比卡在那里好很多。</p>
<p>及时做面经能够很明显的感觉出来自己刚刚哪里表述有问题，哪里逻辑不清晰，哪里口误，哪里明明心里是会的，但是说出来很混乱，这样就能尽量避免下次再犯类似的错误。</p>
<h2 id="正向反馈"><a href="#正向反馈" class="headerlink" title="正向反馈"></a>正向反馈</h2><p>不得不承认，真正热爱技术的人绝对是少之又少，大部分人投身技术领域主要还是为了一口饭吃。讨厌技术和热爱技术在学习和工作中绝对是两种不同的心态，并且成长速度也是绝对不一样的。</p>
<p>那么该怎么让自己不讨厌技术，甚至爱上技术呢？</p>
<p>引入开源思想，写面经、写博客，绝对是一个很好的方法。当我写出来的东西能帮他人解决问题，能够获得别人的赞同，能起到哪怕一点点微小的帮助，对我来说也是一种认同+满足，不断的重复这个过程，慢慢的去影响越来越多的人，帮助到越来越多的人，是一件很快乐的事情，至少对于我来说是这样。</p>
<h2 id="养成review的习惯"><a href="#养成review的习惯" class="headerlink" title="养成review的习惯"></a>养成review的习惯</h2><p>及时复习，及时review绝对是帮助你提升效率的一大杀器，但是很遗憾的是大部分人都没有这个能力。从小我们接受的学习模式应该是：预习-正式学习-复习这么一个过程，上了大学之后基本没有预习这一说了，学习模式变成了：学习-复习这个过程。</p>
<p>不讨论这个模式是否正确，但是从记忆曲线来说，复习、及时复习、多次复习，这个过程的回报率是比只学习、不复习的模式强很多很多的，review一次的时间一般不会超过正式学习的20%，而效果会比只学习一次强很多很多。</p>
<p>所以不管是刷题、学技术、还是学知识，我都建议大家可以试着去review，如果不知道该如何踏出第一步，也许你可以试试从写一份面经开始。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/limit%E4%B8%8E%E5%88%86%E9%A1%B5%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/limit%E4%B8%8E%E5%88%86%E9%A1%B5%E9%94%AE/" class="post-title-link" itemprop="url">limit与分页键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:18:40 / 修改时间：22:24:19" itemprop="dateCreated datePublished" datetime="2023-03-27T22:18:40+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="limit与分页"><a href="#limit与分页" class="headerlink" title="limit与分页"></a>limit与分页</h2><p>在SQL中，limit用于限制返回的结果行数。LIMIT语句可以用于SELECT查询，用于<strong>限制查询结果集的行数</strong>，从而在处理大型数据集时，减少数据库的负载，提高查询的性能</p>
<p>基本语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name LIMIT [offset],row_count;</span><br><span class="line">//table_name是表名</span><br><span class="line">//offset是可选的偏移量，用于指定要从结构集的哪个位置开始返回行</span><br><span class="line">如果省略该参数，默认从第一行开始返回</span><br><span class="line">//row_count一共返回的行数，也就是查询得到的数量</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">select * from students limit 5,10;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">select * from students limit 10 offset 5;</span><br></pre></td></tr></table></figure>

<p>limit在实际应用中常用于分页查询</p>
<p>举个例子</p>
<p>现在我有一个article表，想要做到文章分页展示的功能，每一页展示10篇文章</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//表结构如下</span><br><span class="line"></span><br><span class="line">CREATE TABLE article (</span><br><span class="line">id int(11) not null auto_increment,</span><br><span class="line">title varchar(255) not null,</span><br><span class="line">content text,</span><br><span class="line">publish_time datetime not null,</span><br><span class="line">primary key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/这个时候调用方传来一个n，通常是Logic层往dao层传 伪代码如下</span><br><span class="line">select * from article order by</span><br><span class="line">publish_time desc limit ?,10 values (n*10);</span><br><span class="line"></span><br><span class="line">//这条SQL就能做到文章分页的功能，按照时间来分页</span><br><span class="line">//具体实践中可能没有这么简单，通常是热度、时间等等</span><br></pre></td></tr></table></figure>

<h2 id="深分页"><a href="#深分页" class="headerlink" title="深分页"></a>深分页</h2><p>查询结果集中的某个位置之后的记录，即查询结果集的偏移量很大的情况。这样需要扫描的数据量就很大，可能导致查询的性能变得很低下</p>
<p>如何避免深分页的问题</p>
<ul>
<li>使用更小的偏移量：比如将偏移量从10000降低到100</li>
<li>使用分页键</li>
<li>缓存结果集，在内存层面进行返回</li>
<li>分库分表，减少每个表的数据量大小</li>
</ul>
<h2 id="分页键"><a href="#分页键" class="headerlink" title="分页键"></a>分页键</h2><p>分页键(pagination key)是一种用于分页查询的技术，它可以帮助我们在大数据集合中快速定位到需要查询的数据段。分页键通常是一个<strong>唯一的标识符</strong>，可以表示查询结果集中的某一行。在使用分页键的时候，通过查询分页键来定位结果集的起始位置，从而避免了偏移量很大的情况，也就是避免了SQL深分页的情况。</p>
<p>举个例子，假设我们需要查询一个包含一百万行数据的用户表，并且我们需要查询第500001到第500100行的数据。如果用偏移量的方式进行查询，需要查询前5000000行数据才能获得我们需要的结果，这将导致查询性能非常低下。而使用分页键的方式，可以在查询时直接指定分页键的值，从而定位到结果集的起始位置，避免了大量的数据扫描。</p>
<p>使用分页键的时候，我们需要选择一个合适的字段作为分页键，并确保该字段具有唯一性。通常情况下，自增长主键或者时间戳字段都是比较好的选择，分页键适用于有序数据集的分页查询</p>
<p>下面有一个具体的栗子</p>
<p>假设我们有一个包含大量文章的表，每篇文章都有一个唯一编号id和发布时间publish_time两个字段。我们需要查询发布时间在2022年1月1日到2022年3月31日之间的文章，并按照发布时间进行排序，每页显示十篇文章，显示第六页的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.选择分页键：根据查询条件，我们选择publish_time作为分页键</span><br><span class="line"></span><br><span class="line">2.查询第五页的最后一篇文章的发布时间</span><br><span class="line">我们得确定第五页最后一篇文章的发布时间</span><br><span class="line">select publish from articles </span><br><span class="line">where publish_time&gt;=&#x27;2022-01-01 00:00:00&#x27;</span><br><span class="line">and publish_time&lt;=&#x27;2022-03-31 23:59:59&#x27;</span><br><span class="line">order by pulish_time asc </span><br><span class="line">limit 1 offset 50;</span><br><span class="line"></span><br><span class="line">3.使用分页键查询数据</span><br><span class="line">select * FROM articels </span><br><span class="line">where publish_time&gt;=&#x27;分页键的值&#x27;</span><br><span class="line">and publish_time&lt;=&#x27;2022-03-31 23:59:59&#x27;</span><br><span class="line">order by publish_time asc </span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/" class="post-title-link" itemprop="url">深入理解异地多活</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-27 22:18:25 / 修改时间：22:22:51" itemprop="dateCreated datePublished" datetime="2023-03-27T22:18:25+08:00">2023-03-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统性能三指标"><a href="#系统性能三指标" class="headerlink" title="系统性能三指标"></a>系统性能三指标</h1><p>要想理解异地多活，我们需要从架构设计的原则说起</p>
<p>现如今，我们开发一个软件系统，对其要求越来越高，一个好的软件架构应该遵循以下3个原则：</p>
<ol>
<li>高性能</li>
<li>高可用</li>
<li>易扩展</li>
</ol>
<ul>
<li>高性能：系统拥有更大流量的处理能力，同时接口返回的速度应该尽可能的快。</li>
<li>易扩展：系统在迭代新功能的时候，能够以最小的代价去扩展，系统遇到流量压力的时候，可以在不改动代码的前提下去扩容系统。</li>
<li>高可用：通常由两个指标来衡量，分别是平均故障时间和故障恢复时间</li>
</ul>
<p>不同的软件，不同阶段的公司，产品开发的不同阶段，对这些指标的要求是不一样的：比如一个初创公司，这个时候用户、流量最重要，开发功能，让页面尽可能美观，做产品比其他指标更重要；当流量上来了之后，怎么尽可能缩短响应时间，让系统能处理的QPS更大，就成了至关重要的问题；当产品使用的人数足够多，影响力足够大，可用性的重要就凸现出来了，怎么保证系统尽可能稳定，不出问题，对于公司来说才是最重要的。</p>
<p>系统发生故障是不可避免的，尤其是规模越大的系统，互相之间的调用也更加复杂，对于硬件的要求也越高，从理论上来说发生问题的概率也越大。这些故障一般提现在3个方面：</p>
<ol>
<li>硬件故障：CPU 内存 磁盘 网卡 交换机 路由器</li>
<li>软件问题：代码BUG 版本迭代 线上故障等等</li>
<li>不可抗力：地震 水灾 火灾  战争</li>
</ol>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/1.png" alt="img"></p>
<p>我们通常用N个9来表示系统的可用性高不高，从数据上能看出来，越到后面系统可用性带来的平均受益是越小的，但是难度是指数级别上升的。我们平常写的小玩具和企业级的应用差别也无非是这几个方面：高并发、高性能、高可用。</p>
<p>这些风险随时都有可能发生，所以在面对故障的时候，系统能否以【最快】的速度恢复，就成了可用性的关键。</p>
<p>如何做到快速恢复呢？</p>
<p><strong>异地多活</strong>就是为了解决这个问题，而提出的高效解决方案</p>
<h1 id="单机房"><a href="#单机房" class="headerlink" title="单机房"></a>单机房</h1><h2 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h2><p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/2.png" alt="img"></p>
<p>客户端请求先进来，业务应用读写数据库，返回结果</p>
<p>这里的数据库是单机部署的，所以有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，这意味着所有数据就全部【丢失】了，这个损失是巨大的</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>我们可以对数据做备份，将数据库文件【定期】copy到另一台机器上，这样即使原机器丢失数据，依旧可以通过备份把数据【恢复】回来，以此保证数据安全</p>
<p>这个方案实施起来虽然比较简单，但存在两个问题</p>
<ol>
<li>恢复需要时间：业务需要先停机，在恢复数据，这段时间服务是不可用的，对于一个系统来说这显然不能忍受</li>
<li>数据不完整：因为是定期备份，数据肯定不是最新的，会有丢数据的风险。这里补充一句，其实现代系统想要做到数据实时强一致性，几乎是不可能的</li>
</ol>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/3.png" alt="img"></p>
<p>可以在另一台机器上，再部署一个数据库实例，成为这个原实例的副本，让两者保持【实时同步】，这里的实时同步要打上引号，因为两台机器有网络隔离，永远不可能真正的实时同步，比如当主库写一条数据，还没同步的时候就宕机了，这个时候从库就会有丢数据的可能。</p>
<p>我们一般把原实例称为主库（master），新实例称作从库（slave），这个方案的优点在于</p>
<ul>
<li>数据完整性高：主从副本实时同步，数据差异很小</li>
<li>抗故障能力提升：主库有任何异常，从库可以随时切换为主库，继续提供服务</li>
<li>读性能提示：从库可以直接用来读</li>
</ul>
<h2 id="主从-多机器"><a href="#主从-多机器" class="headerlink" title="主从+多机器"></a>主从+多机器</h2><p>同样的，业务应用也也可以在其他机器部署一份，避免单点。因为业务应用通常是【无状态】的，这里的无状态很好理解，业务代码的逻辑部分（除去数据库的部分），在什么机器上都能跑，且不会对机器造成持久化的影响，不像数据库一样存储数据，所以直接部署即可，非常简单。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/4.png" alt="img"></p>
<p>因为业务应用部署了多个，所以现在还需要一个接入层，来做请求的负载均衡，一般是用nginx或者是lvs，这样当一台机器宕机之后，另一台机器也可以【接管】所有流量，持续提供服务。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/5.png" alt="img"></p>
<h2 id="提高可用性的核心思想"><a href="#提高可用性的核心思想" class="headerlink" title="提高可用性的核心思想"></a>提高可用性的核心思想</h2><p>从这些方案可以看出，提升可用性的关键思路就是：<strong>冗余</strong></p>
<p>担心一个实例故障，那就部署多个实例；担心一个机器宕机，那就部署多台机器；担心一个数据库可能会崩然后丢数据，那就多整几个数据库；这种冗余的思想放在机房层面，就产生了同城灾备、同城双活等方案；放在城市层面，就产生了两地三中心、异地双活、异地多活等方案</p>
<p>以上说的方案还是有缺点的，因为应用虽然部署了多台机器，但是这些机器的分布情况，我们并没有去深究。</p>
<p>而一个机房有很多服务器，这些服务器通常会分布在一个个【机柜】上，如果使用的机器刚好在一个机柜，还是存在风险。</p>
<p>如果恰好链接这个机柜的交换机&#x2F;路由器发生故障，那么你的应用依旧有【不可用】的风险</p>
<p>哪怕是在不同机柜上，依旧会有风险，因为它们始终还是属于一个机房。</p>
<p>机房的故障率从现实角度来分析其实真的很低，建设一个机房的要求是很高的，地理位置、温湿度控制、备用电源等等。机房厂商会在各方面做好防护，但即使这样，还是有以下事故</p>
<ul>
<li>15年支付宝因为光纤被挖断，5小时无法访问支付宝</li>
<li>21年b站服务器着火，3小时无法访问</li>
<li>21年富途证券服务器断电，2小时无法访问</li>
</ul>
<p>可见，哪怕机房级别的防护已经做的足够好，但只要有概率出现问题，那现实情况就有可能发生。虽然概率很小，但一旦发生，就会造成重大损失。</p>
<p>像前文所说的一样，不同体量的系统，关注的重点是不一样的。小系统关注的重点是用户，这个阶段用户的规模、增长就是一切。在用户体量上来之后，会重点关注性能，优化接口响应时间，接口打开速度等等。这个阶段更多的是关注用户体验，而体量再大下去，可用性就会变得尤为重要。像微信、支付宝这种全民级别的应用，如果机房发生一次故障，那么影响和损失都是巨大的</p>
<p>我们该如何应对机房级别的故障呢？没错，还是冗余</p>
<h1 id="多机房"><a href="#多机房" class="headerlink" title="多机房"></a>多机房</h1><h2 id="同城灾备"><a href="#同城灾备" class="headerlink" title="同城灾备"></a>同城灾备</h2><p>简单起见，可以在同一个城市再搭建一个机房，原机房为A，新机房为B，这两个机房的网络用一条【专线】连通。</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/6.png" alt="img"></p>
<p>为了避免A机房故障导致数据丢失，所以我们需要把数据在B机房也做【定时备份】。这种方案，我们成为【冷备】。因为B机房只做备份，不提供服务，只有在A机房故障的时候才会弃用。</p>
<p>或者可以把AB之间的关系换成主从的关系，这样不仅能提高系统吞吐量，也能够更加保证数据的完整性</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/7.png" alt="img"></p>
<p>在这个方案的设想中，如果A机房真挂掉了，要想保证服务不中断，还需要做这些事情</p>
<ol>
<li>B机房所有从库升级成主库</li>
<li>在B机房部署应用，启动服务</li>
<li>部署接入层，配置转发规则</li>
<li>DNS指向B机房接入层，接入流量，业务恢复</li>
</ol>
<p>整个过程的每一步需要人为介入，且需要花费大量时间，回复之前整个服务还是不可用的，如果想要做到故障之后立即【切换】，就需要考虑下面这种架构</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/8.png" alt="img"></p>
<p>这样的话，A机房整个挂掉，我们只需要做两件事</p>
<ol>
<li>B机房所有从库提升为主库</li>
<li>DNS指向B机房接入层，接入流量，业务回复</li>
</ol>
<p>这种方案我们叫【热备】，热备相比于冷备的最大优点是随时可切换，不同点有需要多加一层应用层和接入层，同时数据库层面的定时备份变成了实时备份，这些都是需要额外开销的。我们把这两个方案统称为：同城灾备</p>
<p>同城灾备的最大优势在于，我们不用担心【机房】级别的故障了，一个机房发生风险，我们只需要把流量切换到另一个机房，当然这不一定会没有问题，比如冷备的问题是之前的备用系统没有经过流量的测试，不一定能扛得住；热备也是，瘫了一个主系统，那么备用系统的压力范围，也不一定能抗住。</p>
<h2 id="同城双活"><a href="#同城双活" class="headerlink" title="同城双活"></a>同城双活</h2><p>虽然有了应对机房故障的解决方案，但是有个问题是不能忽略的：A机房挂掉，全部流量切到B机房，B机房是否真的能如我们所愿，正常提供服务？</p>
<p>另外从成本的角度上看，我们新部署一个机房，需要购买很多硬件资源，花费成本也是非常高昂的，如果只是放在那里不去使用，是很浪费资源的一种表现。</p>
<p>因此我们需要让B机房也接入流量，实时提供服务</p>
<p>只需要把B机房的接入层IP地址，加入到dns服务中，这样B机房从上层就可以有流量进来了</p>
<p><img src="/2023/03/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/9.png" alt="img"></p>
<p>这里有一个新问题：B机房的存储都是从库，而从库默认都是不可写的，也就是说B机房是处理不了写请求的。这个问题就应该在业务应用层解决，需要区分读写分离，一般是通过中间件实现，写流量给A机房，读流量可以给两个机房</p>
<p>这种架构有什么问题呢？</p>
<h2 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h2><p>因为把两个机房当成一个整体来规划，如果是一个城市的话，当整个城市发生自然灾害的时候，例如地震、水灾，那么依旧可能有【全局覆没】的风险</p>
<p>这个时候就可以将备份机房放在另一个城市</p>
<p>两地三中心就是指两个城市，三个机房，其中2个机房在同一个城市，并且同时提供服务，第三个机房部署在异地，制作数据灾备。</p>
<p>这种架构方案，通常用在银行、金融、政企相关的项目中，问题还是启用后的服务，不确定能否如期工作。</p>
<p>所以想要真正抵御城市级别的故障，越来越多的互联网公司，开始实施【异地双活】</p>
<h2 id="异地双活"><a href="#异地双活" class="headerlink" title="异地双活"></a>异地双活</h2><p>主要问题是跨机房的延迟调用，当B地的应用去跨区域读写A地的存储，网络延迟就会让整个请求变得非常慢。而要解决这个问题，就必须在存储层做改造了。</p>
<p>B机房的存储不再是从库，而也要变为主库，同时两个机房的数据还要【互相同步】，无论客户端写哪一个机房，都要把数据同步到另一个机房。因为只有两个机房都拥有全量数据，才能支持任意切换机房，持续提供服务。MySQL本身是提供了双主架构的，支持双向数据复制，但平时用的不多。而且Redis、mongoDB等数据库是没有这个功能的，所以必须开发对应的【数据同步中间件】来实现双向同步的功能。</p>
<p>除了数据库这种有状态的软件之外，通常还会用到消息队列，例如rabbitMQ，kafka等，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房</p>
<p>业界开源出了很多数据同步中间件，例如阿里的canal、redisshake、mongoshake，可分别在两个机房同步MySQL、REDIS、MONGODB数据</p>
<p>这样的话有一个新的问题，两个机房都可以写，如果操作的是同一条数据，就很容易发生竞态的问题</p>
<p>分别有两个方案</p>
<ol>
<li>消息同步中间件要有自动解决数据的能力，区分出操作的先后顺序</li>
<li>从源头避免数据冲突的发生</li>
</ol>
<p>一般都是采用第二种方案：在最上层接入流量的时候，就不要让冲突的情况发生。</p>
<p>具体来讲就是将用户区分开，部分用户请求固定达到北京机房，其他用户请求固定打到上海机房。进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免【跨机房】。</p>
<p>这时候需要在接入层之上，再部署一个路由层，自己配置路由规则，把用户分流到不同的机房内。</p>
<p>一般来说有三种方式</p>
<ul>
<li>按业务类型分片，比如某个子域的请求固定全打在某个机房</li>
<li>直接哈希分片，先对请求进行哈希，再对机房的数量进行取模，这样可以保证流量均匀分布到某个机房，但是对于某些请求来说可能速度会慢，比如一个新疆的请求，打到了广州机房，网络延迟就会比打在西安机房大</li>
<li>按地理位置分片，请求只会打在距离自己最近的机房，处理请求的速度快，但是流量不均匀</li>
</ul>
<h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><p>把异地双活的思想推到多个城市，部署多个机房</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/" class="post-title-link" itemprop="url">我的本科前半生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-04 23:33:56 / 修改时间：23:48:31" itemprop="dateCreated datePublished" datetime="2023-03-04T23:33:56+08:00">2023-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是一个很喜欢用文字记录生活与想法的人，但是由于文字功底太弱，这些文字大多都躺在我的备忘录和废纸篓里。<br>      昨天看到了一个我很尊敬的学长写的一篇博文，深有所感。于是想写一些东西，记录一下大学这两年的一些经历，感悟和想法。部分内容摘自<a target="_blank" rel="noopener" href="http://www.cbb777.fun/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">实习求职总结</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cbb777.fun/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/">我的本科前半生</a></p>
<h1 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h1><p>20年9月16日，我独自坐上了从景德镇到南昌的动车，在体验过人生的第一次地铁和第一次飞机之后，在晚上十一点抵达了重庆。当时订的酒店在机场附近有一个总店一个分店，很不幸，我订的是总店但是不小心跑到分店去了。当时下着淅淅沥沥的小雨，我背着我的电脑包和双肩包走在凌晨的大街上，忽然觉得有些冷，那晚我把QQ签名改成了“希望生活别把我揍的太惨”。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/1.png" alt="image.png"><br>        进入大学后，我并没有选择松懈。<strong>我觉得人就是这样，越长大要承受的东西只会越来越多，万万没有变轻松的道理，中学比小学难熬，大学比中学难熬，进了社会比在学校难熬。</strong>我选择了在报道的第二天就一头扎进了图书馆，并在一个礼拜内速通了《高等数学上》及《线性代数》的大部分内容。开学之后没多久就放国庆了，但是国庆我也没有闲着，在之后的几个礼拜我又陆陆续续的把《C语言程序设计》学完了，当时真的非常幼稚，一有问题就在群里问，一有看不懂的代码就直接打包让当时的C语言志愿者帮忙看，完全不知道这是一种多么不负责任的行为，现在想想真的是愧怍万分。<br>        当时其实完全没有思考过自己到底想在大学里面干什么事情，在毕业的时候成为什么样的人，只顾着努力学东西。我只是把高中的那一套东西复用在大学里了，打算成为班里面的尖子，然后争取保研，但是我真的需要一个硕士学位吗？<br>        <strong>这何尝不是一种懒惰呢？还没有确定明确的目标就慌不择路的随便选条路出发，现在回头看看只觉这是在用战术上的勤奋来掩盖战略上的懒惰罢了。</strong><br>        大概是十一月初，我大学生活最重要的一个转折点来了。我去参加了当时我们学院的优秀就业生宣讲，第一个宣讲人是胡仓学长，也是一个很厉害很厉害的学长，在听完他的经历之后我花了一下午仔细思考了之后的规划，最终决定不读研了，本科毕业直接就业。这个决定其实并没有得到家人和朋友的支持，但我并没有动摇我的想法，人生总得自己去体验嘛。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/2.png" alt="image.png"><br>        之后我就很少去上课了，因为我觉得那些课程真的很浪费时间，大部分课程都是通识课，对就业可以说是毫无帮助，开设的少部分专业课，老师只是在念年纪比我都大的PPT，一节课一个半小时，我想如果自学的话也许花不了二十分钟就能把一节课的内容给学完。<br>        大一也没有确定好方向，同时也缺乏学习的方法论，基本上ACM、CTF、安全、后端、前端，这些方向我都尝试过，当时很多开发环境我都装不上，经常是一个环境装好几个小时，最后还是不了了之；除此之外刷了一些算法题也并没有体现出来效果。这对一个刚接触技术的小白来说打击太大了。加上当时其实对写代码根本说不上有什么兴趣，我很快就慢慢对写代码这件事情丧失了动力，但我又决定了本科毕业就业，于是乎我开始选择逃避现实了，几乎每天都窝在寝室里，不去上课也不做正事，每天看看小说刷视频打游戏。<strong>一边因为迷茫而焦虑，同时又缺乏自驱力和行动力，无法走出自己的舒适圈，我想这是很多大学生的问题。</strong></p>
<h1 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h1><p><strong>我是一个很难因为自己而开心起来的人，我直到现在都没有找到真正能让我很开心的事情，我总觉得我存在的意义是为了周围的人，为了我的家人、伴侣和朋友。如果说取悦自己是一门课程的话，那我一定没有及格。</strong><br>        其实到现在我都不能理解为什么有人的开心能来的这么容易，我的好哥们会因为吃到好吃的而觉得开心，他可以为了吃专门跑出去一趟，我长这么大似乎都没有很喜欢很喜欢吃的东西，大部分食物都只是用来饱腹而已。<br>        这可能也和多巴胺能有关系，有的人就是很容易觉得幸福和满足，不需要出人头地，平平淡淡的生活已经能够让他们很开心很开心了。而有的人多巴胺能很强，对自己的现状很容易产生一种不满足的心理，这种人更容易取得一点成就，但是这一定就是好事吗？我并不觉得这种世俗意义上的成功和幸福感是有正相关性的。之前我一直希望我家的小孩能够好好读书，出人头地，大有作为；但现在我完全不这么想了，现在的小孩能活的开心的太少了，不需要有什么成就，开开心心的过一生就很好。<br>        <strong>如何经营好自己的生活、享受当下是我觉得我急需学习的一项技能。好消息是现在我已经迈出了第一步，我开始学画画、摄影、骑行、读书、分享自己的生活。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/3.png" alt="AB205C830C36C9F4AB42E05364A29BBA.jpg"><br>        就像中学一样，我是因为不想让家人过于担心我的成绩才开始努力学习，最终完成逆袭的。在大二开始之前的那个暑假我认识了当时的爱人，因为恋爱的原因，我觉得自己不能再继续颓废下去了，当时刚好极客勤奋蜂工作室开启了Go学员的培训，为了通过工作室的考核，我开始把大一学过的东西慢慢捡起来，然后每天把大量的时间丢在写代码，学技术上面。<strong>不知道是不是我的性格如此，不管是什么东西，只要我花了足够多的时间，我就会慢慢的不排斥这件事甚至喜欢上它。</strong>每做完一个嘉文学长设置的project我都会更热爱代码一分，每划掉每日to-do list中的一项我的成就感就会多一分，在成就感和满足感积累之中，我慢慢的开始喜欢上技术了。我想也许就是这样吧，在大学我也读过几本心理学的书籍，<strong>满足感、成就感、被需要感是做某些事情的最佳动力了，同时，一个最可怜的人也一定不是缺少财富、权利、地位，而一定是不被需要。</strong><br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/4.png" alt="image.png"></p>
<p><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/5.png" alt="img"></p>
<p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，因为是第一次面试，我的印象真的非常深刻，问的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。<br>        之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在专业知识上被认可了，然后当天就去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。当天主要和峰哥、源哥聊的比较多，这也是我第一次了解创业相关的东西，比如融资是怎么一回事。<br>        之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装。<br>        差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，那边的环境是真的很好，呆着就容易让人心情愉悦，我慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/6.png" alt="56E6CD019183D099581FB095CF187A7C.jpg"><br>        源哥曾经说过这么一段话，我深以为然。<br>        “<strong>其实编程真的不是一件很难的事情，甚至是一个比较有意思的事情。只是大部分人还在学的阶段就放弃了，这个阶段他们只能抄别人的代码，自己写不出来东西，一旦自己能创造东西就能感受到编程的快乐了。</strong>”<br>        除了工程上的收获之外，我还认识了很多很厉害的大佬，基本上食铁兽成员的专业能力已经是我校一级梯队水准了，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来他思考的方面特别多。而且他知识的广度也很强，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐、洋哥，也都是很优秀的人，就不一一说了，食铁兽的氛围是真的挺好的，大家都是学生，没有那种领导的感觉，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。<br>        差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，也是我在校园最痛苦的一段时间，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，需要吃褪黑素才睡得着，不然脑子会一直处于活跃状态，明明身体很困，但是意识非常非常清晰。差不多准备了两个礼拜之后就开始投递简历了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，当时真的非常焦虑，觉得自己是不是要找不到工作了。最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是挂掉了，最后拿了一个小厂的offer但是不太想去。<br>    没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功，那段时间我对于linux和shell的熟悉程度也在直线上升。同时也和我校的研究生学长进行了交流和接触，更坚定了我不读研的想法。</p>
<p>“学长你学的什么方向啊？”<br>“开发吧，JAVA学了一半，没完全学完”<br>“那你发了paper吗？”<br>“还没有，还在写”<br>“打算毕业之后就业还是接着深造啊？”<br>“就业，读不下去了，读研都已经觉得很痛苦了。”<br>“读研究生有补贴吗？”<br>“一个月800”</p>
<h1 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h1><p>在大三入学后我又开始了新一轮的投递和面试，在开学的一周内拿了两家公司的offer，最后选择了去通明智云实习，这是一家搞负载均衡的公司，我们组负责开发负载均衡设备的纳管平台。<br>        那是第一次出远门实习，在此要感谢我的辅导员——林义钧老师，他是一位真正有师德，替学生考虑的老师，替我解决了学校里的很多麻烦，在大部分院都卡学生外出实习、完全不考虑当今就业市场学生可能毕业即失业、只顾学生就业率、升学率的情况下，林义钧老师仍然支持我实习，并替我解决了请假审批的问题。<br>        在通明智云我学到了很多东西，这是我第一次接触到生产级别的项目。我的leader韩哥是一个非常好的领导，并没有因为我是实习生就给我分配边角任务，而是真正有让我积极参与项目、融入到整个集体里面来，同时他也会让每个人不只负责一个模块，而是定期更换模块，让所有人对项目都有多方位的理解，也能真的学到技术。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/7.png" alt="689294415A37CFD7521DF177B8FA68A9.jpg"><br>        一开始主要负责部署相关的工作，负责和用户对接，能被leader信任，真的去做事情对我来说真的是一件挺有意义的事情。后面主要负责Prometheus相关的开发工作，但是没深入多久就和我当时的爱人分手了，后面整个人的状态其实都不太好，也没有多少产出，也确实是一件挺遗憾的事情。<br>        公司里还有来自北邮、北林的实习生，该说不说，长得都很帅。在之前我没觉得重邮本学历有多低，在实习之后发现好像确实有点低了。大家一起玩ranging loop、爬长城是真的挺开心的，长这么大第一次碰到除了LOL之外戳我的游戏，我之前一直以为自己不爱玩游戏呢。<br>        组里面的同事也很友好：说话很好笑很热心的美美、对技术很有追求的建国、像大哥哥一样很温暖的恩清、很腼腆的PM若培、喜欢玩摩托的士亮等等。还记得我理解不了需求、写不来mongo的查询语句、搞不懂prometheus实现原理、部署出问题的时候基本都是问的美美、建国和恩清，谢谢他们愿意花时间替我来擦屁股。总的来说大家都很好，氛围很温暖，下了班大家也会去地铁口那边一起吃饭，平常住在一栋楼里面交流也多。真的是一段很难忘也很有意义的经历，不仅仅是技术方面成长了，连带着待人接物、生活技能方面也学会了不少东西。<br>        现在我加入了百度APP业务中台部门，虽然呆的时间还不久，但是也能够感觉出来氛围挺好的，我的mentor宇哥和leader学明哥相处起来都给人一种很舒服的感觉，并且也是真的希望我能够学到东西，在我反应了我更想往Go方面去靠的时候，他们立马给我确定了之后的任务方向。百度给我的感觉是新人培养制度真的很不错，有很详细的培养方案，能够帮助实习生快速融入团队，同时整个部门的效率也非常高，不会在不该浪费时间的地方浪费时间，组里还有来自北大硕、北航硕的实习生，真的都是一群很优秀很优秀的人。<br><img src="/2023/03/04/%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%89%8D%E5%8D%8A%E7%94%9F/8.png" alt="9CE5E3FDD31967D5D0140BB2F68751A9.jpg"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉自己真的很幸运，这么多年都没有碰到过坏人。从入学认识的室友、导员，到后面认识的学长学姐：胡仓学长、宋扬学长、彩嵘学长、文炀学长、嘉文学长，再到食铁兽认识的小伙伴：源哥、峰哥、婧姐、洋哥，再到通明智云的同事和leader，还有现在的mentor、同事和leader，大家都是很好很好的人，相处起来都非常舒服，感谢所有遇见。<br>        大三还没结束，要做的事情还有很多。回头看看其实比起刚入学那一会，我已经成长不少了，也学会了一些道理。也培养了一些比较好的习惯，比如我上大学前完全想不到我现在在假期也会学习、会定期阅读和运动、会主动走出舒适区去学一些我觉得我应该会的技能。</p>
<p>当然大学里也有一些不好的经历，甚至有些事情我到现在也没有想明白原因，不明白自己为什么要被这么对待。虽然不理解，但是也只能试着接受。</p>
<p>希望我能过好大学的最后一年零几个月的生活，收拾行囊，再度出发吧。也希望我能一直热爱编程，热爱我的事业。我几乎不在社交媒体上发编程相关的东西，一是觉得我还是个noob，需要学习的东西还有很多；二是不爱给自己打上程序员的这个tag，不想给自己设限。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/MySQL%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%8F%8A%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">MySQL主键相关的一些思考及方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-02 23:10:48 / 修改时间：23:12:44" itemprop="dateCreated datePublished" datetime="2023-03-02T23:10:48+08:00">2023-03-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL创建表的时候可以不设置主键吗？"><a href="#MySQL创建表的时候可以不设置主键吗？" class="headerlink" title="MySQL创建表的时候可以不设置主键吗？"></a>MySQL创建表的时候可以不设置主键吗？</h3><p>MySQL创建表的时候是可以不主动设置主键的，但是表是一定需要一个主键的，MySQL会主动将第一个不为null的唯一索引设置为主键</p>
<h3 id="为什么MySQL推荐使用自增id作为主键？"><a href="#为什么MySQL推荐使用自增id作为主键？" class="headerlink" title="为什么MySQL推荐使用自增id作为主键？"></a>为什么MySQL推荐使用自增id作为主键？</h3><p>mysql官方推荐不要使用uuid或者不连续不重复的雪花作为主键，而是使用连续自增的主键id</p>
<p><strong>使用自增id的内部结构</strong></p>
<p>自增id的值是顺序的，所以innodb在索引B+树的叶子节点层面可以直接把每一条记录都存储在上一条记录的后面，当达到页面的最大填充因子的时候（页面容量已经满了）下一条记录就会写入新的页中，数据按照这种顺序的方式进行填充，主键页就会以近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费</p>
<p>新插入的行一定会在原有的最大数据行下一行，MySQL定位和寻址非常快，不会因为计算而做出额外的消耗，</p>
<p>并且能够减少页分裂和碎片的产生</p>
<p>页分裂：保证后一个数据页的所有行主键值比前一个数据页的主键值大，所以当ID不为自增的主键的时候，就会导致后一个页的所有行并不一定比前一个数据页的行的id大。这时就会触发页分裂的逻辑，对两个页之间的数据进行调整，甚至会涉及到多个数据页，导致性能降低</p>
<h3 id="使用自增id的缺点"><a href="#使用自增id的缺点" class="headerlink" title="使用自增id的缺点"></a>使用自增id的缺点</h3><ol>
<li>别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你业务的增长信息，从而分析出经营情况</li>
<li>对于高并发的负载，innodb在按照主键进行插入的时候会造成明显的锁争用，auto_increment锁机制会造成自增锁的争夺，有一定的性能损失</li>
</ol>
<h3 id="为什么分布式系统不用自增id，而是要用雪花算法生成id"><a href="#为什么分布式系统不用自增id，而是要用雪花算法生成id" class="headerlink" title="为什么分布式系统不用自增id，而是要用雪花算法生成id"></a>为什么分布式系统不用自增id，而是要用雪花算法生成id</h3><p>分布式id创建的业务需求</p>
<ol>
<li>全局唯一</li>
<li>趋势递增 innodb引擎的叶子结点是有序的双向链表，趋势递增可以增加性能，不会打乱树的结构</li>
<li>信息安全</li>
<li>最好包含时间戳</li>
</ol>
<p>为什么自增id不适合分布式系统？</p>
<p>当数据庞大的时候，在数据库分库分表之后，数据库自增id不能满足唯一id来表示数据；因为每个表都按照自己的节奏自增，会造成id冲突，从而无法满足需求</p>
<h3 id="使用auto-increment实现廉价的分布式唯一主键"><a href="#使用auto-increment实现廉价的分布式唯一主键" class="headerlink" title="使用auto_increment实现廉价的分布式唯一主键"></a>使用auto_increment实现廉价的分布式唯一主键</h3><p>flickr有类似的方案，构建是一个专用的数据库服务器，上面只有一个数据库，在数据库里面有用于32位id和64位id的id表，id是auto自增的，所有数据库生成id都会向这个服务器发请求，然后服务器分发id下去，也能达到一种分布式唯一主键的效果</p>
<p>类似于session-redis的思想，把所有的sessionid都存在redis里面，所有的服务器实例在比较cookie的时候就先去redis里面比较，这样就能避免因为负载均衡导致的cookie失效问题</p>
<p>当然这个廉价的做法显然是有很大问题的</p>
<ol>
<li>并发量很小，因为只有一台服务器</li>
<li>增加开销，并且整个请求流程变慢，因为需要向服务器发请求，并且是在硬盘层面进行操作的</li>
<li>flickr服务器成了整个系统的瓶颈和隐患，如果服务器宕机整个系统直接崩掉了</li>
</ol>
<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>是twitter开源的分布式id生成算法，结果是一个64位的longint类型，核心思想是用41位来作为时间戳，10位来作为机器的id,12位作为毫秒内的流水号（意味着每个节点可以在每毫秒生成4096个id），最后还有一个符号为永远为0 </p>
<p><strong>优点</strong></p>
<ul>
<li>完全在内存生成，高性能高可用</li>
<li>容量大，每秒可以生成几百万id</li>
<li>趋势递增，插入数据库索引树的时候，性能比较高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>依赖系统时钟的一致性，如果某台机器的系统时钟回拨，有可能造成id冲突</li>
<li>多台机器的ID只能保证趋势增加，即每一台机器都能保证这台机器生成的ID是在增加的，但是多台机器并不一定绝对递增</li>
<li>41位时间戳只能保证69年无重复ID</li>
<li>因为是64位的ID，在传递给前端的时候需要用字符串的类型进行传递，因为js的number类型最大只支持53位</li>
</ul>
<h3 id="其他分布式ID方案"><a href="#其他分布式ID方案" class="headerlink" title="其他分布式ID方案"></a>其他分布式ID方案</h3><ul>
<li>UUID:JAVA自带的API，生成一个唯一性的字符串，不能保证有序递增</li>
<li>UidGenerator:百度开源的分布式ID生成器，基于雪花算法</li>
<li>Leaf:美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但是需要依赖关系数据库、Zookeeper等中间件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">中台是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-01 08:28:04 / 修改时间：08:28:51" itemprop="dateCreated datePublished" datetime="2023-03-01T08:28:04+08:00">2023-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中台是一个非常宽泛的概念，可以是技术平台，比如框架、devops平台、容器云之类的，也可以是业务平台，像用户中心、订单中心、各种微服务集散。</p>
<h3 id="为什么需要中台？"><a href="#为什么需要中台？" class="headerlink" title="为什么需要中台？"></a>为什么需要中台？</h3><p>中台的产生可能是高层的战略设计，也可能是公司不断膨胀而暴露出来的种种问题需要被解决。</p>
<p>中台一开始诞生于16年阿里提出的“大中台，小前台”概念，中台的价值是以快速响应需求为依切，中台并不是一开始就有的，而是基于“前台+后台”的架构发展演变的</p>
<p>前台：系统的前端平台，是直接与终端用户进行交互的应用层，比如日常使用的app,h5（html5 通常用来写移动端的前端和web的前端）,pc端都是属于前台</p>
<p>后台：后台是指系统的后端平台，终端用户无法感知，提供后端服务</p>
<p>因为用户的需求是会高速变化的，而用户需求的变化决定了前台系统需要快速迭代响应用户需求，而前端的变化又需要后端的变化来进行支撑，这就对后台的快速应变提出了要求，而后台的核心目的并不是服务于前台，而是提升后端数据的安全及系统的管理效率</p>
<p>于是就产生了“前端为了用户需求，期望系统不断的快速迭代”与“后段为了数据安全与系统稳定，期望系统趋于稳定”的矛盾局面，为了解决这一矛盾，架构师们创造性的提出了“中台”这一概念，核心就是将后台的逻辑层进行拆离，形成前端（应用层）-中台（逻辑层）-后台（数据层）的产品架构，在这一架构下，当前端需求出现时，中台能够快速的进行响应，从而提升了研发效率，降低了创新成本</p>
<p>阿里中台战略最早从业务中台和数据中台建设开始，采用了双中台的建设模式，到后来发展出了移动中台，技术中台和研发中台等等。</p>
<p><img src="/2023/03/01/%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/1677551872346-10e243df-5756-457d-ba84-cfa2585f525c.png" alt="img"></p>
<h3 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h3><p>一般是指支持企业线上核心业务的中台，承载了核心业务能力，实现企业级业务能力复用和各业务板块之间的联通和协同</p>
<h3 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h3><p>与业务中台相辅相成，共同支持前台一线业务，大部分数据来源于业务中台，经过数据建模和数据分析等操作之后，将加工后的数据返回业务中台为前台应用提供服务，或者直接以数据类应用的方式向前台应用提供api数据服务，一般包括数据采集、数据生成、数据治理、数据应用以及数据仓库或大数据等技术应用</p>
<h3 id="技术中台"><a href="#技术中台" class="headerlink" title="技术中台"></a>技术中台</h3><p>业务中台落地的时候需要很多的技术组建来支撑，这些不同技术领域的技术组建就组成了技术中台。比如一些业务关键技术的组件</p>
<ul>
<li>api网关</li>
<li>开发框架</li>
<li>微服务治理</li>
<li>分布式数据库</li>
<li>数据处理组件</li>
</ul>
<p> <strong>api网关</strong></p>
<p>前后端分离，通过网关实现前后端集成，api网关主要包括：鉴权、降级限流、流量分析、负载均衡、服务路由和访问日志等功能。api网关可以帮助用户方便地管理微服务api接口，实现安全的前后端分离，实现高效的系统集成和精细的服务监控</p>
<p><strong>开发框架</strong></p>
<p>开发框架主要包括前端开发和后端微服务开发框架，支持代码自动生成，本地调试和依赖管理等功能</p>
<p><strong>微服务治理</strong></p>
<p>服务治理是在为服务的运行过程中，针对微服务的运行状况采取的动态治理策略，如服务注册、发现、限流、 熔断和降级等等，以保障微服务能够持续稳定的运行</p>
<p>治理主要应用于微服务运行中的状态监控、微服务运行异常时的治理策略配置等场景，保障微服务在常见异常场景下的自恢复能力</p>
<p><strong>分布式数据库</strong></p>
<p>分布式数据库一般都具有较强的数据线性拓展能力，它们大多采用数据多副本机制实现数据库高可用，具有可拓展和低成本等技术优势，一般分为三类：交易型、分析型、交易分析混合型</p>
<ul>
<li>交易型：用于解决交易类业务的数据库计算能力，支持数据分库、分片、数据多副本，具有高可用的特性，提供统一的运维界面，具备高性能的交易型业务处理分析能力。</li>
<li>分析型：通过横向扩展能力和并行计算能力，提高数据整体计算能力和吞吐量，支持海量数据的分析</li>
<li>混合型：通过资源隔离、分时和数据多副本等技术手段，基于不同的数据存储、访问性能和容量等需求，使用不同的存储介质和分布式计算存储，同时满足业务交易和分析需求</li>
</ul>
<p><strong>数据处理组件</strong></p>
<p>为了提高应用性能和业务的承载能力，降低微服务的耦合度，实现分布式架构下的分布式事务等要求，技术中台还有很多数据处理相关的基础技术组件。如分布式缓存、搜索引擎、数据复制、消息中间件和分布式事务等技术组建</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生学习（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 12:45:05" itemprop="dateCreated datePublished" datetime="2023-02-26T12:45:05+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 22:43:12" itemprop="dateModified" datetime="2023-02-27T22:43:12+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC是一种现代化开源的RPC框架，由Google进行研发，能够运行于任何环境之中，最初由谷歌进行开发，它使用HTTP&#x2F;2作为传输协议。</p>
<p>在gRPC中，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，帮助你更容易创建分布式应用程序和服务。gRPC是基于定义一个服务，制定一个可以远程调用的带有参数和返回类型的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用，在客户端，有一个stub提供和服务端相同的方法</p>
<p><img src="/2023/02/26/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/1676256947622-90dcc6f3-615b-4154-a261-5a45a2beedbc.png" alt="img"></p>
<h3 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h3><p>gRPC可以帮助我们一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，也就是说gRPC解决了<strong>不同语言以及环境间通信的复杂性</strong>。使用<code>protocol buffer</code>还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之，使用gRPC能够帮助我们更容易编写跨语言的分布式代码</p>
<p>IDL（Interface description Language） 是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成</p>
<h3 id="使用gRPC进行开发的步骤"><a href="#使用gRPC进行开发的步骤" class="headerlink" title="使用gRPC进行开发的步骤"></a>使用gRPC进行开发的步骤</h3><p><strong>1.编写.proto文件定义服务</strong></p>
<p>默认情况下gRPC使用<code>protocol buffers</code>作为接口定义语言（IDL）来描述服务接口和有效负载消息的结构</p>
<p>在gRPC中可以定义四种类型的服务方法 	</p>
<p>普通rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>服务器流式rpc，其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，知道没有更多的消息，gRPC保证在单个RPC调用的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>客户端流式rpc，其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应，同样，gRPC保证单个RPC调用中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LostsOfGreetings(stream HelloRequest) returns(HelloResponse);</span><br></pre></td></tr></table></figure>

<p>双向流式rpc，其中双方使用读写流发送一系列消息，这两个流独立运行，因此客户端和服务器可以按照自己指定的顺序读写；例如，服务器可以等待接受所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc StreamGreetings(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p><strong>2.生成指定语言的代码（客户端一份、服务端一份）</strong></p>
<p>在<code>.proto</code>文件中定义好服务之后，gRPC提供了生成客户端和服务端代码的protocol buffers编译器插件。</p>
<p>我们使用这些插件可以根据需要生成<code>Java Go C++ Python</code>等语言的代码，我们通常会在客户端调用这些API，并且在服务器端实现对应的API</p>
<ul>
<li>在服务器端，服务器实现服务声明的方法，并运行一个gRPC服务器来处理客户端发来的调用请求。gRPC底层会对传入的请求进行编码，执行被调用的服务方法，并对服务响应进行编码</li>
<li>在客户端，客户端有一个称为存根(stub)的本地对象，它实现了与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的<code>protocol buffers</code>消息类型中–gRPC在向服务器发送请求并返回服务器的<code>protocol buffers</code>响应之后进行处理</li>
</ul>
<p><strong>3.编写业务逻辑代码</strong></p>
<p>proto文件生成<code>pb.go</code>以及<code>grpc.pb.go</code>的命令</p>
<p>不指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>

<p>指定proto路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=xx --go_out=pb --go_opt=paths=source_relative --go-grpc_out=pb --go-grpc_opt=paths=source_relative xxx.proto</span><br></pre></td></tr></table></figure>



<h3 id="使用grpc实现一个简单的hello服务"><a href="#使用grpc实现一个简单的hello服务" class="headerlink" title="使用grpc实现一个简单的hello服务"></a>使用grpc实现一个简单的hello服务</h3><p><strong>Server</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer //当没有完全实现proto中的所有方法时依旧可以运行起来</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// gRPC通过.proto文件自动生成的SayHello方法  </span><br><span class="line">func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) &#123;</span><br><span class="line">	reply := &quot;hello&quot; + in.GetName()</span><br><span class="line">	return &amp;pb.HelloResponse&#123;Reply: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:8972&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to listen,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 注册服务</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	// 启动服务</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_server/pb&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//连接server 带加密连接</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:8972&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;grpc.Dial failed,err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	//创建客户端</span><br><span class="line">	c := proto.NewGreeterClient(conn)</span><br><span class="line">	//使用context进行控制，传入background和超时时间一秒钟</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	name := &quot;xiaocheng&quot;</span><br><span class="line">	resp, err := c.SayHello(ctx, &amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.SayHello failed, err:%v&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 拿到RPC响应</span><br><span class="line">	log.Printf(&quot;resp:%v&quot;, resp.GetReply())</span><br><span class="line">&#125;</span><br><span class="line">// 应该是同一份proto文件</span><br><span class="line">syntax = &quot;proto3&quot;;  //版本声明</span><br><span class="line"></span><br><span class="line">option go_package=&quot;hello_client/proto&quot;;  // 项目中import导入生成go代码的模块</span><br><span class="line"></span><br><span class="line">package  pb;  //proto文件模块 必须与server端一致</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // 定义方法</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义消息</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;   //字段的序号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message  HelloResponse &#123;</span><br><span class="line">  string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用grpc实现一个简单的add服务"><a href="#使用grpc实现一个简单的add服务" class="headerlink" title="使用grpc实现一个简单的add服务"></a>使用grpc实现一个简单的add服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedAddMethodServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *server) Add(ctx context.Context, in *pb.AddRequest) (*pb.AddResponse, error) &#123;</span><br><span class="line">	reply := in.GetArgs1() + in.GetArgs2()</span><br><span class="line">	return &amp;pb.AddResponse&#123;Number: reply&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//启动服务</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, &quot;:9999&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;net listen failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterAddMethodServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	err = s.Serve(l)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to server,err:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>proto文件应该在客户端和服务端都有一份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">option go_package=&quot;server/pb&quot;;</span><br><span class="line">package pb;</span><br><span class="line"></span><br><span class="line">service AddMethod &#123;</span><br><span class="line">   rpc Add(AddRequest) returns (AddResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddRequest &#123;</span><br><span class="line">  int32 args1 =1;</span><br><span class="line">  int32 args2 =2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddResponse &#123;</span><br><span class="line">  int32 number =1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	conn, err := grpc.Dial(&quot;127.0.0.1:9999&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;grpc dail failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line">	c := pb.NewAddMethodClient(conn)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	var args1, args2 int32</span><br><span class="line">	args1 = 1</span><br><span class="line">	args2 = 2</span><br><span class="line">	resp, err := c.Add(ctx, &amp;pb.AddRequest&#123;Args1: args1, Args2: args2&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;c.Add failed,err:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(&quot;Add Response:&quot;, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protobuf语法"><a href="#protobuf语法" class="headerlink" title="protobuf语法"></a>protobuf语法</h3><p><strong>protobuf为什么体积小、解析快</strong></p>
<p>protobuf是google提出的数据交换格式，同一条消息数据，使用Protobuf序列化之后占用空间是json的1&#x2F;10，但是性能却是几十倍</p>
<p>原因</p>
<ul>
<li>编解码大多采用位运算，比JSON&#x2F;XML的字符匹配效率更高</li>
<li>pb定义了varint类型，使用变长编码压缩数值类型。值越小的数字，使用的字节数就越少</li>
<li>采用Tag-value类型，没有冗余字符</li>
</ul>
<p><strong>定义一个消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">	string query =1;</span><br><span class="line">	int32 page_number=2; </span><br><span class="line">&#125;</span><br><span class="line">//文件的第一行指定使用proto3语法，如果不这么写</span><br><span class="line">//pb的编译器默认使用proto2</span><br><span class="line"></span><br><span class="line">//SearchRequest定义了一个消息，使用了两个字段</span><br><span class="line">//每个字段需要定义类型 名字 和编号</span><br></pre></td></tr></table></figure>



<p><strong>字段编号</strong></p>
<p>消息定义中的每个字段都要有一个唯一的编号，这些编号用来在消息二进制格式中标识字段，<strong>在消息类型使用后就不能更改</strong>。在范围1到15中的字段需要一个字节进行编码，而16-2047的字段采用两个字节。所以应该为经常使用的消息元素保留数字1到15的编号，也要为将来可能添加的经常使用的元素留出一些编号</p>
<p><strong>指定字段规则</strong></p>
<p>消息字段可以是下列字段之一</p>
<ul>
<li>singular：格式正确的消息可以有这个字段的0个或者一个，默认使用singular字段</li>
<li>repeated：该字段可以在格式正确的消息中重复任意次数（包括0次），重复值的顺序将被保留</li>
<li>optional：该字段在传递的时候可选也可不选</li>
</ul>
<p><strong>保留字段</strong></p>
<p>如果你通过完全删除字段或者将其注释来<strong>更新消息类型，</strong>那么未来的用户在对该类型进行自己的更新的时候就可以重用字段号，如果其他人以后加载旧版本的相同<code>.proto</code>文件，这可能就会导致严重的问题，比如数据损坏、隐私漏洞等等。</p>
<p>解决方法是指定已经删除的字段的字段编号，如果将来有用户尝试使用这些字段标识符，protocol buffer编译器将发出提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">reserved 2,15,9 to 11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>值类型</strong></p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java&#x2F;Kotlin Type[1]</th>
<th>Python Type[3]</th>
<th>Go Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint32代替。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>int64</td>
<td>使用可变长度编码。编码负数效率低下——如果你的字段可能有负值，则使用 sint64代替。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>uint32</td>
<td>使用变长编码。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>使用变长编码。</td>
<td>uint64</td>
<td>long[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>sint32</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int32更有效地编码负数。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>使用可变长度编码。带符号的 int 值。这些编码比普通的 int64更有效地编码负数。</td>
<td>int64</td>
<td>long</td>
<td>int&#x2F;long[4]</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是四个字节。如果值经常大于228，则比 uint32更有效率。</td>
<td>uint32</td>
<td>int[2]</td>
<td>int&#x2F;long[4]</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是8字节。如果值经常大于256，则比 uint64更有效率。</td>
<td>uint64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是四个字节。</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是八个字节。</td>
<td>int64</td>
<td>integer&#x2F;string[6]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>字符串必须始终包含 UTF-8编码的或7位 ASCII 文本，且不能长于232。</td>
<td>string</td>
<td>String</td>
<td>str&#x2F;unicode[5]</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>可以包含任何不超过232字节的任意字节序列。</td>
<td>string</td>
<td>ByteString</td>
<td>str (Python 2) bytes (Python 3)</td>
<td>[]byte</td>
<td>string</td>
</tr>
</tbody></table>
<p><strong>枚举</strong></p>
<p>在定义消息类型的时候，可能希望其中的一个字段只能是预定义的值列表中的一个值。下面是一个栗子，Conrpus字段的值只能是其中的一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">string query = 1;</span><br><span class="line">  int32 page_number = 2;</span><br><span class="line">  int32 result_per_page = 3;</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = 4;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>嵌套消息类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated Result results = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  string url = 1;</span><br><span class="line">  string title = 2;</span><br><span class="line">  repeated string snippets = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Any</strong></p>
<p>Any类型允许你将消息作为嵌入类型使用，使用Any类型需要导入<code>google/protobuf/any.proto</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">  repeated google.protobuf.Any details = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>oneof</strong></p>
<p>如果你有一条包含多个字段的消息，并且同时最多设置其中的一个字段，那么可以通过oneof来实现并节省内存，可以通过<code>case()</code>或者<code>WihchOneOf()</code>来检查one  of 中的哪个值被设置（如果有）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">    string name = 4;</span><br><span class="line">    SubMessage sub_message = 9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> SampleMessage message;</span><br><span class="line">  message.set_name(&quot;name&quot;);</span><br><span class="line">  CHECK(message.has_name());</span><br><span class="line">  message.mutable_sub_message();   // Will clear name field.</span><br><span class="line">  CHECK(!message.has_name());</span><br></pre></td></tr></table></figure>

<p><strong>Maps</strong></p>
<p>如果想创建一个关联映射作为数据定义的一部分，可以使用这个map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<h3 id="protobuf实战"><a href="#protobuf实战" class="headerlink" title="protobuf实战"></a>protobuf实战</h3><p><strong>oneof字段</strong></p>
<p>oneof中的值只能选择其中的一个  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message NoticeReaderRequest &#123;</span><br><span class="line">  string msg=1;</span><br><span class="line">  oneof notice_way&#123;</span><br><span class="line">    string email=2;</span><br><span class="line">    string phone=3;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的服务端代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func oneofDemo() &#123;</span><br><span class="line">	req := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is chengxisheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Email&#123;</span><br><span class="line">			Email: &quot;xxx&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	req2 := &amp;book.NoticeReaderRequest&#123;</span><br><span class="line">		Msg: &quot;here is xishengcheng&quot;,</span><br><span class="line">		NoticeWay: &amp;book.NoticeReaderRequest_Phone&#123;</span><br><span class="line">			Phone: &quot;1008611&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">	switch v := req2.NoticeWay.(type) &#123;</span><br><span class="line">	case *book.NoticeReaderRequest_Email:</span><br><span class="line">		noticeWithEmail(v)</span><br><span class="line">	case *book.NoticeReaderRequest_Phone:</span><br><span class="line">		noticeWithPhone(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithEmail(in *book.NoticeReaderRequest_Email) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by email:%v\n&quot;, in.Email)</span><br><span class="line">&#125;</span><br><span class="line">func noticeWithPhone(in *book.NoticeReaderRequest_Phone) &#123;</span><br><span class="line">	fmt.Printf(&quot;notice reader by phone:%v\n&quot;, in.Phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里必须使用类型断言+switch case </span><br><span class="line">//来进行one of 字段的确认</span><br></pre></td></tr></table></figure>

<p><strong>wrapvalue类型</strong></p>
<p>首先让我们想一想Go中区分一个MySQL的int类型是默认值还是0值该怎么做？</p>
<p>其实就只有以下两种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">price sql.NullInt64</span><br><span class="line">price *int64</span><br><span class="line">//第一种方式是一个定义好的结构体 </span><br><span class="line">//里面有一个字段是 该结构体是否被赋值</span><br><span class="line">//第二种方式是直接用指针来做</span><br><span class="line">//对指针解引用，如果为0则赋值，如果为Nil则是默认值</span><br><span class="line">func wrapValueDemo() &#123;</span><br><span class="line">	// client</span><br><span class="line">	 book:=book.Book&#123;</span><br><span class="line">		 Title: &quot;learning go language&quot;,</span><br><span class="line">		 Price: &amp;wrapperspb.Int64Value&#123;Value: 600&#125;,</span><br><span class="line">		 Memo: &amp;wrapperspb.StringValue&#123;Value: &quot;学&quot;&#125;,</span><br><span class="line">	 &#125;</span><br><span class="line">	 // server </span><br><span class="line">	 if book.GetPrice()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetPrice().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">	 if book.GetMemo()==nil &#123;</span><br><span class="line">		 fmt.Println(&quot;is not assigned&quot;)</span><br><span class="line">	 &#125; else &#123;</span><br><span class="line">		 fmt.Println(book.GetMemo().GetValue())</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FieldMask类型</strong></p>
<p>当我们更新的时候，定义了很多字段，不可能全部进行全量更新Book的每个字段，因为通常操作只会更新1到2个字段。</p>
<p>当我们想知道更新操作涉及到的具体字段，就需要使用到filedmask类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // 操作人</span><br><span class="line">  string op =1;</span><br><span class="line">  // 要更新的书籍信息</span><br><span class="line">  Book book=2;</span><br><span class="line">  // 要更新的字段</span><br><span class="line">  google.protobuf.FieldMask update_mask=3;</span><br><span class="line">&#125;</span><br><span class="line">func fieldMaskDemo() &#123;</span><br><span class="line">	//client</span><br><span class="line">	paths := []string&#123;&quot;price&quot;&#125;</span><br><span class="line">	req := &amp;book.UpdateBookRequest&#123;</span><br><span class="line">		Op: &quot;chengxisheng&quot;,</span><br><span class="line">		Book: &amp;book.Book&#123;</span><br><span class="line">			Price: &amp;wrapperspb.Int64Value&#123;Value: 8800&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		UpdateMask: &amp;fieldmaskpb.FieldMask&#123;Paths: paths&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	mask, _ := fieldmask_utils.MaskFromProtoFieldMask(req.UpdateMask, generator.CamelCase)</span><br><span class="line">	var bookDst = make(map[string]interface&#123;&#125;)</span><br><span class="line">	fieldmask_utils.StructToMap(mask, book.UpdateBookRequest&#123;&#125;.Book, bookDst)</span><br><span class="line">	fmt.Printf(&quot;bookDst:%#v\n&quot;, bookDst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端流式RPC"><a href="#服务端流式RPC" class="headerlink" title="服务端流式RPC"></a>服务端流式RPC</h3><p>对应的proto（client和server）中添加一个流式方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);</span><br></pre></td></tr></table></figure>



<p>Server添加一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfReplies(in *pb.HelloRequest, stream pb.Greeter_LotsOfRepliesServer) error &#123;</span><br><span class="line">	words := []string&#123;</span><br><span class="line">		&quot;你好&quot;,</span><br><span class="line">		&quot;hello&quot;,</span><br><span class="line">		&quot;こんにちは&quot;,</span><br><span class="line">		&quot;안녕하세요&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	for _, word := range words &#123;</span><br><span class="line">		data := &amp;pb.HelloResponse&#123;</span><br><span class="line">			Reply: word + in.GetName(),</span><br><span class="line">		&#125;</span><br><span class="line">		// 使用Send方法发送多个数据 每当有一个data就send一次数据</span><br><span class="line">		if err := stream.Send(data); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端添加一个新的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func callLotsOfReplies(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)</span><br><span class="line">	defer cancel()</span><br><span class="line">	stream, err := c.LotsOfReplies(ctx, &amp;proto.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	for &#123;</span><br><span class="line">		//依次从流式响应中读取返回的响应数据</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;c.LotsOfReplies failed,err:%v&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;got reply: %q\n&quot;, res.GetReply())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端流式RPC"><a href="#客户端流式RPC" class="headerlink" title="客户端流式RPC"></a>客户端流式RPC</h3><p>在<code>hello.proto</code>中添加这么一个新的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在server端添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) LotsOfGreetings(stream pb.Greeter_LotsOfGreetingsServer) error &#123;</span><br><span class="line">   reply := &quot;你好:&quot;</span><br><span class="line">   for &#123;</span><br><span class="line">      //接受客户端发来的流式数据</span><br><span class="line">      res, err := stream.Recv()</span><br><span class="line">      if err == io.EOF &#123;</span><br><span class="line">         return stream.SendAndClose(&amp;pb.HelloResponse&#123;</span><br><span class="line">            Reply: reply,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         return err</span><br><span class="line">      &#125;</span><br><span class="line">      reply += res.GetName()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Client端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func runLotsOfGreeting(c proto.GreeterClient) &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	defer cancel()</span><br><span class="line">	// 客户端要流式的发送请求消息</span><br><span class="line">	stream, err := c.LotsOfGreetings(ctx)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;c.LotsOfGreetings failed,err:%v\n&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	names := []string&#123;&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;&#125;</span><br><span class="line">	for _, name := range names &#123;</span><br><span class="line">		stream.Send(&amp;proto.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">		time.Sleep(200 * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	//关闭流</span><br><span class="line">	res, err := stream.CloseAndRecv()</span><br><span class="line">	log.Printf(&quot;res:%v\n&quot;, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向流式RPC"><a href="#双向流式RPC" class="headerlink" title="双向流式RPC"></a>双向流式RPC</h3><p>在proto中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns(stream HelloResponse);</span><br></pre></td></tr></table></figure>

<p>在client中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在Server端中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (s *server) BidiHello(stream pb.Greeter_BidiHelloServer) error &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		//接受流式请求</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		reply := magic(in.GetName())</span><br><span class="line">		//返回流式响应</span><br><span class="line">		if err := stream.SendAndClose(&amp;pb.HelloResponse&#123;Reply: reply&#125;); err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// magic 一段价值连城的“人工智能”代码</span><br><span class="line">func magic(s string) string &#123;</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吗&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;吧&quot;, &quot;&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;你&quot;, &quot;我&quot;)</span><br><span class="line"></span><br><span class="line">	s = strings.ReplaceAll(s, &quot;？&quot;, &quot;!&quot;)</span><br><span class="line">	s = strings.ReplaceAll(s, &quot;?&quot;, &quot;!&quot;)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MetaData元数据"><a href="#MetaData元数据" class="headerlink" title="MetaData元数据"></a>MetaData元数据</h3><p>metadata是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用的是键值对列表 的形式，其中键是string类型，值通常是[]string类型，但也可以是二进制数据。gRPC中的metadata类似于我们在HTTP headers中的键值对，元数据可以包含认真token、请求标识和监控标签等等</p>
<p>metadata中的键是大小写不敏感的，不能以grpc-开头，并且二进制的简明必须以-bin结尾，元数据对gRPC本身是不可见的，通常在应用程序代码或者中间件中处理元数据，我们不需要再.proto中指定元数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MD map[string][]string</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Go微服务与云原生一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-24 12:07:13 / 修改时间：12:08:30" itemprop="dateCreated datePublished" datetime="2023-02-24T12:07:13+08:00">2023-02-24</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h3><p>用架构历史</p>
<p>1.单体架构 堆机子 高耦合 一改动就需要重新部署 而且编译时间很长，不容易拓展，不支持多语言技术栈 </p>
<p>2.分层架构 典型的有MVC和MSC架构 当访问量逐渐增大，单体架构扛不住了，把单体项目进行垂直划分，耦合还是很大，项目之间的接口多为数据同步，比如不同项目之间的数据库同步。 架构简单，成本低开发周期短，经过垂直拆分之后原来的单体项目不至于太大，每一层可以用不同的技术，但还是不易拓展和维护 </p>
<p>3.SOA面向服务架构 ：当垂直架构的应用越来越多，就会出现多个应用都依赖的业务组件，比如数据库，而且各个应用交互越来越频繁，此时就需要把部分通用的组件拆分独立处理，于是SOA面向服务架构诞生了，它带来了模块化开发、分布式拓展部署和服务接口定义等概念</p>
<p>实时SOA需要建立企业服务总线，外部应用通过总线调用服务，有以下特征：可从企业外部访问、随时可用、标准化的服务接口等</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/1.png" alt="img"></p>
<p>优点：</p>
<ul>
<li>已经具有微服务的影子了，将重复的功能抽离出来，提高开发效率</li>
<li>减少接口耦合</li>
</ul>
<p>SOA架构适用于大型软件服务企业对外提供服务的场景，并不适合一般的业务场景，其服务的定义、注册和调用都需要繁琐的配置，业务总线的吞吐量决定了整个系统的上限，因为整个系统都是通过总线进行任务分配的。并且业务总线也容易导致系统崩掉、影响性能。</p>
<p>4.微服务架构：</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/2.png" alt="img"></p>
<p>特点</p>
<p>1.服务层完全独立出来 并将服务层抽取为一个一个的微服务</p>
<p>2.微服务遵循单一原则</p>
<p>3.微服务之间采用RESTful等轻量协议通信</p>
<p>4.微服务一般用容器技术部署 运行在自己的独立进程中</p>
<p>微服务架构下服务的拆分粒度更细，有利于资源重复利用，提高开发效率，采用去中心化思想，更轻量级</p>
<p>缺点：如果服务实例过多，治理成本就会很大，不利于维护；服务之间相互依赖，可能形成复杂的依赖链条，往往单个服务异常，其他服务也会受到影响，出现服务雪崩效应。</p>
<p>微服务与SOA的区别：</p>
<p>微服务继承了SOA的众多优点和理念</p>
<p>SOA更适合与许多其他应用程序继承的大型复杂企业应用程序环境，小型的应用并不适合SOA，微服务则更适合于较小和良好的分割式web业务系统</p>
<p>微服务不再强调SOA架构中比较重要的ESB企业服务总线，而是通过轻量级通信机制相互沟通</p>
<p>SOA注重的是系统继承，而微服务关注的则是完全分离，SOA尝试采用中心化管理来确保各个应用能够协同运作，微服务则尝试部署新功能，快速有效地拓展开发团队，它着重于分散管理、代码再利用和自动化执行。</p>
<h3 id="微服务的优势和劣势"><a href="#微服务的优势和劣势" class="headerlink" title="微服务的优势和劣势"></a>微服务的优势和劣势</h3><p>微服务的优势</p>
<p>1.快：更注重CI&#x2F;CD 敏捷开发、持续交付</p>
<p>2.准：服务粒度小、服务质量精准可控</p>
<p>3.狠：适用于互联网时代、产品迭代周期更短</p>
<p>微服务的劣势</p>
<p>1.系统的复杂性</p>
<p>2.服务依赖管理</p>
<p>3.数据的一致性保障</p>
<p>4.测试更加艰难</p>
<p>5.对于DevOps等基础设施的高要求</p>
<h3 id="如何划分微服务界限"><a href="#如何划分微服务界限" class="headerlink" title="如何划分微服务界限"></a>如何划分微服务界限</h3><p>如何进行服务划分？</p>
<p>1.按照业务职能进行划分</p>
<p>由公司内部不同部门提供的只能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能</p>
<p>2.按照DDD的限界上下文划分</p>
<p>限界上下文是DDD中用来划分不同业务边界的元素</p>
<p>这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域</p>
<p>为了解决某种类型的业务问题，贴近领域只是，也就是业务</p>
<p>CQRS将系统中的操作划分为两类，即【命令】Command和【查询】Query</p>
<p>命令则是对会引起数据发生变化操作的总称，即我们常说的新增、更新、删除的这些操作，都是命令。</p>
<p>而查询则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查询数据。</p>
<p>CQRS的核心思想是将两类不同的操作进行分离，然后在两个独立的【服务】中实现。这里的服务一般指的是两个独立部署的应用，在某些特殊情况下，也可以部署在同一个应用内的不同接口上。 </p>
<h3 id="微服务的迭代"><a href="#微服务的迭代" class="headerlink" title="微服务的迭代"></a>微服务的迭代</h3><p>1.第一代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/3.png" alt="img"></p>
<p>2.第二代</p>
<p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/4.png" alt="img"></p>
<p>把那些服务监控、服务管理作为基础服务提供给我们的业务</p>
<p>架构分层</p>
<p> <img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/5.png" alt="img"></p>
<p>核心组件</p>
<ul>
<li>API网关</li>
<li>服务注册中心</li>
<li>配置中心</li>
<li>服务通信</li>
<li>服务治理</li>
<li>服务监控</li>
</ul>
<h2 id="net-x2F-rpc"><a href="#net-x2F-rpc" class="headerlink" title="net&#x2F;rpc"></a>net&#x2F;rpc</h2><h3 id="RPC出现的原因"><a href="#RPC出现的原因" class="headerlink" title="RPC出现的原因"></a>RPC出现的原因</h3><p>RPC需要解决三个问题</p>
<p>1.如何要确定要执行的函数？在本地调用中，函数主体通过函数指针函数指定，然后调用add函数，编译器你通过函数指针函数确定add函数在内存中的位置。但是在RPC中，调用不能通过函数指针完成，因为他们的内存地址可能完全不同。因此，调用方和被调用方都需要维护一个{fuction&lt;-&gt;ID}映射表，以确保调用正确的函数</p>
<p>2.如何表达参数？本地过程调用中传递的参数是通过堆栈结构实现的，但是RPC不能直接使用内存传递参数，因此参数或返回值需要在传输期间徐丽湖儿啊并转换成字节流，反之亦然</p>
<p>3.如何通过网络传输？函数的调用方和被调用方通常是通过网络连接的，也就是说 function ID和序列化字节流需要通过网络传输，因此，只要能够完成传输，调用方和被调用方就不受某个网络协议的限制。例如，一些RPC框架使用TCP协议，一些使用HTTP。</p>
<p>以往实现跨服务调用的时候，我们会采用restful api的方式，被调用方会对外提供一个HTTP接口，调用方按要求发起HTTP请求并接收API接口返回的响应数据。</p>
<p>本地调用，通过HTTP的API的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">//定义参数和响应  </span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(x, y int) int &#123;</span><br><span class="line">	return x + y</span><br><span class="line">&#125;</span><br><span class="line">// addHandler 解析参数+调用add+响应写回</span><br><span class="line">func addHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	// parse parameters</span><br><span class="line">	b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">	var param addParam</span><br><span class="line">	json.Unmarshal(b, &amp;param)</span><br><span class="line">	// use the add func</span><br><span class="line">	ret := add(param.X, param.Y)</span><br><span class="line">	// return the response</span><br><span class="line">	respBytes, _ := json.Marshal(addResult&#123;Code: 0, Data: ret&#125;)</span><br><span class="line">	w.Write(respBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/add&quot;, addHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(&quot;:9090&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">type addParam struct &#123;</span><br><span class="line">	X int `json:&quot;x&quot;`</span><br><span class="line">	Y int `json:&quot;y&quot;`</span><br><span class="line">&#125;</span><br><span class="line">type addResult struct &#123;</span><br><span class="line">	Code int `json:&quot;code&quot;`</span><br><span class="line">	Data int `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	url := &quot;http://127.0.0.1:9090/add&quot;</span><br><span class="line">	param := addParam&#123;</span><br><span class="line">		X: 10,</span><br><span class="line">		Y: 20,</span><br><span class="line">	&#125;</span><br><span class="line">	// marshal to json</span><br><span class="line"></span><br><span class="line">	paramBytes, _ := json.Marshal(param)</span><br><span class="line">	// call</span><br><span class="line">	resp, _ := http.Post(url, &quot;application/json&quot;, bytes.NewReader(paramBytes))</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line">	respBytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	var respData addResult</span><br><span class="line">	json.Unmarshal(respBytes, &amp;respData)</span><br><span class="line">	fmt.Println(respData.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而RPC调用则不需要如此</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">service.go</span><br><span class="line">type Args struct &#123;</span><br><span class="line">	X, Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ServiceA struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Add is an out method</span><br><span class="line">// has two args and a return </span><br><span class="line">// two params must be out </span><br><span class="line">// and the return value must be error type </span><br><span class="line">func (s *ServiceA) Add(args *Args, reply *int) error &#123;</span><br><span class="line">	*reply = args.X + args.Y</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line">server.go</span><br><span class="line">func main() &#123;</span><br><span class="line">  //new service instance   </span><br><span class="line">	service := new(yunyuansheng.ServiceA)</span><br><span class="line">  //register rpc service   </span><br><span class="line">	rpc.Register(service) </span><br><span class="line">  //botton on http  </span><br><span class="line">	//rpc.HandleHTTP()      </span><br><span class="line">  //botton on tcp   </span><br><span class="line">	l, e := net.Listen(&quot;tcp&quot;, &quot;:9091&quot;)</span><br><span class="line">	if e != nil &#123;</span><br><span class="line">		log.Fatal(&quot;listen error:&quot;, e)</span><br><span class="line">	&#125;</span><br><span class="line">	//http.Serve(l, nil)</span><br><span class="line">	for &#123;</span><br><span class="line">	  // accpet the request and serve   </span><br><span class="line">		conn, _ := l.Accept()</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">client.go</span><br><span class="line">func main() &#123;</span><br><span class="line">	//因为服务端是HTTP请求 所以要建立HTTP连接</span><br><span class="line">	client, err := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:9091&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 同步调用 Call</span><br><span class="line">	args := &amp;yunyuansheng.Args&#123;10, 20&#125;</span><br><span class="line">	reply := new(int)</span><br><span class="line">	err = client.Call(&quot;ServiceA.Add&quot;, args, reply)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;ServiceA.Add error:&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;ServiceA.Add %d+%d=%d\n&quot;, args.X, args.Y, *reply)</span><br><span class="line"></span><br><span class="line">	//异步调用 Go</span><br><span class="line">	var reply2 int</span><br><span class="line">	divCall := client.Go(&quot;ServiceA.Add&quot;, args, &amp;reply2, nil)</span><br><span class="line">	replyCall := &lt;-divCall.Done //Done是一个调用结果的通知 有值了就说明调用完成了</span><br><span class="line">	fmt.Println(replyCall.Error)</span><br><span class="line">	fmt.Println(reply2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>RPC的最终目的：让调用远程方法更加简单，并且速度更快</strong></p>
<p><strong>Go原生net&#x2F;rpc库需要注意的几点</strong></p>
<p><strong>1.可以支持很多种协议，包括但不限于HTTP和TCP，如果使用HTTP的话，那么客户端就使用DialHTTP，服务端通过HandleHTTP进行HTTP连接的处理，使用TCP的话，客户端使用Dial，服务端就应该for循环处理连接</strong></p>
<p><strong>2.客户端支持同步调用和异步调用两种方式，对应的分别是Call和Go</strong></p>
<p><strong>3.暴露出的服务必须满足两个条件，两个参数，一个返回值，返回值必须要是error类型，第二个参数必须是指针</strong></p>
<h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><p><img src="/2023/02/24/Go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/6.png" alt="img"></p>
<ol>
<li>client以本地调用方式调用服务</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体</li>
<li>client stub找到服务地址，并将服务发送到服务端</li>
<li>server 接收到消息之后，通过server stub对消息进行解码</li>
<li>server stub根据解码的结果调用本地服务</li>
<li>本地服务执行并把消息返回给server stub</li>
<li>server stub将结果打包成能够进行网络传输的结构体，发送到消息方</li>
<li>client 收到消息并进行解码，得到最终结果</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">实习求职总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-24 11:08:23" itemprop="dateCreated datePublished" datetime="2023-02-24T11:08:23+08:00">2023-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-04 20:52:49" itemprop="dateModified" datetime="2023-03-04T20:52:49+08:00">2023-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%84%9F%E6%82%9F%E5%8F%8A%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index"><span itemprop="name">感悟及认知</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我一直觉得博客嘛，就应该发一些技术相关的东西，看了很多同龄人的博客我才发现，其实博客可以发的东西有很多很多，不一定要仅限于技术，于是就有了这篇文章。</p>
<p>同时我是一个很喜欢用文字记录生活与想法的人，但是由于文字功底太弱，这些文字大多都躺在我的备忘录和废纸篓里。</p>
<p>昨天看到了一个我很尊敬的学长写的一篇博文，深有所感。于是想把这篇于2023-2-24日写好的博文修改一下，记录一下大学这两年的一些经历，感悟和想法。</p>
<p>还记得去年这个时候我还没有开始准备实习，那段时间应该是在完成工作室的考核，现在回头看看其实已经走出去很远了。</p>
<p>下面简单说一下我找实习的几个阶段吧。</p>
<h1 id="stage-one"><a href="#stage-one" class="headerlink" title="stage one"></a>stage one</h1><p>在21年年底的时候，我在QQ空间里面看到了有学长分享食铁兽招新的信息，然后加入了招新QQ群，22年1月13日，那时候我刚考完《数据结构》这门课，这也是那学期的最后一门考试，考完之后打算和我的爱人去主城区耍的，然后突如其来的约面了，那是我人生中的第一次技术面试，说实话答得很差，完全没有准备过八股，只能凭借平常做项目的一些实践经历答上来一部分问题，大概只答上来了一小半吧，我印象很深的问题有Redis的持久化，Redis的数据结构，HTTP2的特性这些，面试官还和我讨论了一下Go的优劣和以后职业规划的事情。</p>
<p>之后食铁兽的负责人晚上又和我联系了一下，简单问了一些职业发展之类的问题。</p>
<p>第二天通知我面试通过了，当时真的非常非常开心，第一次觉得自己在技术上或者说是在编程上被认可了，然后就打车去了食铁兽那边，见到了面试官源哥，婧姐，还有负责人峰哥。</p>
<p>之后的话就放寒假了，我当时在家不怎么学习，基本上都是食铁兽给的一些任务PUSH着我去学，比如尝试基于TCP、UDP、KCP、和HTTP编程，还有当时Go的最新版本是1.18beta，推出了泛型这一特性，但是还没有来得及对内置数据结构（slice map等）进行泛型的封装，于是我去学习了泛型，实现了简单的泛型封装，之后的任务就是写一个分布式消息队列。</p>
<p>差不多三月到五月吧，基本每个周末都会去食铁兽那边敲代码，慢慢的把分布式消息队列的拼图一块块补全，从raft选主的实现，到消息的存储和删除，到消息的切片，再到考虑结点状态进行消息的分发，慢慢的也把这个项目做出来了，这也是我第一个不看视频写出来的非web项目。</p>
<p>除了工程上的收获之外，我还认识了很多很厉害的大佬，比如源哥，给我的感觉就是在技术上钻的很深，不管是理论知识还是工程能力都很强，在大四的时候就能写出很多很多东西了，架构层面的知识也很优秀，之前问过他一点设计方面的题目，能感觉出来思考的方面特别多。而且他知识的广度也很大，前端后端嵌入式都会，现在我也大三下了，感觉我也很难在一年之后达到这样的水平。还有峰哥、翔哥、婧姐，就不一一说了，食铁兽的氛围是真的挺好的，这些哥哥姐姐们也很照顾我，在那边呆着也很舒服。</p>
<h1 id="stage-two"><a href="#stage-two" class="headerlink" title="stage two"></a>stage two</h1><p>差不多五月开始正式准备八股和算法了，那段时间的学习强度真的特别大，差不多白天一整天都在工作室呆着，学到脑子疼才结束，晚上睡眠质量也差，差不多准备了两个礼拜之后就开始投递简历了，尴尬的事情来了，投了很多厂子，不过大部分厂子看到是24届就直接拒了，最后好像只有几个小厂还有字节给了面试机会，字节的算法没做出来，于是一面挂，拿了一个小厂的offer但是不太想去。</p>
<h1 id="stage-three"><a href="#stage-three" class="headerlink" title="stage three"></a>stage three</h1><p>没有找到合适的实习就选择了去老师的实验室干活，做的是偏运维的华为HPC高性能迁移项目，其实就是写脚本，不过真的挺折磨的，需要保证一个大的脚本一次性执行成功。做完了就差不多七月底了，八月主要是在陪我的爱人，当时自己也生病了，除了复习八股之外还学了一些gRPC，做了一个简单的分布式系统来巩固知识。九月回校，这时候八股和算法都算比较巩固了，开始了新一轮的投递，两个礼拜下来面了五六家吧，也没有大厂愿意给面试机会，最后拿到了两个offer，分别是通明智云和daocloud，其实更想去daocloud，面试官说做的是容器方向，还能带薪做开源，狠狠的心动了，不过daocloud的给的薪资属实是有点少，算了一下得贴钱实习，于是去了通明智云，在通明智云的实习期间也很舒服，我的leader很信任我直接让我和客户对接，为期三个月的实习确实有真的在做东西学东西，也从同事前辈们身上学到了很多东西，总之是一段很有意义的实习经历。</p>
<h1 id="stage-four"><a href="#stage-four" class="headerlink" title="stage four"></a>stage four</h1><p>差不多十二月的时候，当时考虑到通明这边的实习期快到了，于是开启了新一轮的投递，可能是因为在盘hc，同样的也没有大厂面试机会，一轮面下来也拿了几个小厂的offer，而且待遇也不是很好，做的东西也不太感兴趣，唯一感兴趣的可能是默安科技的云原生开发，但是突如其来的我的爱人与我分手了，当时就不太想去实习了，想回家修养一阵子，于是把offer给拒了，在流程中的面试也给推了。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/1.png" alt="image-20230224111242791"></p>
<h1 id="stage-five"><a href="#stage-five" class="headerlink" title="stage five"></a>stage five</h1><p>年后市场开始复苏了，从一月底开始投递，一共投的也就那么几家吧，最后拿到了百度中台和莉莉丝运维的offer，最后打算去百度。</p>
<p><img src="/2023/02/24/%E5%AE%9E%E4%B9%A0%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93/2.png" alt="image-20230224111357693"></p>
<h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>从大一确定毕业就业开始，我就很想去大厂实习，但是拿到大厂offer之后也没有很开心，是真的没有波澜，很平淡，和我当时通过食铁兽面试，拿到通明智云的offer一样，非常平淡。也许这就是人生吧，很多事情不要太去追求结果，这样在结果不如意的时候真的会很痛苦，结果如意了也不见得开心，多关注过程，那些奋斗的日子回过头看是真的挺美好的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="安妮的心动录">
      <meta itemprop="description" content="永远不要高估自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安妮的心动录的园子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式的学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-02-22 14:54:48 / 修改时间：14:57:12" itemprop="dateCreated datePublished" datetime="2023-02-22T14:54:48+08:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h3 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h3><p>模式：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，也就是说，<strong>设计模式是在特定环境下人们解决某类重复出现问题的一套成功或者有效的解决方案</strong></p>
<h3 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h3><p><strong>Gang of Four提出了软件设计模式</strong><br>Gof提出的设计模式有23个，包括</p>
<ul>
<li>创建型模式：如何创建对象</li>
<li>结构型模式：如何实现类或者对象的组合</li>
<li>行为型模式：类或者对象怎么交互以及怎样分配职责</li>
</ul>
<p>“简单工厂模式”不属于23种<br>设计模式：GOF的23种+简单工厂模式<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/1.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/16.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/17.png" alt="image.png"><br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/2.png" alt="image.png"></p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计原则是设计模式的核心思想，一共有七种</p>
<ul>
<li>单一职责原则： 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个</li>
<li><strong>开闭原则</strong>：类的改动<strong>是通过增加代码</strong>进行的，而不是修改源代码</li>
<li>里氏代换原则：任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能</li>
<li><strong>依赖倒转原则</strong>：依赖于抽象（接口），不要依赖具体的实现（类），也就是<strong>针对接口</strong>编程</li>
<li>接口隔离原则：不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去</li>
<li>合成复用原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合</li>
<li><strong>迪米特法则</strong>：<strong>一个对象应当对其他对象尽可能少的了解</strong>，从而降低各个对象之间的耦合，提高系统的可维护性，例如在一个程序中，各个模块相互调用时，通常会提供一个同一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变的时候，不会影响其他模块的使用（黑盒原理）</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>类的职责是单一的，对外只提供一种功能，而引起类变化的原因也应该只有一个<br>在面向对象编程的过程中，设计一个类，建议对外提供的功能单一，接口单一，影响一个类的范围就限定在这一个接口上，一个类的一个接口具备这个类的功能含义，职责单一不复杂<br><strong>一个类对外只提供一种功能</strong><br><strong>实例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 以下代码不遵循单一职责原则，一个类实现了多个功能</span><br><span class="line">// 即一个clothes结构体实现了“工作装扮”和“逛街装扮”两个方法</span><br><span class="line">type Clothes struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (c *Clothes) Style() &#123;</span><br><span class="line">//	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (c *Clothes) Style2() &#123;</span><br><span class="line">//	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	c := Clothes&#123;&#125;</span><br><span class="line">//	c.Style()</span><br><span class="line">//	c.Style2()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 单一职责原则</span><br><span class="line">// 每一个类（结构体）负责一个功能或者一个逻辑</span><br><span class="line"></span><br><span class="line">type ClothesShop struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClothesWork struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesWork) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;工作的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ClothesShop) Style() &#123;</span><br><span class="line">	fmt.Println(&quot;逛街的装扮&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	c := ClothesWork&#123;&#125;</span><br><span class="line">	c.Style()</span><br><span class="line">	c1 := ClothesShop&#123;&#125;</span><br><span class="line">	c1.Style()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则的核心思想就是当我们添加一个新功能的时候，不是通过修改代码，而是通过增添代码来实现的。<br>如果我们使用接口<code>interface</code>就可以进行一层抽象，然后提供一个抽象的方法供业务进行实现。<br><strong>增加功能的时候去增加代码而不是修改代码</strong><br><strong>示例代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 以下代码是平铺式设计 每当添加一个业务就需要增加方法 会导致Banker类越来越臃肿</span><br><span class="line">// 不符合开闭原则  每当有新的功能出现就要对类添加对应功能的代码</span><br><span class="line">// 当Banker业务越多再修改Banker的业务或者添加新业务的时候 出现问题的问题也会越来越大</span><br><span class="line">// 耦合度太高 Banker的职责也不够单一 代码的维护成本与业务的复杂程度成正比</span><br><span class="line"></span><br><span class="line">//type Banker struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Save() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 存款业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Transfer() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 转账业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Banker) Pay() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 支付业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">// 新增的Deal服务</span><br><span class="line">//func (b *Banker) Deal() &#123;</span><br><span class="line">// fmt.Println(&quot;进行了 交易业务...&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">// banker := &amp;Banker&#123;&#125;</span><br><span class="line">// banker.Save()</span><br><span class="line">// banker.Transfer()</span><br><span class="line">// banker.Pay()</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 开闭原则</span><br><span class="line">// 在Go中的描述就是通过接口实现多态，每个类去实现接口</span><br><span class="line">// 这样的话就能实现一个结果：类的改动是通过增加代码进行的，而不是修改源代码</span><br><span class="line"></span><br><span class="line">type AbstractBanker interface &#123;</span><br><span class="line">   Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SaveBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SaveBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了存款&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加转账功能</span><br><span class="line"></span><br><span class="line">type TransferBanker struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tb *TransferBanker) Business() &#123;</span><br><span class="line">   fmt.Println(&quot;进行了转账&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以基于抽象层进行业务封装-针对interface接口进行封装</span><br><span class="line"></span><br><span class="line">func BankBusiness(banker AbstractBanker) &#123;</span><br><span class="line">   banker.Business()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sb := SaveBanker&#123;&#125;</span><br><span class="line">   sb.Business()</span><br><span class="line">   tb := TransferBanker&#123;&#125;</span><br><span class="line">   tb.Business()</span><br><span class="line">   BankBusiness(&amp;sb)</span><br><span class="line">   BankBusiness(&amp;tb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>在设计一个系统的时候我们可以将模块分成三个层次，抽象层、实现层、业务逻辑层。我们首先将抽象层的模块和接口定义出来，然后通过interface接口的设计依照抽象层依次实现每个实现层的模块，在我们写实现层代码的时候，实际上只需要参考对应的抽象层，实现每个模块。而业务逻辑层也是通过抽象层暴露出来的接口进行实现的，可以使用的方法就是抽象层暴露出来的方法<br><strong>模块与模块之间依赖抽象而不是具体实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// 下面的代码耦合度很高，不满足依赖倒转原则</span><br><span class="line">// 如果要满足张三开宝马，李四开奔驰，就需要重新添加代码</span><br><span class="line">// 如果司机人数为m，汽车数量为n，那么需要编写的方法为m*n</span><br><span class="line"></span><br><span class="line">//type Benz struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *Benz) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;Benz is running&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type BMW struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (b *BMW) Run() &#123;</span><br><span class="line">//	fmt.Println(&quot;BMW is runnning&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Zhang3 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (z *Zhang3) DriveBenz(benz *Benz) &#123;</span><br><span class="line">//	benz.Run()</span><br><span class="line">//	fmt.Println(&quot;Zhang3 is driving Benz&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//type Li4 struct &#123;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func (l *Li4) DriveBMW(bmw *BMW) &#123;</span><br><span class="line">//	bmw.Run()</span><br><span class="line">//	fmt.Println(&quot;Li4 is driving BMW&quot;)</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//func main() &#123;</span><br><span class="line">//	benz := &amp;Benz&#123;&#125;</span><br><span class="line">//	zhang3 := Zhang3&#123;&#125;</span><br><span class="line">//	zhang3.DriveBenz(benz)</span><br><span class="line">//	bmw := &amp;BMW&#123;&#125;</span><br><span class="line">//	li4 := Li4&#123;&#125;</span><br><span class="line">//	li4.DriveBMW(bmw)</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Car interface &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Driver interface &#123;</span><br><span class="line">	Driver(car Car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">// 每个车子都实现Run方法</span><br><span class="line">// 每个司机都实现Drive方法</span><br><span class="line">// 这样需要实现的方法为m+n </span><br><span class="line">// 而且实现层只依赖于抽象层</span><br><span class="line">type Benz struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Benz) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;Benz is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BMW struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *BMW) Run() &#123;</span><br><span class="line">	fmt.Println(&quot;BMW is Running&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Zhang3 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (z3 *Zhang3) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Li4 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l4 *Li4) Drive(car Car) &#123;</span><br><span class="line">	fmt.Println(&quot;li4 drive car&quot;)</span><br><span class="line">	car.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var benz Car = new(Benz)</span><br><span class="line">	z := new(Zhang3)</span><br><span class="line">	z.Drive(benz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。<br><strong>使用组合来实现父类方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Cat) Eat() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫吃饭&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用继承来实现 添加一个睡觉的方法</span><br><span class="line"></span><br><span class="line">type CatB struct &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *CatB) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用组合来添加可睡觉的方法</span><br><span class="line"> </span><br><span class="line">type CatC struct &#123;</span><br><span class="line">	C *Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cc *CatC) Sleep() &#123;</span><br><span class="line">	fmt.Println(&quot;小猫睡觉 &quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	c := &amp;Cat&#123;&#125;</span><br><span class="line">	c.Eat()</span><br><span class="line">	cb := &amp;CatB&#123;&#125;</span><br><span class="line">	cb.Eat()</span><br><span class="line">	cb.Sleep()</span><br><span class="line">	cc := &amp;CatC&#123;&#125;</span><br><span class="line">	cc.Sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>依赖第三方进行解耦</strong></p>
<h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><p>接口的意义就是实现多态的思想，我们可以根据interface类型来设计API接口，那么这种API接口的适应能力不仅能够适应当下所实现的全部模块，也适应未来实现的模块来进行调用。<code>**调用未来**</code>也许是接口最大的意义所在，良好的架构师可以针对interface进行设计一套框架，在未来的许多年后仍然可以适用</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/3.png" alt="image.png"><br>思想就是可以通过添加一层<strong>工厂模块</strong>，来做到业务逻辑层和基础模块层之间的耦合，避免业务逻辑层对基础模块层的直接依赖。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式并不属于GoF的23种设计模式，它是开发者自发认为的一种非常简易的设计模式，其角色和职责如下：</p>
<ul>
<li>工厂：简单工厂模式的核心，它负责创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需要的产品对象</li>
<li>抽象产品：简单工厂模式所创建的所有对象的分类，它负责描述实例所公有的公共接口</li>
<li>具体产品：简单工厂模式所创建的具体实例对象</li>
</ul>
<p>设计模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/4.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type Fruit interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type Apple struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Apple) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Banana struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Banana) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pear struct &#123;</span><br><span class="line">	Fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Pear) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂模块</span><br><span class="line"></span><br><span class="line">type Factory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Factory) CreateFruit(kind string) Fruit &#123;</span><br><span class="line">	var fruit Fruit</span><br><span class="line">	if kind == &quot;apple&quot; &#123;</span><br><span class="line">		fruit = new(Apple)</span><br><span class="line">	&#125; else if kind == &quot;banana&quot; &#123;</span><br><span class="line">		fruit = new(Banana)</span><br><span class="line">	&#125; else if kind == &quot;pear&quot; &#123;</span><br><span class="line">		fruit = new(Pear)</span><br><span class="line">	&#125;</span><br><span class="line">	return fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 逻辑层</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	factory := new(Factory)</span><br><span class="line">	apple := factory.CreateFruit(&quot;apple&quot;)</span><br><span class="line">	apple.Show()</span><br><span class="line">	banana := factory.CreateFruit(&quot;banana&quot;)</span><br><span class="line">	banana.Show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>实现了对象创建和使用的分离</li>
<li>不需要记住具体类名，记住参数就可以，减少使用者记忆量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对工厂职责过重，一旦不能工作，系统会受到影响</li>
<li>增加系统中类的个数，复杂度和理解度增加</li>
<li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的逻辑太复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li>抽象工厂：工厂的核心，任何工厂类都必须实现这个接口</li>
<li>工厂：具体工厂是抽象工厂的一个实现，负责实例化产品对象</li>
<li>抽象产品：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品：工厂方法模式所创建的具体实例对象</li>
</ul>
<p>简单工厂+开闭原则&#x3D;工厂<br>模式类图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/5.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type fruit interface &#123;</span><br><span class="line">	show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 工厂类（抽象的接口）</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateFruit() fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 基础模块层</span><br><span class="line"></span><br><span class="line">type apple struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *apple) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type banana struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *banana) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type pear struct &#123;</span><br><span class="line">	fruit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *pear) show() &#123;</span><br><span class="line">	fmt.Println(&quot;i am pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AppleFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *AppleFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(apple)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type BananaFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *BananaFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(banana)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PearFactory struct &#123;</span><br><span class="line">	AbstractFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (fac *PearFactory) CreateFruit() fruit &#123;</span><br><span class="line">	var f fruit</span><br><span class="line">	f = new(pear)</span><br><span class="line">	return f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 业务逻辑层</span><br><span class="line">func main() &#123;</span><br><span class="line">	//需求1 需要一个具体的苹果对象</span><br><span class="line">	//需要一个具体的苹果工厂</span><br><span class="line">	var a AbstractFactory</span><br><span class="line">	a = new(AppleFactory)</span><br><span class="line">	//生产一个具体的水果</span><br><span class="line">	var apple fruit</span><br><span class="line">	apple = a.CreateFruit()</span><br><span class="line">	apple.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ul>
<li>不需要记住具体类名，甚至连具体参数都不用记忆</li>
<li>实现了对象创建和使用的分离</li>
<li>系统的可拓展性也变得非常好，不需要修改接口和原类</li>
<li>对于新产品的创建，符合开闭原则</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加系统中的类的个数，复杂度和理解度增加</li>
<li>增加了系统的抽象性</li>
</ul>
<p><strong>适用场景</strong></p>
<ol>
<li>客户端不知道它所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定创建哪个对象</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。因此，可以将一些相关的产品组成一个“产品族”，从而由同一个工厂来统一生产。</p>
<ul>
<li>抽象工厂：它声明了一组用于创建一组产品的方法，每一个方法对应一种产品</li>
<li>具体工厂：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某在产品等级结构中</li>
<li>抽象产品：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li>
<li>具体产品：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li>
</ul>
<p>模式例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/6.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 抽象层</span><br><span class="line"></span><br><span class="line">type AbstractApple interface &#123;</span><br><span class="line">	ShowApple()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractBanana interface &#123;</span><br><span class="line">	ShowBanana()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AbstractPear interface &#123;</span><br><span class="line">	ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的工厂</span><br><span class="line"></span><br><span class="line">type AbstractFactory interface &#123;</span><br><span class="line">	CreateApple() AbstractApple</span><br><span class="line">	CreateBanana() AbstractBanana</span><br><span class="line">	CreatePear() AbstractPear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line"></span><br><span class="line">type ChinaApple struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaBanana struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaPear struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChinaFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ca *ChinaApple) ShowApple() &#123;</span><br><span class="line">	fmt.Println(&quot;china apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cb *ChinaBanana) ShowBanana() &#123;</span><br><span class="line">	fmt.Println(&quot;china banana&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cp *ChinaPear) ShowPear() &#123;</span><br><span class="line">	fmt.Println(&quot;china pear&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateApple() AbstractApple &#123;</span><br><span class="line">	var apple AbstractApple</span><br><span class="line">	apple = new(ChinaApple)</span><br><span class="line">	return apple</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;</span><br><span class="line">	var b AbstractBanana</span><br><span class="line">	b = new(ChinaBanana)</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cf *ChinaFactory) CreatePear() AbstractPear &#123;</span><br><span class="line">	var p AbstractPear</span><br><span class="line">	p = new(ChinaPear)</span><br><span class="line">	return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 需要中国的水果</span><br><span class="line">	//1. 创建中国工厂</span><br><span class="line">	var cF AbstractFactory</span><br><span class="line">	cF = new(ChinaFactory)</span><br><span class="line">	var cApple AbstractApple</span><br><span class="line">	cApple = cF.CreateApple()</span><br><span class="line">	cApple.ShowApple()</span><br><span class="line">	var cBanana AbstractBanana</span><br><span class="line">	cBanana = cF.CreateBanana()</span><br><span class="line">	cBanana.ShowBanana()</span><br><span class="line">	var cPear AbstractPear</span><br><span class="line">	cPear = cF.CreatePear()</span><br><span class="line">	cPear.ShowPear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>用于工厂方法模式的优点</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”</li>
</ol>
<p>缺点</p>
<ol>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了”开闭原则“</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族，可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>产品等级结构稳定。设计完成之后，不会像系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<h3 id="三种工厂的区别"><a href="#三种工厂的区别" class="headerlink" title="三种工厂的区别"></a>三种工厂的区别</h3><ul>
<li>简单工厂：一个工厂负责创建所有产品，违反开闭原则，添加新产品需要修改工厂逻辑，工厂会变得越来越复杂</li>
<li>工厂：一个工厂创建一个产品，系统的可扩展性非常好，无需修改接口和类，但是系统中类的个数变多，复杂度和理解度增加</li>
<li>抽象工厂：一个工厂创建一系列（同一个产品族）的产品，增加新的产品族很方便，无需修改已有系统，符合开闭原则，增加新的产品等级结构很麻烦，需要对原有系统进行较大的修改，违背了开闭原则，相当于在工厂方法的模式下进行了折中，如果产品结构等级稳定，那么就相当于完全遵循开闭</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。<br>要解决的问题是：保证一个类永远只能有一个对象，且该对象的功能依然能被其他模块使用。<br>类图：<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/7.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//三个要点</span><br><span class="line">// 某个类只能有一个实例</span><br><span class="line">// 它必须自行创建这个实例</span><br><span class="line">// 必须自行向整个系统提供这个实例</span><br><span class="line"></span><br><span class="line">// 总结：一个类永远只能有一个对象，这个对象还能被系统的其他模块使用</span><br><span class="line"></span><br><span class="line">//1. 因为这个类必须保证私有化 所以首字母要小写</span><br><span class="line">type singelton struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 2.指针只能指向这个唯一对象，但是这个指针不能改变方向，也必须小写</span><br><span class="line">var instance *singelton = new(singelton)</span><br><span class="line"></span><br><span class="line">// 3.对外提供一个方法来获取到这个对象 把instance的写权限去掉 只暴露读权限</span><br><span class="line"></span><br><span class="line">func GetInstance() *singelton &#123;</span><br><span class="line">	return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *singelton) DoSomeThing() &#123;</span><br><span class="line">	fmt.Println(&quot;Do something&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := GetInstance()</span><br><span class="line">	s.DoSomeThing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 懒汉式的单例模式:只有被第一次访问的时候 才给instance赋值 平常为nil</span><br><span class="line">// 但是懒汉式可能有并发问题： 同时有两个Getinstance同一时刻首次调用 那么就会出现两个instance 可以加锁解决</span><br><span class="line">// 锁的粒度太大了 可以通过一个uint的标记 使用atomic.LoadUnit函数判断 不用每次访问都加锁</span><br><span class="line">// 或者直接使用sync.Once进行new 这是对atomic.LoadUint的封装</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>单例模式提供了对唯一实例的受控访问</li>
<li>节约系统资源，由于在系统内存中只存在一个对象</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩展性差，单利模式中没有抽象层</li>
<li>单例类的职责过重</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统只需要一个实例对象，比如系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li>
<li>客户调用类的单个实力只允许使用一个公共访问点，除了该节点之外，不能通过其他途径访问该实例</li>
</ol>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>Proxy模式又叫代理模式，可以为其他对象提供一种代理（Proxy）以控制对这个对象的访问。<br>所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类进行交互</p>
<ul>
<li>抽象主题：真实主题与代理主题的共同接口</li>
<li>真实主题：定义了代理角色所代表的真实对象</li>
<li>代理主题角色：含有对真实主题角色的引用，代理角色通常在客户端调用给真实主题对象之前或者之后执行某些操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/8.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">type Goods struct &#123;</span><br><span class="line">	Kind string</span><br><span class="line">	Fact bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象层</span><br><span class="line">type Shopping interface&#123;</span><br><span class="line">	Buy(goods *Goods)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现层</span><br><span class="line">type KoreaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ks *KoreaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go korea buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AmericaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AmericaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go america buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AfricaShopping struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (as *AfricaShopping) Buy(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;go africa buy&quot;, good.Kind)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 海外代理</span><br><span class="line"></span><br><span class="line">type OverSeasProxy struct &#123;</span><br><span class="line">	shopping Shopping</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) Buy(good *Goods) &#123;</span><br><span class="line">	//1.辨别真伪</span><br><span class="line">	if op.distinguish(good) == true &#123;</span><br><span class="line">		op.shopping.Buy(good)</span><br><span class="line">		op.check(good)</span><br><span class="line">	&#125;</span><br><span class="line">	//2.调用具体需要被代理的Buy方法</span><br><span class="line">	//3.海关安检</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辨别真伪</span><br><span class="line">func (op *OverSeasProxy) distinguish(goods *Goods) bool &#123;</span><br><span class="line">	fmt.Println(&quot;对&quot;, goods.Kind, &quot;进行了辨别真伪&quot;)</span><br><span class="line">	if goods.Fact == false &#123;</span><br><span class="line">		fmt.Println(&quot;发现假货&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return goods.Fact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (op *OverSeasProxy) check(good *Goods) &#123;</span><br><span class="line">	fmt.Println(&quot;通过海关&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewProxy(s Shopping) Shopping &#123;</span><br><span class="line">	return &amp;OverSeasProxy&#123;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	g1 := Goods&#123;</span><br><span class="line">		Kind: &quot;韩国面膜&quot;,</span><br><span class="line">		Fact: true,</span><br><span class="line">	&#125;</span><br><span class="line">	g2 := Goods&#123;</span><br><span class="line">		Kind: &quot;苹果&quot;,</span><br><span class="line">		Fact: false,</span><br><span class="line">	&#125;</span><br><span class="line">	var k Shopping = new(KoreaShopping)</span><br><span class="line">	var p Shopping</span><br><span class="line">	p = NewProxy(k)</span><br><span class="line">	p.Buy(&amp;g1)</span><br><span class="line">	var a Shopping = new(AmericaShopping)</span><br><span class="line">	p = NewProxy(a)</span><br><span class="line">	p.Buy(&amp;g2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.能够协调调用者和被调用者，在一定程度上降低了系统的耦合度<br>2.客户端可以针对抽象主题角色进行编程，符合开闭原则，系统具有姣好的灵活性和可拓展性<br>缺点：<br>1.实现较为复杂<br><strong>适用场景</strong><br>为其他对象提供一种代理以控制对这个对象的访问</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式（Decorator）用来动态地给一个对象增加一些额外的职责，比生成子类实现更加灵活<br>装饰模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用模式的时候，我们常常在一个代理类中创建一个对象的实例。并且当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<ul>
<li>抽象构件：是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方法处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件：它是抽象构建类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/9.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">type Phone interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象的装饰器，装饰器的基础类</span><br><span class="line"></span><br><span class="line">type Decorator struct &#123;</span><br><span class="line">	phone Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Decorator) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的构件</span><br><span class="line"></span><br><span class="line">type Huawei struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (hw *Huawei) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a huawei phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Xiaomi struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (xm *Xiaomi) Show() &#123;</span><br><span class="line">	fmt.Println(&quot;it is a xiaomi phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MoDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md *MoDecorator) Show() &#123;</span><br><span class="line">	md.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a mo phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMoDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;MoDecorator&#123;Decorator&#123;</span><br><span class="line">		p,</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KeDecorator struct &#123;</span><br><span class="line">	Decorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kd *KeDecorator) Show() &#123;</span><br><span class="line">	kd.phone.Show()</span><br><span class="line">	fmt.Println(&quot;it is a ke phone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewKeDecorator(p Phone) Phone &#123;</span><br><span class="line">	return &amp;KeDecorator&#123;Decorator&#123;p&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var hw Phone</span><br><span class="line">	hw = new(Huawei)</span><br><span class="line">	hw.Show()</span><br><span class="line">	var mo Phone</span><br><span class="line">	mo = NewMoDecorator(hw)</span><br><span class="line">	mo.Show()</span><br><span class="line">	var ke Phone</span><br><span class="line">	ke = NewKeDecorator(hw)</span><br><span class="line">	ke.Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰</li>
<li>具体构建类与具体装饰类可以独立变化，符合开闭</li>
</ol>
<p>缺点：</p>
<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活激动的解决方案，同时意味着排错也比较困难</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行拓展或者采用继承不利于系统拓展和维护时可以使用装饰模式</li>
</ol>
<h3 id="装饰与代理的区别"><a href="#装饰与代理的区别" class="headerlink" title="装饰与代理的区别"></a>装饰与代理的区别</h3><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<ul>
<li>目标抽象类：定义客户所需接口，可以是具体类也可以是抽象接口</li>
<li>适配器类：可以调用另一个接口，作为一个转换器，让目标抽象类和适配者类进行适配</li>
<li>适配者类：被适配的角色，定义了一个已经存在的接口，这个接口需要适配</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/10.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">type V5 interface &#123;</span><br><span class="line">	Use5V()</span><br><span class="line">&#125;</span><br><span class="line">type V220 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type phone struct &#123;</span><br><span class="line">	v V5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (v *V220) Use220V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用220V的电压 &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adapter struct &#123;</span><br><span class="line">	v220 *V220</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Adapter) Use5V() &#123;</span><br><span class="line">	fmt.Println(&quot;使用适配器，以220V的电压充电&quot;)</span><br><span class="line">	a.v220.Use220V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPhone(v V5) *phone &#123;</span><br><span class="line">	return &amp;phone&#123;v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewAdapter(v220 *V220) *Adapter &#123;</span><br><span class="line">	return &amp;Adapter&#123;v220&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *phone) Charge() &#123;</span><br><span class="line">	fmt.Println(&quot;Phone 进行了充电&quot;)</span><br><span class="line">	p.v.Use5V()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	phone := NewPhone(NewAdapter(&amp;V220&#123;&#125;))</span><br><span class="line">	phone.Charge()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：</p>
<ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都很好，可以很方便地更换适配器，符合开闭原则</li>
</ol>
<p>缺点：<br>适配器中置换适配者类的某些方法比较麻烦<br><strong>适应场景</strong><br>1.系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码<br>2.想创建一个可以重复使用的类，用来与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式(Facade)，为一组具有类型功能的类群，比如类库，子系统等等，提供一个一致的简单的界面</p>
<ul>
<li>外观角色：为调用方，定义简单的调用接口</li>
<li>子系统角色：功能提供方，指提供功能的类群</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/11.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">type SubSystemA struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemB struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemC struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SubSystemD struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sa *SubSystemA) MethodA() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sb *SubSystemB) MethodB() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method b&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sc *SubSystemC) MethodC() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method c&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sd *SubSystemD) MethodD() &#123;</span><br><span class="line">	fmt.Println(&quot;sub method d&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 外观类</span><br><span class="line">type Facade struct &#123;</span><br><span class="line">	a *SubSystemA</span><br><span class="line">	b *SubSystemB</span><br><span class="line">	c *SubSystemC</span><br><span class="line">	d *SubSystemD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodOne() &#123;</span><br><span class="line">	f.a.MethodA()</span><br><span class="line">	f.b.MethodB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *Facade) MethodTwo() &#123;</span><br><span class="line">	f.c.MethodC()</span><br><span class="line">	f.d.MethodD()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f := Facade&#123;&#125;</span><br><span class="line">	f.MethodOne()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。<br>2.它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可<br>3.一个子系统的修改对其他子系统没有任何影响<br>缺点;<br>1.不能很好的限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性<br>2.如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则<br><strong>适用场景</strong></p>
<ol>
<li>复杂系统需要简单入口使用</li>
<li>客户端程序与多个子系统之间存在很大的依赖性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系</li>
</ol>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><ul>
<li>抽象类：在抽象类中定义了一系列基本操作，可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或者实现这些步骤</li>
<li>具体子类：是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/12.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 抽象类 做饮料</span><br><span class="line"></span><br><span class="line">type Beverage interface &#123;</span><br><span class="line">	BoilWater()</span><br><span class="line">	Brew()</span><br><span class="line">	PourInCup()</span><br><span class="line">	AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装一套流程模板</span><br><span class="line">type template struct &#123;</span><br><span class="line">	b Beverage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *template) MakeBeverage() &#123;</span><br><span class="line">	if t == nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	t.b.BoilWater()</span><br><span class="line">	t.b.Brew()</span><br><span class="line">	t.b.PourInCup()</span><br><span class="line">	t.b.AddThings()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MakeCoffee struct &#123;</span><br><span class="line">	template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) BoilWater() &#123;</span><br><span class="line">	fmt.Println(&quot;boil the water&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) Brew() &#123;</span><br><span class="line">	fmt.Println(&quot;use boiled water to brew&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) PourInCup() &#123;</span><br><span class="line">	fmt.Println(&quot;pour the coffee to the cup&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mc *MakeCoffee) AddThings() &#123;</span><br><span class="line">	fmt.Println(&quot;add sugar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMakeCoffee() *MakeCoffee &#123;</span><br><span class="line">	m := new(MakeCoffee)</span><br><span class="line">	m.b = m</span><br><span class="line">	return m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	makeCoffee := NewMakeCoffee()</span><br><span class="line">	makeCoffee.MakeBeverage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>优缺点</strong><br>优点：<br>1.在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时不会改变算法中步骤的执行顺序<br>2.模板方法是一种代码复用技术，他提取了类库中的公共行为，将公共行为放在父类中<br>3.可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行<br>4.不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则<br>缺点：<br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。<br><strong>适用场景</strong><br>1.具有同一的操作步骤或操作过程<br>2.具有不同的操作细节<br>3.存在多个具有同样操作步骤的应用场景，但某些具体的操作系统却各不相同<br>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个子类和操作步骤解耦合</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>讲一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式。命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不比知道如何完成请求。</p>
<ul>
<li>抽象命令类：一个抽象类或者接口，通过这些方法可以调用请求接收者的相关操作</li>
<li>具体命令类：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中</li>
<li>调用者：请求发送者，通过命令对象来执行请求</li>
<li>接收者：接收者执行与请求相关的操作</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/13.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">type Doctor struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatEye() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat eye&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Doctor) treatMouth() &#123;</span><br><span class="line">	fmt.Println(&quot;doctor treat mouth&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Command interface &#123;</span><br><span class="line">	Treat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatEye struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatEye) Treat() &#123;</span><br><span class="line">	cmd.d.treatEye()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CommandTreatMouth struct &#123;</span><br><span class="line">	d *Doctor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cmd *CommandTreatMouth) Treat() &#123;</span><br><span class="line">	cmd.d.treatMouth()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Nurse struct &#123;</span><br><span class="line">	CmdList []Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Nurse) Notify() &#123;</span><br><span class="line">	if len(n.CmdList) == 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	for _, cmd := range n.CmdList &#123;</span><br><span class="line">		cmd.Treat()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	doctor := new(Doctor)</span><br><span class="line">	cmdEye := CommandTreatEye&#123;doctor&#125;</span><br><span class="line">	cmdMouth := CommandTreatMouth&#123;doctor&#125;</span><br><span class="line">	nurse := new(Nurse)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdEye)</span><br><span class="line">	nurse.CmdList = append(nurse.CmdList, &amp;cmdMouth)</span><br><span class="line">	nurse.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.降低系统的耦合度<br>2.新的命令很容易添加到系统中，满足开闭原则<br>3.可以比较容易地设计一个命令队列或者宏命令<br>缺点：<br>使用命令模式可能会导致某些系统有过多的具体命令类，因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用<br><strong>适用场景</strong><br>1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无需知道接收者的存在，也许无知道接收者是谁<br>2.系统需要在不同的时间指定请求、将请求排队和执行请求<br>3.系统需要将一组操作组合在一起形成宏命令</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul>
<li>环境类：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略，在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类：它为所支持的算法声明了抽象方法，是所有策略类的父类，可以是抽象类或者具体类，也可以是接口</li>
<li>具体策略类：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类，使用一种具体的算法实现某个业务处理</li>
</ul>
<p>例图<br><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/14.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type WeaponStrategy interface &#123;</span><br><span class="line">	UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AK47 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ak *AK47) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用AK47战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Knife struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (k *Knife) UseWeapon() &#123;</span><br><span class="line">	fmt.Println(&quot;使用匕首战斗&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Hero struct &#123;</span><br><span class="line">	strategy WeaponStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) SetWeaponStrategy(s WeaponStrategy) &#123;</span><br><span class="line">	h.strategy = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *Hero) Fight() &#123;</span><br><span class="line">	h.strategy.UseWeapon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	hero := Hero&#123;&#125;</span><br><span class="line">	hero.SetWeaponStrategy(new(AK47))</span><br><span class="line">	hero.Fight()</span><br><span class="line">	hero.SetWeaponStrategy(new(Knife))</span><br><span class="line">	hero.Fight()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点：<br>1.策略模式提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或者行为<br>2.使用策略模式可以避免多重条件选择语句<br>3.策略模式提供了一种算法的复用机制<br>缺点：<br>1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类<br>2.策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类<br><strong>适用场景</strong><br>准备一组算法，并将每一个算法封装起来，使得它们可以互换</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出翻译。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<ul>
<li>抽象主题：被观察的对象</li>
<li>具体主题：被观察者的具体实现</li>
<li>观察者：接口或者抽象类</li>
<li>具体观察者：观察者的具体实现</li>
</ul>
<p><img src="/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0/15.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">type Listener interface &#123;</span><br><span class="line">	OnTeacherComing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Notifier interface &#123;</span><br><span class="line">	AddListener(l Listener)</span><br><span class="line">	RemoveListener(l Listener)</span><br><span class="line">	Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhang3 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhang3) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhang3 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuZhao4 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuZhao4) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;zhao4 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuWang5 struct &#123;</span><br><span class="line">	Badthing string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *StuWang5) OnTeacherComing() &#123;</span><br><span class="line">	fmt.Println(&quot;wang5 stop&quot;, s.Badthing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ClassMonitor struct &#123;</span><br><span class="line">	listenerList []Listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) AddListener(l Listener) &#123;</span><br><span class="line">	m.listenerList = append(m.listenerList, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) RemoveListener(l Listener) &#123;</span><br><span class="line">	for index, li := range m.listenerList &#123;</span><br><span class="line">		if li == l &#123;</span><br><span class="line">			m.listenerList = append(m.listenerList[:index], m.listenerList[index+1:]...)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *ClassMonitor) Notify() &#123;</span><br><span class="line">	for _, listener := range m.listenerList &#123;</span><br><span class="line">		listener.OnTeacherComing()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := &amp;StuZhang3&#123;</span><br><span class="line">		Badthing: &quot;抄作业&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s2 := &amp;StuZhao4&#123;</span><br><span class="line">		Badthing: &quot;玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	s3 := &amp;StuWang5&#123;</span><br><span class="line">		Badthing: &quot;看别人玩手机&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	classMonitor := new(ClassMonitor)</span><br><span class="line">	classMonitor.AddListener(s1)</span><br><span class="line">	classMonitor.AddListener(s2)</span><br><span class="line">	classMonitor.AddListener(s3)</span><br><span class="line">	classMonitor.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优缺点</strong><br>优点</p>
<ol>
<li>观察者模式可以实现表现层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>观察者模式在观察目标和观察者之间建立了一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，不需要了解其具体的观察者</li>
<li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li>观察者模式满足开闭原则</li>
</ol>
<p>缺点</p>
<ol>
<li>如果一个观察者对象有很多直接和间接的观察者，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间存在循环依赖，系统可能会发生崩溃</li>
<li>观察者模式没有响应的机制让观察者知道所观察到的对象是怎样发生变化的</li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这两个方面封装在独立的对象中使得它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致一个或者多个其他对象也发生改变</li>
<li>需要在系统中创建一个触发链路，A对象的行为影响B，B对象的行为影响C</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安妮的心动录"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">安妮的心动录</p>
  <div class="site-description" itemprop="description">永远不要高估自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/anneheartrecord" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anneheartrecord" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengxisheng777@gmail.com" title="E-Mail → mailto:chengxisheng777@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2523286318" title="QQ → 2523286318"><i class="gratipay fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安妮的心动录</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">93k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:24</span>
</div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
